{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2019-2022 U\u011fur CORUH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2019-2022 U\u011fur CORUH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"changelog/","text":"Changelog \u00b6 Material for Software Developers \u00b6 1.0.0 _ October 20, 2020 \u00b6 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#material-for-software-developers","text":"","title":"Material for Software Developers"},{"location":"changelog/#1.0.0","text":"Initial release","title":"1.0.0 _ October 20, 2020"},{"location":"syllabus/syllabus/","text":"Recep Tayyip Erdogan University \u00b6 Faculty of Engineering and Architecture \u00b6 Computer Engineering \u00b6 CE204 Object-Oriented Programming \u00b6 Syllabus \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Download WORD , PDF Instructor Asst. Prof. Dr. U\u011fur CORUH Contact Information ugur.coruh@erdogan.edu.tr Office No F-301 Google Classroom Code n24xrzo Lecture Hours and Days Theory - Monday (13:00-16:00) Lab \u2013 Thursday (10:00-12:00) Lecture Classroom D-203 Office Hours Meetings will be scheduled over Google Meet with your university account and email and performed via demand emails. Please send emails with the subject starts with [CE204] tag for the fast response and write formal, clear, and short emails. Lecture and Communication Language English Theory/Laboratory Course Hour Per Week 3/2 Hours Credit 4 Prerequisite CE103- Algorithms and Programming I CE100- Algorithms and Programming II Corequisite TBD Requirement TBD *TBD: To Be Defined. A.Course Description \u00b6 This course introduces advanced programming skills with a focus on object-oriented programming and design fundamentals using a high-level language such as Java. Object-oriented programming is the process of integrating software components into a large-scale software architecture. After learning the fundamentals of coding, this approach to software development is the next logical step, allowing for large-scale programs. The course focuses on understanding and applying object-oriented concepts such as classes, objects, data abstraction, methods, method overloading, inheritance, and polymorphism. The class will be built around sharing expertise and guiding students to find learning methods and practice for object-oriented programming topics. Making programming applications and projects in the courses will strengthen the learning process by putting theory into practice. B.Course Learning Outcomes \u00b6 After completing this course satisfactorily, a student will be able to: Design applications using OO techniques Use the unified software development process to manage software development Use UML for the notation diagrams of applications Apply useful design and architecture patterns for software development. C.Course Topics \u00b6 Object-oriented concepts Unified object-oriented analysis and design process Unified Model Language Use case analysis Object structure and behavior analysis System design Application architecture and design patterns Java implementation of object-oriented design D.Textbooks and Required Hardware or Equipment \u00b6 This course does not require a coursebook. If necessary, you can use the following books and open-source online resources. Timothy C. Lethbridge and Robert Lagani\u00e8re, Object-Oriented Software Engineering: Practical Software Development using UML and Java, McGraw Hill Walter Savitch, Absolute C++, Addison-Wesley Longman Intro to Java Programming, Comprehensive Version (10 th Edition) 10 th Edition by Y. Daniel Liang Harvey M. Deitel and Paul J. Deitel. 2001. Java How to Program (4 th . ed.). Prentice Hall PTR, USA. Paul Deitel and Harvey Deitel. 2016. Visual C# How to Program (6 th . ed.). Pearson. Additional Books TBD During this course, you should have a laptop for programming practices. You will have your development environment, and you will use this for examination and assignments also classroom practices. E.Grading System \u00b6 Midterm and Final grades will be calculated with the weighted average of the project or homework-based examinations. Midterm grades will be calculated between term beginning to the midterm week, and Final grades will be calculated between Midterm and Final week homeworks or projects as follow \\[ a_n=\\text{Homework or Project Weight} \\] \\[ HW_n=\\text{Homework or Project Points} \\] \\[ n=\\text{Number of Homework or Project} \\] \\[ Grade=(a_1HW_1+a_2HW_2+...+a_nHW_n)/n \\] Homework Weight Midterm %40 Final %60 \\[ \\text{Passing Grade}=(40*Midterm_{Grade}+60*Final_{Grade})/100 \\] F. Instructional Strategies and Methods \u00b6 The basic teaching method of this course will be planned to be face-to-face in the classroom, and support resources, homeworks, and announcements will be shared over google classroom. Students are expected to be in the university. This responsibility is very important to complete this course with success. If pandemic situation changes and distance education is required during this course, this course will be done using synchronous and asynchronous distance education methods. In this scenario, students are expected to be in the online platform, zoom, or meet at the time specified in the course schedule. Attendance will be taken G. Late Homework \u00b6 Throughout the semester, assignments must be submitted as specified by the announced deadline. Overdue assignments will not be accepted. Unexpected situations must be reported to the instructor for late homeworks by students H. Course Platform and Communication \u00b6 Google Classroom and Github will be used as a course learning management system. All electronic resources and announcements about the course will be shared on this platform. It is very important to check the course page daily, access the necessary resources and announcements, and communicate with the instructor to complete the course with success. I. Academic Integrity, Plagiarism & Cheating \u00b6 Academic Integrity is one of the most important principles of RTE\u00dc University. Anyone who breaches the principles of academic honesty is severely punished. It is natural to interact with classmates and others t.\"study together\". It may also be the case where a student asks to help from someone else, paid or unpaid, better understand a difficult topic or a whole course. However, what is the borderline between \"studying together\" or \"taking private lessons\" and \"academic dishonesty\"? When is it plagiarism, when is it cheating? It is obvious that looking at another student's paper or any source other than what is allowed during the exam is cheating and will be punished. However, it is known that many students come to university with very little experience concerning what is acceptable and what counts as \"copying,\"\" especially for assignments. The following are attempted as guidelines for the Faculty of Engineering and Architecture students to highlight the philosophy of academic honesty for assignments for which the student will be graded. Should a situation arise which is not described below, the student is advised to ask the instructor or assistant of the course whether what they intend to do would remain within the framework of academic honesty or not. a. What is acceptable when preparing an assignment? \u00b6 Communicating with classmates about the assignment to understand it better Putting ideas, quotes, paragraphs, small pieces of code (snippets) that you find online or elsewhere into your assignment, provided that these are not themselves the whole solution to the assignment, you cite the origins of these Asking sources for help in guiding you for the English language content of your assignment. Sharing small pieces of your assignment in the classroom to create a class discussion on some controversial topics. Turning to the web or elsewhere for instructions, references, and solutions to technical difficulties, but not for direct answers to the assignment Discuss solutions to assignments with others using diagrams or summarized statements but not actual text or code. Working with (and even paying) a tutor to help you with the course, provided the tutor does not do your assignment for you. b. What is not acceptable? \u00b6 Ask a classmate to see their solution to a problem before submitting your own. Failing to cite the origins of any text (or code for programming courses) that you discover outside of the course's lessons and integrate into your work You are giving or showing a classmate your solution to a problem when the classmate is struggling to solve it. J. Expectations \u00b6 You are expected to attend classes on time by completing weekly course requirements (readings and assignments) during the semester. The main communication channel between the instructor and the students email emailed. Please send your questions to the instructor's email address about the course via the email address provided to you by the university. Ensure that you include the course name in the subject field of your message and your name in the text field . In addition, the instructor will contact you via email if necessary. For this reason, it is very important to check your email address every day for healthy communication. K. Lecture Content and Syllabus Updates \u00b6 If deemed necessary, changes in the lecture content or course schedule can be made. If any changes are made in the scope of this document, the instructor will inform you about this. Course Schedule Overview \u00b6 Weeks Dates Subjects Other Tasks Week 1 21.02.2022-24.02.2022 Course Plan and Communication Grading System, Assignments, and Exams. Software and Software Engineering Object Orientation and OOP with Java Part-I(Classes, Objects, Methods,Inheritance,Access Modifiers,This and InstanceOf Keywords) TBD Week 2 28.02.2022-03.03.2022 OOP with Java Part-II (super keyword, final keyword, Polymorphism / Encapsulation, Method Overriding, Nested Inner Class, Static Class, Anonymous Class, Enums / Enum-Constructor / Enum-String, Abstract Class, Object Class, Forms of Inheritance, Benefits, and Costs of Inheritance, Packages, Access Protection in Packages TBD Week 3 07.03.2022-10.03.2022 OOP with Java Part-III(Defining and Interface and Interface Implementation, Nested Interfaces, Variables in Interfaces, Extending Interfaces, Reflection, Wrapper Classes, Lambda Notation) TBD Week 4 14.03.2022-17.03.2022 UML (UML tools, UML building blocks, architecture, diagrams, relationship, association, aggregation, composition comparison, association, dependency, generalization, realization, class diagram, object diagram, component diagram, deployment diagram, interaction diagram, use-case diagram, sequence diagram, collaboration diagram, state-machine diagram, activity diagram, timing diagram) TBD Week 5 21.03.2022-24.03.2022 Plantuml and Examples TBD Week-6 28.03.2022-31.03.2022 UMPLE and Examples TBD Week-7 04.04.2022-07.04.2022 UMPLE and Examples TBD Week-8 09.04.2022-17.04.2022 Midterm TBD Week-9 18.04.2022-21.04.2022 Using Design Patterns TBD Week-10 25.04.2022-28.04.2022 Using Design Patterns TBD Week-11 02.05.2022-05.05.2022 Holiday TBD Week-12 09.05.2022-12.05.2022 UML + UMPLE + Java Implementations TBD Week-13 16.05.2022-19.05.2022 SMC Remote Service Case Study Part-I TBD Week-14 23.05.2022-26.05.2022 SMC Remote Service Case Study Part-II TBD Week-15 30.05.2022-02.06.2022 OOP ATM Case Study Part-I TBD Week-16 06.06.2022-09.06.2022 OOP ATM Case Study Part-II TBD Week-17 13.06.2022-26.06.2022 Final \\(End-Of-Object-Oriented-Programming-Syllabus\\)","title":"Syllabus"},{"location":"syllabus/syllabus/#recep-tayyip-erdogan-university","text":"","title":"Recep Tayyip Erdogan University"},{"location":"syllabus/syllabus/#faculty-of-engineering-and-architecture","text":"","title":"Faculty of Engineering and Architecture"},{"location":"syllabus/syllabus/#computer-engineering","text":"","title":"Computer Engineering"},{"location":"syllabus/syllabus/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"syllabus/syllabus/#syllabus","text":"","title":"Syllabus"},{"location":"syllabus/syllabus/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX Download WORD , PDF Instructor Asst. Prof. Dr. U\u011fur CORUH Contact Information ugur.coruh@erdogan.edu.tr Office No F-301 Google Classroom Code n24xrzo Lecture Hours and Days Theory - Monday (13:00-16:00) Lab \u2013 Thursday (10:00-12:00) Lecture Classroom D-203 Office Hours Meetings will be scheduled over Google Meet with your university account and email and performed via demand emails. Please send emails with the subject starts with [CE204] tag for the fast response and write formal, clear, and short emails. Lecture and Communication Language English Theory/Laboratory Course Hour Per Week 3/2 Hours Credit 4 Prerequisite CE103- Algorithms and Programming I CE100- Algorithms and Programming II Corequisite TBD Requirement TBD *TBD: To Be Defined.","title":"Spring Semester, 2021-2022"},{"location":"syllabus/syllabus/#acourse-description","text":"This course introduces advanced programming skills with a focus on object-oriented programming and design fundamentals using a high-level language such as Java. Object-oriented programming is the process of integrating software components into a large-scale software architecture. After learning the fundamentals of coding, this approach to software development is the next logical step, allowing for large-scale programs. The course focuses on understanding and applying object-oriented concepts such as classes, objects, data abstraction, methods, method overloading, inheritance, and polymorphism. The class will be built around sharing expertise and guiding students to find learning methods and practice for object-oriented programming topics. Making programming applications and projects in the courses will strengthen the learning process by putting theory into practice.","title":"A.Course Description"},{"location":"syllabus/syllabus/#bcourse-learning-outcomes","text":"After completing this course satisfactorily, a student will be able to: Design applications using OO techniques Use the unified software development process to manage software development Use UML for the notation diagrams of applications Apply useful design and architecture patterns for software development.","title":"B.Course Learning Outcomes"},{"location":"syllabus/syllabus/#ccourse-topics","text":"Object-oriented concepts Unified object-oriented analysis and design process Unified Model Language Use case analysis Object structure and behavior analysis System design Application architecture and design patterns Java implementation of object-oriented design","title":"C.Course Topics"},{"location":"syllabus/syllabus/#dtextbooks-and-required-hardware-or-equipment","text":"This course does not require a coursebook. If necessary, you can use the following books and open-source online resources. Timothy C. Lethbridge and Robert Lagani\u00e8re, Object-Oriented Software Engineering: Practical Software Development using UML and Java, McGraw Hill Walter Savitch, Absolute C++, Addison-Wesley Longman Intro to Java Programming, Comprehensive Version (10 th Edition) 10 th Edition by Y. Daniel Liang Harvey M. Deitel and Paul J. Deitel. 2001. Java How to Program (4 th . ed.). Prentice Hall PTR, USA. Paul Deitel and Harvey Deitel. 2016. Visual C# How to Program (6 th . ed.). Pearson. Additional Books TBD During this course, you should have a laptop for programming practices. You will have your development environment, and you will use this for examination and assignments also classroom practices.","title":"D.Textbooks and Required Hardware or Equipment"},{"location":"syllabus/syllabus/#egrading-system","text":"Midterm and Final grades will be calculated with the weighted average of the project or homework-based examinations. Midterm grades will be calculated between term beginning to the midterm week, and Final grades will be calculated between Midterm and Final week homeworks or projects as follow \\[ a_n=\\text{Homework or Project Weight} \\] \\[ HW_n=\\text{Homework or Project Points} \\] \\[ n=\\text{Number of Homework or Project} \\] \\[ Grade=(a_1HW_1+a_2HW_2+...+a_nHW_n)/n \\] Homework Weight Midterm %40 Final %60 \\[ \\text{Passing Grade}=(40*Midterm_{Grade}+60*Final_{Grade})/100 \\]","title":"E.Grading System"},{"location":"syllabus/syllabus/#f-instructional-strategies-and-methods","text":"The basic teaching method of this course will be planned to be face-to-face in the classroom, and support resources, homeworks, and announcements will be shared over google classroom. Students are expected to be in the university. This responsibility is very important to complete this course with success. If pandemic situation changes and distance education is required during this course, this course will be done using synchronous and asynchronous distance education methods. In this scenario, students are expected to be in the online platform, zoom, or meet at the time specified in the course schedule. Attendance will be taken","title":"F. Instructional Strategies and Methods"},{"location":"syllabus/syllabus/#g-late-homework","text":"Throughout the semester, assignments must be submitted as specified by the announced deadline. Overdue assignments will not be accepted. Unexpected situations must be reported to the instructor for late homeworks by students","title":"G. Late Homework"},{"location":"syllabus/syllabus/#h-course-platform-and-communication","text":"Google Classroom and Github will be used as a course learning management system. All electronic resources and announcements about the course will be shared on this platform. It is very important to check the course page daily, access the necessary resources and announcements, and communicate with the instructor to complete the course with success.","title":"H. Course Platform and Communication"},{"location":"syllabus/syllabus/#i-academic-integrity-plagiarism-cheating","text":"Academic Integrity is one of the most important principles of RTE\u00dc University. Anyone who breaches the principles of academic honesty is severely punished. It is natural to interact with classmates and others t.\"study together\". It may also be the case where a student asks to help from someone else, paid or unpaid, better understand a difficult topic or a whole course. However, what is the borderline between \"studying together\" or \"taking private lessons\" and \"academic dishonesty\"? When is it plagiarism, when is it cheating? It is obvious that looking at another student's paper or any source other than what is allowed during the exam is cheating and will be punished. However, it is known that many students come to university with very little experience concerning what is acceptable and what counts as \"copying,\"\" especially for assignments. The following are attempted as guidelines for the Faculty of Engineering and Architecture students to highlight the philosophy of academic honesty for assignments for which the student will be graded. Should a situation arise which is not described below, the student is advised to ask the instructor or assistant of the course whether what they intend to do would remain within the framework of academic honesty or not.","title":"I. Academic Integrity, Plagiarism &amp; Cheating"},{"location":"syllabus/syllabus/#a-what-is-acceptable-when-preparing-an-assignment","text":"Communicating with classmates about the assignment to understand it better Putting ideas, quotes, paragraphs, small pieces of code (snippets) that you find online or elsewhere into your assignment, provided that these are not themselves the whole solution to the assignment, you cite the origins of these Asking sources for help in guiding you for the English language content of your assignment. Sharing small pieces of your assignment in the classroom to create a class discussion on some controversial topics. Turning to the web or elsewhere for instructions, references, and solutions to technical difficulties, but not for direct answers to the assignment Discuss solutions to assignments with others using diagrams or summarized statements but not actual text or code. Working with (and even paying) a tutor to help you with the course, provided the tutor does not do your assignment for you.","title":"a. What is acceptable when preparing an assignment?"},{"location":"syllabus/syllabus/#b-what-is-not-acceptable","text":"Ask a classmate to see their solution to a problem before submitting your own. Failing to cite the origins of any text (or code for programming courses) that you discover outside of the course's lessons and integrate into your work You are giving or showing a classmate your solution to a problem when the classmate is struggling to solve it.","title":"b. What is not acceptable?"},{"location":"syllabus/syllabus/#j-expectations","text":"You are expected to attend classes on time by completing weekly course requirements (readings and assignments) during the semester. The main communication channel between the instructor and the students email emailed. Please send your questions to the instructor's email address about the course via the email address provided to you by the university. Ensure that you include the course name in the subject field of your message and your name in the text field . In addition, the instructor will contact you via email if necessary. For this reason, it is very important to check your email address every day for healthy communication.","title":"J. Expectations"},{"location":"syllabus/syllabus/#k-lecture-content-and-syllabus-updates","text":"If deemed necessary, changes in the lecture content or course schedule can be made. If any changes are made in the scope of this document, the instructor will inform you about this.","title":"K. Lecture Content and Syllabus Updates"},{"location":"syllabus/syllabus/#course-schedule-overview","text":"Weeks Dates Subjects Other Tasks Week 1 21.02.2022-24.02.2022 Course Plan and Communication Grading System, Assignments, and Exams. Software and Software Engineering Object Orientation and OOP with Java Part-I(Classes, Objects, Methods,Inheritance,Access Modifiers,This and InstanceOf Keywords) TBD Week 2 28.02.2022-03.03.2022 OOP with Java Part-II (super keyword, final keyword, Polymorphism / Encapsulation, Method Overriding, Nested Inner Class, Static Class, Anonymous Class, Enums / Enum-Constructor / Enum-String, Abstract Class, Object Class, Forms of Inheritance, Benefits, and Costs of Inheritance, Packages, Access Protection in Packages TBD Week 3 07.03.2022-10.03.2022 OOP with Java Part-III(Defining and Interface and Interface Implementation, Nested Interfaces, Variables in Interfaces, Extending Interfaces, Reflection, Wrapper Classes, Lambda Notation) TBD Week 4 14.03.2022-17.03.2022 UML (UML tools, UML building blocks, architecture, diagrams, relationship, association, aggregation, composition comparison, association, dependency, generalization, realization, class diagram, object diagram, component diagram, deployment diagram, interaction diagram, use-case diagram, sequence diagram, collaboration diagram, state-machine diagram, activity diagram, timing diagram) TBD Week 5 21.03.2022-24.03.2022 Plantuml and Examples TBD Week-6 28.03.2022-31.03.2022 UMPLE and Examples TBD Week-7 04.04.2022-07.04.2022 UMPLE and Examples TBD Week-8 09.04.2022-17.04.2022 Midterm TBD Week-9 18.04.2022-21.04.2022 Using Design Patterns TBD Week-10 25.04.2022-28.04.2022 Using Design Patterns TBD Week-11 02.05.2022-05.05.2022 Holiday TBD Week-12 09.05.2022-12.05.2022 UML + UMPLE + Java Implementations TBD Week-13 16.05.2022-19.05.2022 SMC Remote Service Case Study Part-I TBD Week-14 23.05.2022-26.05.2022 SMC Remote Service Case Study Part-II TBD Week-15 30.05.2022-02.06.2022 OOP ATM Case Study Part-I TBD Week-16 06.06.2022-09.06.2022 OOP ATM Case Study Part-II TBD Week-17 13.06.2022-26.06.2022 Final \\(End-Of-Object-Oriented-Programming-Syllabus\\)","title":"Course Schedule Overview"},{"location":"week-1/ce204-week-1/","text":"CE204 Object-Oriented Programming \u00b6 Week-1 (Software Engineering and OOP with Java -I) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Brief Description of Course and Rules \u00b6 We will first talk about, Course Plan and Communication Grading System, Homeworks, and Exams please read the syllabus carefully. Course Growth Track \u00b6 OOP with Java UML PlantUML + UMPLE + UML PlantUML + UMPLE + UML + Java Design Patterns + UML + Java + UMPLE Outline (1) \u00b6 Software and Software Engineering Object Orientation and Review OOP with Java Intro Basing Software Development on Reusable Technology Outline (2) \u00b6 Java Classes Java Objects Java Methods Java Inheritance Java Access Modifiers This and InstanceOf Keywords Software and Software Engineering \u00b6 Software \u00b6 Computer Software is the product that software engineers design and build. It encompasses programs that execute within a computer of any size and architecture, documents that encompass hard-copy and virtual forms, data that combine numbers and text but also includes representations of pictorial, video, and audio information. The Nature of Software... (1) \u00b6 Software is intangible Hard to understand development effort Software is easy to reproduce Cost is in its development in other engineering products, manufacturing is the costly stage The industry is labor-intensive Hard to automate Untrained people can hack something together Quality problems are hard to notice The Nature of Software... (2) \u00b6 Software is easy to modify People make changes without fully understanding it Software does not \"wear out\" It deteriorates by having its design changed: erroneously, or in ways that were not anticipated, thus making it complex Conclusions Much software has poor design and is getting worse We have to learn to \u2018engineer\u2019 software Some types of Software \u00b6 Real time embedded software E.g. control and monitoring systems Must react immediately Safety often a concern Data processing software Used to run businesses Accuracy and security of data are key Game software Mobile device software Web-based software Etc. Single Chance \u00b6 Most of the clients use applications to ease their tasks to make money. For this reason, you do not have a chance to try your application development in real system. Before this deployment you have to use Theory Experimentation Guesses Feedback Lets talk about. The Project Construction Cycle - The Tree Swing Example \u00b6 1-How the customer explained it \u00b6 2-How the project leader understood it. \u00b6 3- How the analyst designed it \u00b6 4-How the programmer wrote it \u00b6 5-What the beta testers received \u00b6 6-How the business consultant described it \u00b6 7- How the project was documented \u00b6 8-What operations installed \u00b6 9-How the customer was billed \u00b6 10-How it was supported \u00b6 11-What marketing advertised \u00b6 12-What the customer really needed \u00b6 13-The disaster recover plan \u00b6 14- What the digg effect can do to your site \u00b6 15- (Finally) When it was delivered \u00b6 Need for a good programming method \u00b6 Common problems Why does it take so long? Why are development costs so high? Why can\u2019t find all faults before delivery? Why can\u2019t we measure development? NIST reported that even though 50 percent of software development budgets go to testing, flaws in software still cost the U.S. economy $59.5 billion annually.* Updated NIST Software Uses Combination Testing to Catch Bugs Fast and Easy | NIST What is Software Engineering? (1) \u00b6 The process of solving customers' problems by the systematic development and evolution of large, high-quality software systems within cost, time and other constraints What is Software Engineering? (2) \u00b6 Solving customers\u2019 problems The goal Sometimes the solution is to buy , not build Adding unnecessary features often makes software worse Software engineers must communicate effectively to identify and understand the problem What is Software Engineering? (3) \u00b6 Systematic development and evolution An engineering process involves applying well understood techniques in a organized and disciplined way Many well-accepted practices have been formally standardized e.g. by the IEEE or ISO Most development work is evolution What is Software Engineering? (4) \u00b6 Large, high quality software systems Software engineering techniques are needed because large systems cannot be completely understood by one person Teamwork and co-ordination are required Key challenge: Dividing up the work and ensuring that the parts of the system work properly together The end-product must be of sufficient quality What is Software Engineering? (5) \u00b6 Cost, time and other constraints Finite resources The benefit must outweigh the cost Others are competing to do the job cheaper and faster Inaccurate estimates of cost and time have caused many project failures The Software Engineering Profession \u00b6 The term Software Engineering was coined in 1968 People began to realize that the principles of engineering should be applied to software development Engineering is a licensed profession In order to protect the public Engineers design artifacts following well accepted practices which involve the application of science, mathematics and economics Ethical practice is also a key tenet of the profession In many countries, much software engineering does not require an engineering licence, but is still engineering Software Engineering Code of Ethics \u00b6 Software engineers shall Act consistently with public interest Act in the best interests of their clients Develop and maintain with the highest standards possible Maintain integrity and independence Promote an ethical approach in management Advance the integrity and reputation of the profession Be fair and supportive to colleagues Participate in lifelong learning Software Quality \u00b6 Usability Users can learn it and fast and get their job done easily Efficiency It doesn\u2019t waste resources such as CPU time and memory Reliability It does what it is required to do without failing Maintainability It can be easily changed Reusability Its parts can be used in other projects, so reprogramming is not needed Software Quality and Stakeholders \u00b6 Software Quality and Stakeholders \u00b6 Customer (those who pay): solves problems at an acceptable cost in terms of money paid and resources used User easy to learn; efficient to use; helps get work done Developer easy to design; easy to maintain; easy to reuse its parts Development manager sells more and pleases customers while costing less to develop and maintain Software Quality Metrics \u2013 User \u00b6 A program must do its job correctly . It must be useful and - usable A program must run as fast as necessary (Real-time constraints) A program must not waste system resources (processor time, - memory, disk capacity, network capacity) too much It must be reliable It must be easily updated A good software must have sufficient documentation (users manual) Software Quality Metrics \u2013 SW Developer \u00b6 Source code must be readable and understandable It must be easy to maintain and update the program A program must consist of independent modules An error may not affect other parts of a program (Locality of errors) Modules of the program must be reusable in other projects A software project must meet its deadline Good software must have sufficient documentation Software Quality Metrics - OOP \u00b6 OOP techniques ensure high-quality programs While designing and coding a program, these quality metrics must always be considered Software Quality: Conflicts and Objectives \u00b6 The different qualities can conflict Increasing efficiency can reduce maintainability or reusability Increasing usability can reduce efficiency Setting objectives for quality is a key engineering activity You then design to meet the objectives Avoids \"over-engineering\" which wastes money Software Engineering Projects \u00b6 Most projects are evolutionary or maintenance projects, involving work on legacy systems Corrective projects: fixing defects Adaptive projects: changing the system in response to changes in Operating system Database Rules and regulations Enhancement projects: adding new features for users Reengineering or perfective projects: changing the system internally so it is more maintainable Software Engineering Projects Start Points \u00b6 Green Field Development Brownfield Development Start afresh Build on existing code Choose your technology Technology already chosen Use your best ideas, patterns, techniques Understand previous developers' code Learn from mistakes Live with mistakes Software Engineering Projects Start Points \u00b6 Requirements must be determined Clients have produced requirements New development, Green Field Project A B Evolution of Existing System, Brown Field Project C D Activities Common to Software Projects \u00b6 Requirements and specification Includes Domain analysis Defining the problem Requirements gathering Obtaining input from as many sources as possible Requirements analysis Organizing the information Requirements specification Writing detailed instructions about how the software should behave Activities Common to Software Projects \u00b6 Design Deciding how the requirements should be implemented, using the available technology Includes: Systems engineering: Deciding what should be in hardware and what in software Software architecture: Dividing the system into subsystems and deciding how the subsystems will interact Detailed design of the internals of a subsystem User interface design Design of databases Activities Common to Software Projects \u00b6 Modeling Creating representations of the domain or the software Use case modeling Structural modeling Dynamic and behavioural modeling Programming Quality assurance Reviews and inspections Testing Deployment Managing the process Software Projects Development Team \u00b6 Software Life Cycle \u00b6 Requirements Phase Specification Phase Design Phase Implementation Phase Integration Phase Maintenance Phase Retirement Phase Requirements Phase \u00b6 Defining constraints Functions Due dates Costs Reliability Size Types Functional Non-Functional Specification Phase \u00b6 Documentation of requirements Inputs & Outputs Formal Understandable for user & developer Usually functional requirements (what to do) Base for testing & maintenance The contract between customer & developer Design Phase \u00b6 Defining Internal structure (how to do) Has some levels (or types of docs) Architectural design Detailed design Important To backtrack the aims of decisions To easily maintain Implementation and Integration Phases \u00b6 Implementation phase: Simply coding Unit tests For verification Combining modules System tests For validation Quality tests Maintenance Phase \u00b6 Corrective Enhancement Perfective Adaptive Usually maintainers are not the same people with developers. The only input is (in general) the source code of the software Retirement Phase \u00b6 When the cost of maintenance is not effective. Changes are so drastic, that the software should be redesigned. So many changes may have been made. The update frequency of docs is not enough. The hardware (or OS) will be changed. Software Development Process \u00b6 Software Development Process \u00b6 Analysis : Understanding requirements. They may change during (or after) development of the system! Building the programming team. Design : Identifying the key concepts involved in a solution and creation of the models. This stage has a strong effect on the quality of the software. Therefore, before the coding, verification of the created model must be done. Design process is connected with the programming scheme. Here, our design style is object-oriented. Software Development Process \u00b6 Coding : The solution (model) is expressed in a program. In this course we will use Java. Documentation: Each phase of a software project must be clearly explained. A users manual should also be written. Test : the behavior of the program for possible inputs must be examined. These steps are important design principles and design patterns, which help us developing high-quality software. The Unified Modeling Language (UML) is useful to express the model. Unified Process (UP) \u00b6 The UP promotes several best practices. Iterative Incremental Risk-driven Unified Process (UP) \u00b6 Unified Process (UP) \u00b6 Object Orientation Part-1 \u00b6 OOP Concepts in Java \u00b6 OOP stands for Object-Oriented Programming. OOP is a programming paradigm in which every program is follows the concept of object. In other words, OOP is a way of writing programs based on the object concept. The object-oriented programming paradigm has the following core concepts. Encapsulation Inheritance Polymorphism Abstraction The popular object-oriented programming languages are Smalltalk, C++, Java, PHP, C#, Python, etc. Encapsulation \u00b6 Encapsulation is the process of combining data and code into a single unit (object / class). In OOP, every object is associated with its data and code. In programming, data is defined as variables and code is defined as methods. The java programming language uses the class concept to implement encapsulation. Encapsulation \u00b6 Inheritance \u00b6 Inheritance is the process of acquiring properties and behaviors from one object to another object or one class to another class. In inheritance, we derive a new class from the existing class. Here, the new class acquires the properties and behaviors from the existing class. In the inheritance concept, the class which provides properties is called as parent class and the class which recieves the properties is called as child class. The parent class is also known as base class or supre class. The child class is also known as derived class or sub class. In the inheritance, the properties and behaviors of base class extended to its derived class, but the base class never receive properties or behaviors from its derived class. In java programming language the keyword extends is used to implement inheritance. Inheritance \u00b6 Polymorphism \u00b6 Polymorphism is the process of defining same method with different implementation. That means creating multiple methods with different behaviors. The java uses method overloading and method overriding to implement polymorphism. Method overloading - multiple methods with same name but different parameters. Method overriding - multiple methods with same name and same parameters. Polymorphism \u00b6 Abstraction \u00b6 Abstraction is hiding the internal details and showing only esential functionality. In the abstraction concept, we do not show the actual implemention to the end user, instead we provide only esential things. For example, if we want to drive a car, we does not need to know about the internal functionality like how wheel system works? how brake system works? how music system works? etc. Abstraction \u00b6 Why Object Technology \u00b6 Expectations are, Reducing the effort, complexity, and cost of development and maintenance of software systems. Reducing the time to adapt an existing system (quicker reaction to changes in the business environment): Flexibility, reusability. Increasing the reliability of the system. What is Programming? \u00b6 A programming language provides a way to express concepts. Program development involves creating models of real world - situations and building computer programs based on these models. Computer programs describe the method of implementing the model. Computer programs may contain computer world representations of the things that constitute the solutions of real world problems. What is Programming? \u00b6 If successful, this medium of expression (the object-oriented way) will be significantly easier, more flexible, and efficient than the alternatives as problems grow larger and more complex Why JAVA \u00b6 Java supports writing high quality programs (pure OO) Provides an easy-to-use language Provides an interpreted environment for Improved development speed Code portability Simple Architecture Neutral and Portable Robust and Secure High Performance Why JAVA \u00b6 Write less code can be four times smaller than the same program written in C++ Write better code encourages good coding practices, garbage collection for avoiding memory leaks, wide-ranging, easily extendible API Avoid platform dependencies Write once, run anywhere Gained popularity in gadgets such as PDAs, cell phones etc. Learning JAVA \u00b6 Many syntax and grammar rules Learning how to write \u201cgood programs\u201d Focusing on concepts and not get lost in language-technical - details Paying attention to design techniques rather than details Building an effective programming scheme Practicing, practicing and practicing! Consequently, new and better ways of building systems Java Buzz Words \u00b6 Simple Secure Portable Object-oriented Robust Architecture-neutral (or) Platform Independent Multi-threaded Interpreted High performance Distributed Dynamic Simple \u00b6 Java programming language is very simple and easy to learn, understand, and code. Most of the syntaxes in java follow basic programming language C and object-oriented programming concepts are similar to C++. In a java programming language, many complicated features like pointers, operator overloading, structures, unions, etc. have been removed. One of the most useful features is the garbage collector it makes java more simple. Secure \u00b6 Java is said to be more secure programming language because it does not have pointers concept, java provides a feature \"applet\" which can be embedded into a web application. The applet in java does not allow access to other parts of the computer, which keeps away from harmful programs like viruses and unauthorized access. Portable \u00b6 Portability is one of the core features of java which enables the java programs to run on any computer or operating system. For example, an applet developed using java runs on a wide variety of CPUs, operating systems, and browsers connected to the Internet. Object-oriented \u00b6 Java is said to be a pure object-oriented programming language. In java, everything is an object. It supports all the features of the object-oriented programming paradigm. The primitive data types java also implemented as objects using wrapper classes, but still, it allows primitive data types to archive high-performance. Robust \u00b6 Java is more robust because the java code can be executed on a variety of environments, java has a strong memory management mechanism (garbage collector), java is a strictly typed language, it has a strong set of exception handling mechanism, and many more. Architecture-neutral (or) Platform Independent \u00b6 Java has invented to archive \"write once; run anywhere, any time, forever\". The java provides JVM (Java Virtual Machine) to to archive architectural-neutral or platform-independent. The JVM allows the java program created using one operating system can be executed on any other operating system. Multi-threaded \u00b6 Java supports multi-threading programming, which allows us to write programs that do multiple operations simultaneously. Interpreted \u00b6 Java enables the creation of cross-platform programs by compiling into an intermediate representation called Java bytecode. The byte code is interpreted to any machine code so that it runs on the native machine. High performance \u00b6 Java provides high performance with the help of features like JVM, interpretation, and its simplicity. Distributed \u00b6 Java programming language supports TCP/IP protocols which enable the java to support the distributed environment of the Internet. Java also supports Remote Method Invocation (RMI), this feature enables a program to invoke methods across a network. Dynamic \u00b6 Java is said to be dynamic because the java byte code may be dynamically updated on a running system and it has a dynamic memory allocation and deallocation (objects and garbage collector). The Basics of Java \u00b6 History The first object oriented programming language was Simula-67 designed to allow programmers to write simulation programs In the early 1980\u2019s, Smalltalk was developed at Xerox PARC New syntax, large open-source library of reusable code, bytecode, platform independence, garbage collection. The Basics of Java \u00b6 late 1980\u2019s, C++ was developed by B. Stroustrup, Recognized the advantages of OO but also recognized that there were tremendous numbers of C programmers In 1991, engineers at Sun Microsystems started a project to design a language that could be used in consumer \u2018smart devices\u2019: Oak When the Internet gained popularity, Sun saw an opportunity to exploit the technology. The new language, renamed Java, was formally presented in 1995 at the SunWorld \u201995 conference. Java documentation \u00b6 Looking up classes and methods is an essential skill Looking up unknown classes and methods will get you a long way towards understanding code Java documentation can be automatically generated by a program called Javadoc Documentation is generated from the code and its comments You should format your comments as shown in some of the book\u2019s examples These may include embeded html Characters and Strings \u00b6 Character is a class representing Unicode characters More than a byte each Represent any world language char is a primitive data type containing a Unicode character String is a class containing collections of characters + is the operator used to concatenate strings Arrays and Collections \u00b6 Arrays are of fixed size and lack methods to manipulate them ArrayList is the most widely used class to hold a collection of other objects More powerful than arrays, but less efficient Iterators are used to access members of Vectors Enumerations were formally used, but were more complex 1 2 3 4 5 6 a = new ArrayList (); Iterator i = a . iterator (); while ( i . hasNext ()) { aMethod ( i . next ()); } Casting \u00b6 Java is very strict about types If variable v is declared to have type X, you can only invoke operations on v that are defined in X or its superclasses Even though an instance of a subclass of X may be actually stored in the variable If you know an instance of a subclass is stored, then you can cast the variable to the subclass E.g. if I know a Vector contains instances of String, I can get the next element of its Iterator using: (String)i.next(); To avoid casting you could also have used templates:: a = ArrayList<String>; i=a.iterator(); i.next() Exceptions \u00b6 Anything that can go wrong should result in the raising of an Exception Exception is a class with many subclasses for specific things that can go wrong Use a try - catch block to trap an exception 1 2 3 4 5 6 7 8 try { // some code } catch ( ArithmeticException e ) { // code to handle division by zero } Interfaces \u00b6 Like abstract classes, but cannot have executable statements Define a set of operations that make sense in several classes Abstract Data Types A class can implement any number of interfaces It must have concrete methods for the operations You can declare the type of a variable to be an interface This is just like declaring the type to be an abstract class Important interfaces in Java\u2019s library include Runnable, Collection, Iterator, Comparable, Cloneable Packages and importing \u00b6 A package combines related classes into subsystems All the classes in a particular directory Classes in different packages can have the same name Although not recommended Importing a package is done as follows: import finance.banking.accounts.*; Access control \u00b6 Applies to methods and variables public Any class can access protected Only code in the package, or subclasses can access (blank) Only code in the package can access private Only code written in the class can access Inheritance still occurs! Threads and concurrency \u00b6 Thread : Sequence of executing statements that can be running concurrently with other threads To create a thread in Java : Create a class implementing Runnable or extending Thread Implement the run method as a loop that does something for a period of time Create an instance of this class Invoke the start operation, which calls run Programming Style Guidelines \u00b6 Remember that programs are for people to read Always choose the simpler alternative Reject clever code that is hard to understand Shorter code is not necessarily better Choose good names Make them highly descriptive Do not worry about using long names Programming style \u00b6 Comment extensively Comment whatever is non-obvious Do not comment the obvious Comments should be 25-50% of the code Organize class elements consistently Variables, constructors, public methods then private methods Be consistent regarding layout of code Programming style \u00b6 Avoid duplication of code Do not \"clone\" if possible Create a new method and call it Cloning results in two copies that may both have bugs When one copy of the bug is fixed, the other may be forgotten Programming style \u00b6 Adhere to good object oriented principles E.g. the \u2018isa rule\u2019 Prefer private as opposed to public Do not mix user interface code with non-user interface code Interact with the user in separate classes This makes non-UI classes more reusable Difficulties and Risks in Programming \u00b6 Language evolution and deprecated features : Java is evolving, so some features are \u2018deprecated\u2019 at every release Efficiency can be a concern in some object oriented systems Java can be less efficient than other languages VM-based Dynamic binding C++ vs Java \u00b6 Comparison Index C++ Java Platform-independent C++ is platform-dependent. Java is platform-independent. Mainly used for C++ is mainly used for system programming. Java is mainly used for application programming. It is widely used in Windows-based, web-based, enterprise, and mobile applications. C++ vs Java \u00b6 Comparison Index C++ Java Multiple inheritance C++ supports multiple inheritance. Java doesn't support multiple inheritance through class. It can be achieved by using interfaces in java. Operator Overloading C++ supports operator overloading. Java doesn't support operator overloading. C++ vs Java \u00b6 Comparison Index C++ Java Goto C++ supports the goto statement. Java doesn't support the goto statement. Compiler and Interpreter C++ uses compiler only. C++ is compiled and run using the compiler which converts source code into machine code so, C++ is platform dependent. Java uses both compiler and interpreter. Java source code is converted into bytecode at compilation time. The interpreter executes this bytecode at runtime and produces output. Java is interpreted that is why it is platform-independent. C++ vs Java \u00b6 Comparison Index C++ Java Pointers C++ supports pointers. You can write a pointer program in C++. Java supports pointer internally. However, you can't write the pointer program in java. It means java has restricted pointer support in java. Design Goal C++ was designed for systems and applications programming. It was an extension of the C programming language. Java was designed and created as an interpreter for printing systems but later extended as a support network computing. It was designed to be easy to use and accessible to a broader audience. C++ vs Java \u00b6 Comparison Index C++ Java Structure and Union C++ supports structures and unions. Java doesn't support structures and unions. Thread Support C++ doesn't have built-in support for threads. It relies on third-party libraries for thread support. Java has built-in thread support. C++ vs Java \u00b6 Comparison Index C++ Java Documentation comment C++ doesn't support documentation comments. Java supports documentation comment (/** ... */) to create documentation for java source code. Virtual Keyword C++ supports virtual keyword so that we can decide whether or not to override a function. Java has no virtual keyword. We can override all non-static methods by default. In other words, non-static methods are virtual by default. C++ vs Java \u00b6 Comparison Index C++ Java unsigned right shift >>> C++ doesn't support >>> operator. Java supports unsigned right shift >>> operator that fills zero at the top for the negative numbers. For positive numbers, it works same like >> operator. Inheritance Tree C++ always creates a new inheritance tree. Java always uses a single inheritance tree because all classes are the child of the Object class in Java. The Object class is the root of the inheritance tree in java. C++ vs Java \u00b6 Comparison Index C++ Java Hardware C++ is nearer to hardware. Java is not so interactive with hardware. Object-oriented C++ is an object-oriented language. However, in the C language, a single root hierarchy is not possible. Java is also an object-oriented language. However, everything (except fundamental types) is an object in Java. It is a single root hierarchy as everything gets derived from java.lang.Object. Object Orientation Part-2 \u00b6 Procedural Programming \u00b6 Pascal, C, Basic, Fortran and similar traditional languages are procedural Each statement tells the computer to do something The emphasis is on doing things Functions A program is divided into functions Each function has a clearly defined purpose and interface Procedural Programming \u00b6 Problems with Procedural Programming \u00b6 Data Is undervalued Data is, after all, the reason for a program\u2019s existence. The important parts of a program are not functions that display the data or functions that checks for correct input; they are data Procedural programs don\u2019t model the real world very well. The real world does not consist of functions Global data can be corrupted by functions that have no business changing it To add new data items, all the functions that access data must be modified so that they can also access these new items Creating new data types is difficult Besides \u00b6 It is also possible to write good programs by using procedural programming (C programs). But object-oriented programming offers programmers many advantages, enables them to write high-quality programs Object-Oriented Programming \u00b6 The fundamental idea behind object-oriented programming: The real world consists of objects. Computer programs may contain computer world representations of the things (objects) that constitute the solutions of real world problems. Real world objects have two parts: Properties (or state: characteristics that can change), Behavior (or abilities: things they can do). To solve a programming problem in an object-oriented language,the programmer no longer asks how the problem will be divided into functions, but how it will be divided into objects . The emphasis is on data Object-Oriented Programming \u00b6 What kinds of things become objects in object-oriented programs? Human entities : Employees, customers, salespeople,worker, manager Graphics program : Point, line, square, circle, ... Mathematics : Complex numbers, matrix Computer user environment : Windows, menus, buttons Data-storage constructs : Customized arrays, stacks, linked lists OOP: Encapsulation and Data Hiding \u00b6 Thinking in terms of objects rather than functions Close match between objects in the programming sense and objects in the real world Both data and the functions that operate on that data are combined into a single program entity Data represent the properties (state), and functions represent the behavior of an object. Data and its functions are said to be encapsulated into a single entity An object\u2019s functions, called member functions in Java typically provide the only way to access its data. The data is hidden , so it is safe from accidental alteration. OOP: Encapsulation and Data Hiding \u00b6 Encapsulation and data hiding are key terms in the description of object-oriented languages. If you want to modify the data in an object, you know exactly what functions to interact with it The member functions in the object. No other functions can access the data: This simplifies writing, debugging, and maintaining the program. Example: A Point on the plane \u00b6 A Point on a plane has two properties; x-y coordinates. Abilities (behavior) of a Point are, moving on the plane, appearing on the screen and disappearing. A model for 2 dimensional points with the following parts: Two integer variables (x,y) to represent x and y coordinates A function to move the point: move A function to print the point on the screen: print A function to hide the point: hide Example: A Point on the plane \u00b6 Once the model has been built and tested, it is possible to create many objects of this model , in the main program. 1 2 3 4 5 6 7 8 9 10 11 Point pointOne = new Point ( 67 , 89 ); Point pointTwo = new Point ( 12 , 34 ); public class Point { public int x = 0 ; public int y = 0 ; public Point ( int a , int b ) { x = a ; y = b ; } } Object Model \u00b6 A Java program typically consists of a number of objects that communicate with each other by calling one another\u2019s member functions. OOP vs. Procedural Programming \u00b6 Procedural languages still require you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model and the model of the problem that is actually being solved. The effort required to perform this mapping produces programs that are difficult to write and expensive to maintain . Because the real world thing and their models on the computer are quite different Example: Procedural Programming \u00b6 Real world thing: student Computer model: char *, int, float It is said that the C language is closer to the computer than the problem . OOP vs. Procedural Programming \u00b6 The OO approach provides tools for the programmer to represent elements in the problem space Objects are both in the problem space and the solution The OO programs are easy to update by adding new types of objects OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run. OOP vs. Procedural Programming \u00b6 Benefits of the object-oriented programming: Readability Understandability Low probability of errors Maintenance Reusability Teamwork OOP vs. Procedural Programming \u00b6 Procedural paradigm: Software is organized around the notion of procedures Procedural abstraction Works as long as the data is simple Adding data abstractions groups together the pieces of data that describe some entity Helps reduce the system\u2019s complexity. Such as Records and structures Object oriented paradigm: Organizing procedural abstractions in the context of data abstractions Object Oriented paradigm \u00b6 All computations are performed in the context of objects. The objects are instances of classes, which: are data abstractions contain procedural abstractions that operate on the objects A running program can be seen as a collection of objects collaborating to perform a given task A View of the Two paradigms \u00b6 Classes and Objects \u00b6 Object A chunk of structured data in a running software system Has properties Represent its state Has behaviour How it acts and reacts May simulate the behaviour of an object in the real world Objects: Shown as a UML instance diagram \u00b6 Classes \u00b6 A class: A unit of abstraction in an object oriented (OO) program Represents similar objects Its instances A kind of software module Describes its instances\u2019 structure (properties) Contains methods to implement their behaviour section{ font-size: 25px; } Is Something a Class or an Instance? \u00b6 Something should be a class if it could have instances Something should be an instance if it is clearly a single member of the set defined by a class Film Class; instances are individual films. Reel of Film: Class; instances are physical reels Film reel with serial number SW19876 Instance of ReelOfFilm section{ font-size: 25px; } Is Something a Class or an Instance? \u00b6 Science Fiction Instance of the class Genre. Science Fiction Film Class; instances include \u2018Star Wars\u2019 Showing of \u2018Star Wars\u2019 in the Phoenix Cinema at 7 p.m.: Instance of ShowingOfFilm Naming classes \u00b6 Use capital letters E.g. BankAccount not bankAccount Use singular nouns Use the right level of generality E.g. Municipality , not City Make sure the name has only one meaning E.g. \"bus\" has several meanings Instance Variables \u00b6 Variables defined inside a class corresponding to data present in each instance Also called fields or member variables Attributes Simple data E.g. name , dateOfBirth Associations Relationships to other important classes E.g. supervisor , coursesTaken Variables vs. Objects \u00b6 A variable Refers to an object May refer to different objects at different points in time An object can be referred to by several different variables at the same time Type of a variable Determines what classes of objects it may contain Class variables \u00b6 A class variable\u2019s value is shared by all instances of a class. Also called a static variable If one instance sets the value of a class variable, then all the other instances see the same changed value. Class variables are useful for: Default or \u2018constant\u2019 values (e.g. PI) Lookup tables and similar structures Caution : do not over-use class variables Methods, Operations and Polymorphism \u00b6 Operation A higher-level procedural abstraction that specifies a type of behaviour Independent of any code which implements that behaviour E.g. calculating area (in general) Methods, Operations and Polymorphism \u00b6 Method A procedural abstraction used to implement the behaviour of a class Several different classes can have methods with the same name They implement the same abstract operation in ways suitable to each class E.g. calculating area in a rectangle is done differently from in a circle Polymorphism \u00b6 A property of object oriented software by which an abstract operation may be performed in different ways in different classes. Requires that there be multiple methods of the same name The choice of which one to execute depends on the object that is in a variable Reduces the need for programmers to code many if-else or switch statements Organizing Classes into Inheritance Hierarchies \u00b6 Superclasses Contain features common to a set of subclasses Inheritance hierarchies Show the relationships among superclasses and subclasses A triangle shows a generalization Inheritance The implicit possession by all subclasses of features defined in its superclasses An Example Inheritance Hierarchy \u00b6 Inheritance The implicit possession by all subclasses of features defined in its superclasses The Is-a Rule \u00b6 Always check generalizations to ensure they obey the isa rule \"A checking account is an account\" \"A village is a municipality\" Should 'Province' be a subclass of 'Country'? No, it violates the is-a rule \"A province is a country\" is invalid! A possible inheritance hierarchy of mathematical objects \u00b6 Make Sure all Inherited Features Make Sense in Subclasses \u00b6 Inheritance, Polymorphism and Variables \u00b6 Some Operations in the Shape Example \u00b6 Abstract Classes and Methods \u00b6 An operation should be declared to exist at the highest class in the hierarchy where it makes sense The operation may be abstract (lacking implementation) at that level If so, the class also must be abstract No instances can be created The opposite of an abstract class is a concrete class If a superclass has an abstract operation then its subclasses at some level must have a concrete method for the operation Leaf classes must have or inherit concrete methods for all operations Leaf classes must be concrete Overriding \u00b6 A method would be inherited, but a subclass contains a new version instead For extension E.g. SavingsAccount might charge an extra fee following every debit For optimization E.g. The getPerimeterLength method in Circle is much simpler than the one in Ellipse For restriction (best to avoid) E.g. scale(x,y) would not work in Circle How a decision is made about which method to run \u00b6 If there is a concrete method for the operation in the current class, run that method. Otherwise, check in the immediate superclass to see if there is a method there; if so, run it. Repeat step 2, looking in successively higher superclasses until a concrete method is found and run. If no method is found, then there is an error In Java and C++ the program would not have compiled In Java and C++ the program would not have compiled Dynamic binding \u00b6 Occurs when decision about which method to run can only be made at run time Needed when: A variable is declared to have a superclass as its type, and There is more than one possible polymorphic method that could be run among the type of the variable and its subclasses Key Terminology \u00b6 Abstraction Object \\(\\Longrightarrow\\) something in the world Class \\(\\Longrightarrow\\) objects Superclass \\(\\Longrightarrow\\) subclasses Operation \\(\\Longrightarrow\\) methods Attributes and associations \\(\\Longrightarrow\\) instance variables Modularity Code is divided into classes, and classes into methods Encapsulation Details can be hidden in classes This gives rise to information hiding : Programmers do not need to know all the details of a class Basing Software Development on Reusable Technology \u00b6 Building on the Experience of Others \u00b6 Software engineers should avoid re-developing software already developed Types of reuse: Reuse of expertise Reuse of standard designs and algorithms Reuse of libraries of classes or procedures Reuse of powerful commands built into languages and operating systems Reuse of frameworks Reuse of complete applications Frameworks: Reusable Subsystems \u00b6 A framework is reusable software that implements a generic solution to a generalized problem. It provides common facilities applicable to different application programs. - Principle : Applications that do different, but related, things tend to have similar designs Frameworks to promote reuse \u00b6 A framework is intrinsically incomplete Certain classes or methods are used by the framework, but are missing ( slots ) Some functionality is optional Allowance is made for developer to provide it ( hooks or extension points ) Developers use the services that the framework provides Taken together the services are called the Application Program Interface ( API ) Object-oriented frameworks \u00b6 In the object oriented paradigm, a framework is composed of a library of classes. The API is defined by the set of all public methods of these classes. Some of the classes will normally be abstract and there are often many Interfaces Example: A framework for payroll management A framework for frequent buyer clubs A framework for university registration A framework for e-commerce web sites Frameworks and product lines \u00b6 A product line (or product family) is a set of products built on a common base of technology. The various products in the product line have different features to satisfy different markets The software common to all products in included in a framework Each product is produced by filling the available hooks and slots E.g. software products offering \"demo\", \"lite\" or \"pro\" versions Types of frameworks \u00b6 A horizontal framework provides general application facilities that a large number of applications can use A vertical framework ( application framework ) is more \u2018complete\u2019 but still needs some slots to be filled to adapt it to specific application needs The Client-Server Architecture \u00b6 A distributed system is a system in which: computations are performed by separate programs \u2026 normally running on separate pieces of hardware \u2026 that co-operate to perform the task of the system. Server: A program that provides a service for other programs that connect to it using a communication channel Client A program that accesses a server (or several servers) to obtain services A server may be accessed by many clients simultaneously Example of client-server systems \u00b6 Activities of a server \u00b6 Initializes itself Starts listening for clients Handles the following types of events originating from clients accepts connections responds to messages handles client disconnection May stop listening Must cleanly terminate Activities of a client \u00b6 Initializes itself Initiates a connection Sends messages Handles the following types of events originating from the server responds to messages handles server disconnection Must cleanly terminate Threads in a client-server system \u00b6 Thin- versus fat-client systems \u00b6 Thin-client system (a) Client is made as small as possible Most of the work is done in the server. Client easy to download over the network Fat-client system (b) As much work as possible is delegated to the clients. Server can handle more clients Communications protocols \u00b6 The messages the client sends to the server form a language. The server has to be programmed to understand that language. The messages the server sends to the client also form a language. The client has to be programmed to understand that language. When a client and server are communicating, they are in effect having a conversation using these two languages The two languages and the rules of the conversation, taken together, are called the protocol Tasks to perform to develop client-server applications \u00b6 Design the primary work to be performed by both client and server Design how the work will be distributed Design the details of the set of messages that will be sent Design the mechanism for Initializing Handling connections Sending and receiving messages Terminating Advantages of client-server systems \u00b6 The work can be distributed among different machines The clients can access the server\u2019s functionality from a distance The client and server can be designed separately They can both be simpler There is a choice about where to keep data: All the data can be kept centrally at the server Data can be distributed among many different clients or servers The server can be accessed simultaneously by many clients Competing clients can be written to communicate with the same server, and vice-versa Technology Needed to Build Client-Server Systems \u00b6 Internet Protocol (IP) Route messages from one computer to another Long messages are normally split up into small pieces Transmission Control Protocol (TCP) Handles connections between two computers Computers can then exchange many IP messages over a connection Assures that the messages have been satisfactorily received A host has an IP address and a host name Several servers can run on the same host. Each server is identified by a port number (0 to 65535). To initiate communication with a server, a client must know both the host name and the port number Establishing a connection in Java \u00b6 The java.net package Permits the creation of a TCP/IP connection between two applications Before a connection can be established, the server must start listening to one of the ports: 1 2 ServerSocket serverSocket = new ServerSocket ( port ); Socket clientSocket = serverSocket . accept (); For a client to connect to a server: 1 Socket clientSocket = new Socket ( host , port ); Exchanging information in Java \u00b6 Each program uses an instance of InputStream to receive messages from the other program OutputStream to send messages to the other program These are found in package java.io 1 output = clientSocket . getOutputStream (); 1 input = clientSocket . getInputStream (); Sending and receiving messages \u00b6 without any filters (raw bytes) 1 2 output . write ( msg ); msg = input . read (); or using DataInputStream / DataOutputStream filters 1 2 output . writeDouble ( msg ); msg = input . readDouble (); or using ObjectInputStream / ObjectOutputStream filters 1 2 output . writeObject ( msg ); msg = input . readObject (); The Object Client-Server Framework (OCSF) \u00b6 Using OCSF \u00b6 Software engineers using OCSF never modify its three classes They: Create subclasses of the abstract classes in the framework Call public methods that are provided by the framework Override certain slot and hook methods (explicitly designed to be overridden) The Client Side \u00b6 Consists of a single class: AbstractClient Must be subclassed Any subclass must provide an implementation for handleMessageFromServer Takes appropriate action when a message is received from a server Implements the Runnable interface Has a run method which Contains a loop that executes for the lifetime of the thread The public interface of AbstractClient \u00b6 Controlling methods: openConnection closeConnection sendToServer Accessing methods: isConnected getHost setHost getPort setPort getInetAddress The callback methods of AbstractClient \u00b6 Methods that may be overridden: connectionEstablished connectionClosed Method that must be implemented: handleMessageFromServer Using AbstractClient \u00b6 Create a subclass of AbstractClient Implement handleMessageFromServer slot method Write code that: Creates an instance of the new subclass Calls openConnection Sends messages to the server using the sendToServer service method Implement the connectionClosed callback Implement the connectionException callback Internals of AbstractClient \u00b6 Instance variables: A Socket which keeps all the information about the connection to the server Two streams, an ObjectOutputStream and an ObjectInputStream A Thread that runs using AbstractClient\u2019s run method Two variables storing the host and port of the server The Server Side \u00b6 Two classes: One for the thread which listens for new connections ( AbstractServer ) One for the threads that handle the connections to clients ( ConnectionToClient ) The public interface of AbstractServer \u00b6 Controlling methods: listen stopListening close sendToAllClients Accessing methods: isListening getClientConnections getPort setPort setBacklog The callback methods of AbstractServer \u00b6 Methods that may be overridden: serverStarted clientConnected clientDisconnected clientException serverStopped listeningException serverClosed Method that must be implemented: handleMessageFromClient The public interface of ConnectionToClient \u00b6 Controlling methods: sendToClient close Accessing methods: getInetAddress setInfo getInfo Using AbstractServer and ConnectionToClient \u00b6 Create a subclass of AbstractServer Implement the slot method handleMessageFromClient Write code that: Creates an instance of the subclass of AbstractServer Calls the listen method Sends messages to clients, using: the getClientConnections and sendToClient service methods or sendToAllClients Implement one or more of the other callback methods Internals of AbstractServer and ConnectionToClient \u00b6 The setInfo and getInfo methods make use of a Java class called HashMap Many methods in the server side are synchronized The collection of instances of ConnectionToClient is stored using a special class called ThreadGroup The server must pause from listening every 500ms to see if the stopListening method has been called if not, then it resumes listening immediately An Instant Messaging Application: SimpleChat \u00b6 ClientConsole can eventually be replaced by ClientGUI The server \u00b6 EchoServer is a subclass of AbstractServer The main method creates a new instance and starts it It listens for clients and handles connections until the server is stopped The three callback methods just print out a message to the user handleMessageFromClient , serverStarted and serverStopped The slot method handleMessageFromClient calls sendToAllClients This echoes any messages Key code in EchoServer \u00b6 1 2 3 4 5 6 7 8 public void handleMessageFromClient ( Object msg , ConnectionToClient client ) { System . out . println ( \"Message received: \" + msg + \" from \" + client ); this . sendToAllClients ( msg ); } The client \u00b6 When the client program starts, it creates instances of two classes: ChatClient A subclass of AbstractClient Overrides handleMessageFromServer This calls the display method of the user interface ClientConsole User interface class that implements the interface ChatIF Hence implements display which outputs to the console Accepts user input by calling accept in its run method Sends all user input to the ChatClient by calling its handleMessageFromClientUI This, in turn, calls sendToServer Key code in ChatClient \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void handleMessageFromClientUI ( String message ) { try { sendToServer ( message ); } catch ( IOException e ) { clientUI . display ( \"Could not send message. \" + \"Terminating client.\" ); quit (); } } Key code in ChatClient \u00b6 1 2 3 4 public void handleMessageFromServer ( Object msg ) { clientUI . display ( msg . toString ()); } Risks when reusing technology \u00b6 Poor quality reusable components Ensure that the developers of the reusable technology: follow good software engineering practices are willing to provide active support Compatibility not maintained Avoid obscure features Only re-use technology that others are also re-using Risks when developing reusable technology \u00b6 Investment uncertainty Plan the development of the reusable technology, just as if it was a product for a client The \"not invented here syndrome\" Build confidence in the reusable technology by: Guaranteeing support Ensuring it is of high quality Responding to the needs of its users Risks when developing reusable technology \u00b6 Competition The reusable technology must be as useful and as high quality as possible Divergence (tendency of various groups to change technology in different ways) Design it to be general enough, test it and review it in advance Risks when adopting a client-server approach \u00b6 Security Security is a big problem with no perfect solutions: consider the use of encryption, firewalls, ... Need for adaptive maintenance Ensure that all software is forward and backward compatible with other versions of clients and servers Java Classes and Objects \u00b6 Java Classes \u00b6 Java is an object-oriented programming language, so everything in java program must be based on the object concept. In a java programming language, the class concept defines the skeleton of an object. Java Classes \u00b6 The java class is a template of an object. The class defines the blueprint of an object. Every class in java forms a new data type. Once a class got created, we can generate as many objects as we want. Every class defines the properties and behaviors of an object. All the objects of a class have the same properties and behaviors that were defined in the class. Java Classes \u00b6 Every class of java programming language has the following characteristics. Identity - It is the name given to the class. State - Represents data values that are associated with an object. Behavior - Represents actions can be performed by an object. Java Classes \u00b6 Creating a Class \u00b6 In java, we use the keyword class to create a class. A class in java contains properties as variables and behaviors as methods. Following is the syntax of class in the java. 1 2 3 4 class < ClassName > { data members declaration ; methods defination ; } Here, fields (variables) and methods represent the state and behavior of the object respectively. fields are used to store data methods are used to perform some operations Creating a Class \u00b6 A class is a blueprint for the object. Before we create an object, we first need to define the class. We can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object. Since many houses can be made from the same description, we can create many objects from a class. Creating a Class \u00b6 The ClassName must begin with an alphabet, and the Upper-case letter is preferred. The ClassName must follow all naming rules. Creating a Class \u00b6 1 2 3 4 5 6 7 8 9 10 class Bicycle { // state or field private int gear = 5 ; // behavior or method public void braking () { System . out . println ( \"Working of Braking\" ); } } In the above example, we have created a class named Bicycle. It contains a field named gear and a method named braking(). Creating a Class \u00b6 Here, Bicycle is a prototype. Now, we can create any number of bicycles using the prototype. And, all the bicycles will share the fields and methods of the prototype. Creating an Object \u00b6 In java, an object is an instance of a class. When an object of a class is created, the class is said to be instantiated. All the objects that are created using a single class have the same properties and methods. But the value of properties is different for every object. Following is the syntax of class in the java. 1 < ClassName > < objectName > = new < ClassName > ( ); Creating an Object \u00b6 The objectName must begin with an alphabet, and a Lower-case letter is preferred. The objectName must follow all naming rules. Creating an Object \u00b6 An object is called an instance of a class. For example, suppose Bicycle is a class then MountainBicycle, SportsBicycle, TouringBicycle, etc can be considered as objects of the class. 1 2 3 4 5 6 className object = new className (); // for Bicycle class Bicycle sportsBicycle = new Bicycle (); Bicycle touringBicycle = new Bicycle (); We have used the new keyword along with the constructor of the class to create an object. Constructors are similar to methods and have the same name as the class. For example, Bicycle() is the constructor of the Bicycle class. Creating an Object \u00b6 Here, sportsBicycle and touringBicycle are the names of objects. We can use them to access fields and methods of the class. Access Members of a Class \u00b6 sportsBicycle.gear - access the field gear sportsBicycle.braking() - access the method braking() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Bicycle { // field of class int gear = 5 ; // method of class void braking () { ... } } // create object Bicycle sportsBicycle = new Bicycle (); // access field and method sportsBicycle . gear ; sportsBicycle . braking (); Example: Java Class and Objects \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Lamp { // stores the value for light // true if light is on // false if light is off boolean isOn ; // method to turn on the light void turnOn () { isOn = true ; System . out . println ( \"Light on? \" + isOn ); } // method to turnoff the light void turnOff () { isOn = false ; System . out . println ( \"Light on? \" + isOn ); } } Example: Java Class and Objects \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Main { public static void main ( String [] args ) { // create objects led and halogen Lamp led = new Lamp (); Lamp halogen = new Lamp (); // turn on the light by // calling method turnOn() led . turnOn (); // turn off the light by // calling method turnOff() halogen . turnOff (); } } Example: Create objects inside the same class \u00b6 Note that in the previous example, we have created objects inside another class and accessed the members from that class. However, we can also create objects inside the same class. Example: Create objects inside the same class \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Lamp { // stores the value for light // true if light is on // false if light is off boolean isOn ; // method to turn on the light void turnOn () { isOn = true ; System . out . println ( \"Light on? \" + isOn ); } public static void main ( String [] args ) { // create an object of Lamp Lamp led = new Lamp (); // access method using object led . turnOn (); } } Java Methods \u00b6 Java Methods \u00b6 A method is a block of statements under a name that gets executes only when it is called. Every method is used to perform a specific task. The major advantage of methods is code re-usability (define the code once, and use it many times). Java Methods \u00b6 In a java programming language, a method defined as a behavior of an object. That means, every method in java must belong to a class. Every method in java must be declared inside a class. Java Methods \u00b6 Every method declaration has the following characteristics. returnType - Specifies the data type of a return value. name - Specifies a unique name to identify it. parameters - The data values it may accept or recieve. { } - Defienes the block belongs to the method. Creating a method \u00b6 A method is created inside the class and it may be created with any access specifier. However, specifying access specifier is optional. Following is the syntax for creating methods in java. 1 2 3 4 5 6 7 class < ClassName > { < accessSpecifier > < returnType > < methodName > ( parameters ){ ... block of statements ; ... } } Creating a method \u00b6 1 2 3 modifier static returnType nameOfMethod ( parameter1 , parameter2 , ...) { // method body } modifier - It defines access types whether the method is public, private, and so on. static - If we use the static keyword, it can be accessed without creating objects. Creating a method \u00b6 The methodName must begin with an alphabet, and the Lower-case letter is preferred. The methodName must follow all naming rules. If you don't want to pass parameters, we ignore it. If a method defined with return type other than void, it must contain the return statement, otherwise, it may be ignored. Calling a method \u00b6 In java, a method call precedes with the object name of the class to which it belongs and a dot operator. It may call directly if the method defined with the static modifier. Every method call must be made, as to the method name with parentheses (), and it must terminate with a semicolon. 1 < objectName > . < methodName > ( actualArguments ); Calling a method \u00b6 The method call must pass the values to parameters if it has. If the method has a return type, we must provide the receiver. Calling a Method : Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Scanner ; public class JavaMethodsExample { int sNo ; String name ; Scanner read = new Scanner ( System . in ); void readData () { System . out . print ( \"Enter Serial Number: \" ); sNo = read . nextInt (); System . out . print ( \"Enter the Name: \" ); name = read . next (); } static void showData ( int sNo , String name ) { System . out . println ( \"Hello, \" + name + \"! your serial number is \" + sNo ); } ... Calling a Method : Example \u00b6 1 2 3 4 5 6 7 ... public static void main ( String [] args ) { JavaMethodsExample obj = new JavaMethodsExample (); obj . readData (); // method call using object showData ( obj . sNo , obj . name ); // method call without using object } } Variable arguments of a method \u00b6 In java, a method can be defined with a variable number of arguments. That means creating a method that receives any number of arguments of the same data type. 1 < returnType > < methodName > ( dataType ... parameterName ); Variable arguments of a method : Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class JavaMethodWithVariableArgs { void diaplay ( int ... list ) { System . out . println ( \"\\nNumber of arguments: \" + list . length ); for ( int i : list ) { System . out . print ( i + \"\\t\" ); } } ... Variable arguments of a method : Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 ... public static void main ( String [] args ) { JavaMethodWithVariableArgs obj = new JavaMethodWithVariableArgs (); obj . diaplay ( 1 , 2 ); obj . diaplay ( 10 , 20 , 30 , 40 , 50 ); } } Java Normal Method Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Main { // create a method public int addNumbers ( int a , int b ) { int sum = a + b ; // return value return sum ; } public static void main ( String [] args ) { int num1 = 25 ; int num2 = 15 ; // create an object of Main Main obj = new Main (); // calling method int result = obj . addNumbers ( num1 , num2 ); System . out . println ( \"Sum is: \" + result ); } } Java Static Method Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Main { // create a method public static int square ( int num ) { // return statement return num * num ; } public static void main ( String [] args ) { int result ; // call the method // store returned value to result result = square ( 10 ); System . out . println ( \"Squared value of 10 is: \" + result ); } } Java Method Parameters \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Main { // method with no parameter public void display1 () { System . out . println ( \"Method without parameter\" ); } // method with single parameter public void display2 ( int a ) { System . out . println ( \"Method with a single parameter: \" + a ); } public static void main ( String [] args ) { // create an object of Main Main obj = new Main (); // calling method with no parameter obj . display1 (); // calling method with the single parameter obj . display2 ( 24 ); } } Java Method Overloading \u00b6 Java Method Overloading \u00b6 two or more methods may have the same name if they differ in parameters (different number of parameters, different types of parameters, or both). These methods are called overloaded methods and this feature is called method overloading. Java Method Overloading \u00b6 1 2 3 4 void func () { ... } void func ( int a ) { ... } float func ( double a ) { ... } float func ( int a , float b ) { ... } Note : The return types of the above methods are not the same. It is because method overloading is not associated with return types. Overloaded methods may have the same or different return types, but they must differ in parameters. Why method overloading? \u00b6 Suppose, you have to perform the addition of given numbers but there can be any number of arguments (let\u2019s say either 2 or 3 arguments for simplicity). In order to accomplish the task, you can create two methods sum2num(int, int) and sum3num(int, int, int) for two and three parameters respectively. However, other programmers, as well as you in the future may get confused as the behavior of both methods are the same but they differ by name. The better way to accomplish this task is by overloading methods. And, depending upon the argument passed, one of the overloaded methods is called. This helps to increase the readability of the program. How to perform method overloading in Java? \u00b6 Overloading by changing the number of parameters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MethodOverloading { private static void display ( int a ){ System . out . println ( \"Arguments: \" + a ); } private static void display ( int a , int b ){ System . out . println ( \"Arguments: \" + a + \" and \" + b ); } public static void main ( String [] args ) { display ( 1 ); display ( 1 , 4 ); } } How to perform method overloading in Java? \u00b6 Method Overloading by changing the data type of parameters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MethodOverloading { // this method accepts int private static void display ( int a ){ System . out . println ( \"Got Integer data.\" ); } // this method accepts String object private static void display ( String a ){ System . out . println ( \"Got String object.\" ); } public static void main ( String [] args ) { display ( 1 ); display ( \"Hello\" ); } } Java Overloading Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class HelperService { private String formatNumber ( int value ) { return String . format ( \"%d\" , value ); } private String formatNumber ( double value ) { return String . format ( \"%.3f\" , value ); } private String formatNumber ( String value ) { return String . format ( \"%.2f\" , Double . parseDouble ( value )); } public static void main ( String [] args ) { HelperService hs = new HelperService (); System . out . println ( hs . formatNumber ( 500 )); System . out . println ( hs . formatNumber ( 89.9934 )); System . out . println ( hs . formatNumber ( \"550\" )); } } Java Constructor \u00b6 Java Constructor \u00b6 A constructor is a special method of a class that has the same name as the class name. The constructor gets executes automatically on object creation. It does not require the explicit method call. A constructor may have parameters and access specifiers too. In java, if you do not provide any constructor the compiler automatically creates a default constructor. Java Constructor \u00b6 A constructor can not have return value. 1 2 3 4 5 6 7 8 9 10 11 12 public class ConstructorExample { ConstructorExample () { System . out . println ( \"Object created!\" ); } public static void main ( String [] args ) { ConstructorExample obj1 = new ConstructorExample (); ConstructorExample obj2 = new ConstructorExample (); } } Types of Constructor \u00b6 In Java, constructors can be divided into 3 types: No-Arg Constructor Parameterized Constructor Default Constructor Java No-Arg Constructors \u00b6 Java private no-arg constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Main { int i ; // constructor with no parameter private Main () { i = 5 ; System . out . println ( \"Constructor is called\" ); } public static void main ( String [] args ) { // calling the constructor without any parameter Main obj = new Main (); System . out . println ( \"Value of i: \" + obj . i ); } } Java No-Arg Constructors \u00b6 Java public no-arg constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Company { String name ; // public constructor public Company () { name = \"My Company\" ; } } class Main { public static void main ( String [] args ) { // object is created in another class Company obj = new Company (); System . out . println ( \"Company name = \" + obj . name ); } } Java Parameterized Constructor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Main { String languages ; // constructor accepting single value Main ( String lang ) { languages = lang ; System . out . println ( languages + \" Programming Language\" ); } public static void main ( String [] args ) { // call constructor by passing a single value Main obj1 = new Main ( \"Java\" ); Main obj2 = new Main ( \"Python\" ); Main obj3 = new Main ( \"C\" ); } } Java Default Constructor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { int a ; boolean b ; public static void main ( String [] args ) { // A default constructor is called Main obj = new Main (); System . out . println ( \"Default Value:\" ); System . out . println ( \"a = \" + obj . a ); System . out . println ( \"b = \" + obj . b ); } } Java Default Values \u00b6 The default constructor initializes any uninitialized instance variables with default values. Type \\(\\Longrightarrow\\) Default Value boolean \\(\\Longrightarrow\\) false byte \\(\\Longrightarrow\\) 0 short \\(\\Longrightarrow\\) 0 int \\(\\Longrightarrow\\) 0 long \\(\\Longrightarrow\\) 0L char \\(\\Longrightarrow\\) \\u0000 float \\(\\Longrightarrow\\) 0.0f double \\(\\Longrightarrow\\) 0.0d object \\(\\Longrightarrow\\) Reference null Java Default Constructor Equivalent \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Main { int a ; boolean b ; // a private constructor private Main () { a = 0 ; b = false ; } public static void main ( String [] args ) { // call the constructor Main obj = new Main (); System . out . println ( \"Default Value:\" ); System . out . println ( \"a = \" + obj . a ); System . out . println ( \"b = \" + obj . b ); } } Constructors Overloading in Java \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Main { String language ; // constructor with no parameter Main () { this . language = \"Java\" ; } // constructor with a single parameter Main ( String language ) { this . language = language ; } public void getName () { System . out . println ( \"Programming Langauage: \" + this . language ); } ... Constructors Overloading in Java \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 ... public static void main ( String [] args ) { // call constructor with no parameter Main obj1 = new Main (); // call constructor with a single parameter Main obj2 = new Main ( \"Python\" ); obj1 . getName (); obj2 . getName (); } } Java Inheritance \u00b6 Inheritance Concept \u00b6 The inheritance is a very useful and powerful concept of object-oriented programming. In java, using the inheritance concept, we can use the existing features of one class in another class. - The inheritance provides a greate advantage called code re-usability. With the help of code re-usability, the commonly used code in an application need not be written again and again. Inheritance Concept \u00b6 Inheritance Concept \u00b6 The inheritance is the process of acquiring the properties of one class to another class. Inheritance Basics \u00b6 In inheritance, we use the terms like parent class, child class, base class, derived class, superclass, and subclass. Inheritance Basics \u00b6 The Parent class is the class which provides features to another class. The parent class is also known as Base class or Superclass . The Child class is the class which receives features from another class. The child class is also known as the Derived Class or Subclass . Inheritance Basics \u00b6 In the inheritance, the child class acquires the features from its parent class. But the parent class never acquires the features from its child class. Inheritance Basics \u00b6 There are five types of inheritances, and they are as follows. Simple Inheritance (or) Single Inheritance Multiple Inheritance Multi-Level Inheritance Hierarchical Inheritance Hybrid Inheritance Inheritance Basics \u00b6 Simple Inheritance (or) Single Inheritance Inheritance Basics \u00b6 Multiple Inheritance Inheritance Basics \u00b6 Multi-Level Inheritance Inheritance Basics \u00b6 Hierarchical Inheritance Inheritance Basics \u00b6 Hybrid Inheritance Inheritance Basics \u00b6 The java programming language does not support multiple inheritance type. However, it provides an alternate with the concept of interfaces . Creating Child Class in java \u00b6 In java, we use the keyword extends to create a child class. The following syntax used to create a child class in java. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class < ChildClassName > extends < ParentClassName > { ... //Implementation of child class ... } ``` - In a java programming language , a class extends only one class . - Extending multiple classes is not allowed in java . --- ### Single Inheritance in Java Example - 1 - In this type of inheritance , one child class derives from one parent class . ``` Java linenums = \"1\" class ParentClass { int a ; void setData ( int a ) { this . a = a ; } } 1 2 3 4 5 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Value of a is \" + a ); } } Single Inheritance in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 public class SingleInheritance { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . setData ( 100 ); obj . showData (); } } Single Inheritance in Java Example-2 \u00b6 1 2 3 4 5 6 7 8 class Animal { // field and method of the parent class String name ; public void eat () { System . out . println ( \"I can eat\" ); } } 1 2 3 4 5 6 7 8 // inherit from Animal class Dog extends Animal { // new method in subclass public void display () { System . out . println ( \"My name is \" + name ); } } Single Inheritance in Java Example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // access field of superclass labrador . name = \"Rohu\" ; labrador . display (); // call method of superclass // using object of subclass labrador . eat (); } } Single Inheritance in Java Example-2 \u00b6 Single Inheritance / is-a relationship \u00b6 In Java, inheritance is an is-a relationship. That is, we use inheritance only if there exists an is-a relationship between two classes. For example, Car is a Vehicle Orange is a Fruit Surgeon is a Doctor Dog is an Animal Here, Car can inherit from Vehicle, Orange can inherit from Fruit, and so on. Multi-level Inheritance in java \u00b6 In this type of inheritance, the child class derives from a class which already derived from another class 1 2 3 4 5 6 class ParentClass { int a ; void setData ( int a ) { this . a = a ; } } Multi-level Inheritance in java \u00b6 1 2 3 4 5 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Value of a is \" + a ); } } 1 2 3 4 5 class ChildChildClass extends ChildClass { void display () { System . out . println ( \"Inside ChildChildClass!\" ); } } Multi-level Inheritance in java \u00b6 1 2 3 4 5 6 7 8 9 10 11 public class MultipleInheritance { public static void main ( String [] args ) { ChildChildClass obj = new ChildChildClass (); obj . setData ( 100 ); obj . showData (); obj . display (); } } Hierarchical Inheritance in java \u00b6 In this type of inheritance, two or more child classes derive from one parent class. 1 2 3 4 5 6 class ParentClass { int a ; void setData ( int a ) { this . a = a ; } } Hierarchical Inheritance in java \u00b6 1 2 3 4 5 6 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass!\" ); System . out . println ( \"Value of a is \" + a ); } } 1 2 3 4 5 6 class ChildClassToo extends ParentClass { void display () { System . out . println ( \"Inside ChildClassToo!\" ); System . out . println ( \"Value of a is \" + a ); } } Hierarchical Inheritance in java \u00b6 1 2 3 4 5 6 7 8 9 10 11 public class HierarchicalInheritance { public static void main ( String [] args ) { ChildClass child_obj = new ChildClass (); child_obj . setData ( 100 ); child_obj . showData (); ChildClassToo childToo_obj = new ChildClassToo (); childToo_obj . setData ( 200 ); childToo_obj . display (); } } Hybrid Inheritance in java \u00b6 The hybrid inheritance is the combination of more than one type of inheritance. We may use any combination as a single with multiple inheritances, multi-level with multiple inheritances, etc., Java Access Modifiers \u00b6 Java Access Modifiers \u00b6 In Java, the access specifiers (also known as access modifiers) used to restrict the scope or accessibility of a class, constructor, variable, method or data member of class and interface. Java Access Modifiers \u00b6 There are four access specifiers, and their list is below. default (or) no modifier public protected private Java Access Modifiers \u00b6 In java, we can not employ all access specifiers on everything. The following table describes where we can apply the access specifiers. Java Access Modifiers \u00b6 Let's look at the following example java code, which generates an error because a class does not allow private access specifier unless it is an inner class. 1 2 3 private class Sample { ... } Java Access Modifiers \u00b6 In java, the accessibility of the members of a class or interface depends on its access specifiers. The following table provides information about the visibility of both data members and methods. Java Access Modifiers \u00b6 The public members can be accessed everywhere. The private members can be accessed only inside the same class. The protected members are accessible to every child class (same package or other packages). The default members are accessible within the same package but not outside the package. Java Access Modifiers \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int a = 10 ; public int b = 20 ; protected int c = 30 ; private int d = 40 ; void showData () { System . out . println ( \"Inside ParentClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); System . out . println ( \"d = \" + d ); } } Java Access Modifiers \u00b6 1 2 3 4 5 6 7 8 9 10 11 class ChildClass extends ParentClass { void accessData () { System . out . println ( \"Inside ChildClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); //System.out.println(\"d = \" + d); // private member can't be accessed } } Java Access Modifiers \u00b6 1 2 3 4 5 6 7 8 9 10 11 public class AccessModifiersExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); obj . accessData (); } } Java Access Modifiers \u00b6 Default Access Modifier Here, the Logger class has the default access modifier 1 2 3 4 5 6 package defaultpackage ; class Logger { void message (){ System . out . println ( \"This is a message\" ); } } the class is visible to all the classes that belong to the defaultPackage package However, if we try to use the Logger class in another class outside of defaultPackage, we will get a compilation error. Java Access Modifiers \u00b6 Private Access Modifier When variables and methods are declared private, they cannot be accessed outside of the class 1 2 3 4 class Data { // private variable private String name ; } Java Access Modifiers \u00b6 Private Access Modifier 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] main ){ // create an object of Data Data d = new Data (); // access private variable and field from another class d . name = \"My App\" ; } } Java Access Modifiers \u00b6 Private Access Modifier When we run the program, we will get the following error Main.java:18: error: name has private access in Data d.name = \"My App\" ; ^ Java Access Modifiers \u00b6 Private Access Modifier if we need to access those private variables we can use the getters and setters method 1 2 3 4 5 6 7 8 9 10 11 12 class Data { private String name ; // getter method public String getName () { return this . name ; } // setter method public void setName ( String name ) { this . name = name ; } } Java Access Modifiers \u00b6 Private Access Modifier 1 2 3 4 5 6 7 8 9 public class Main { public static void main ( String [] main ){ Data d = new Data (); // access the private variable using the getter and setter d . setName ( \"My App\" ); System . out . println ( d . getName ()); } } Java Access Modifiers \u00b6 Private Access Modifier We cannot declare classes and interfaces private in Java. However, the nested classes can be declared private. Java Access Modifiers \u00b6 Protected Access Modifier When methods and data members are declared protected, we can access them within the same package as well as from subclasses . Java Access Modifiers \u00b6 Protected Access Modifier 1 2 3 4 5 6 class Animal { // protected method protected void display () { System . out . println ( \"I am an animal\" ); } } 1 2 3 4 5 6 7 8 9 class Dog extends Animal { public static void main ( String [] args ) { // create an object of Dog class Dog dog = new Dog (); // access protected method dog . display (); } } Java Access Modifiers \u00b6 Protected Access Modifier (Ex-2) 1 2 3 4 5 6 7 class Animal { protected String name ; protected void display () { System . out . println ( \"I am an animal.\" ); } } 1 2 3 4 5 6 class Dog extends Animal { public void getInfo () { System . out . println ( \"My name is \" + name ); } } Java Access Modifiers \u00b6 Protected Access Modifier (Ex-2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // access protected field and method // using the object of subclass labrador . name = \"Rocky\" ; labrador . display (); labrador . getInfo (); } } Java Access Modifiers \u00b6 Protected Access Modifier We cannot declare classes or interfaces protected in Java. Java Access Modifiers \u00b6 Public Access Modifier When methods, variables, classes, and so on are declared public, then we can access them from anywhere. 1 2 3 4 5 6 7 8 9 10 11 12 // Animal.java file // public class public class Animal { // public variable public int legCount ; // public method public void display () { System . out . println ( \"I am an animal.\" ); System . out . println ( \"I have \" + legCount + \" legs.\" ); } } Java Access Modifiers \u00b6 Public Access Modifier 1 2 3 4 5 6 7 8 9 10 11 12 // Main.java public class Main { public static void main ( String [] args ) { // accessing the public class Animal animal = new Animal (); // accessing the public variable animal . legCount = 4 ; // accessing the public method animal . display (); } } Java Constructors in Inheritance \u00b6 Java Constructors in Inheritance \u00b6 It is very important to understand how the constructors get executed in the inheritance concept. In the inheritance, the constructors never get inherited to any child class. In java, the default constructor of a parent class called automatically by the constructor of its child class. That means when we create an object of the child class, the parent class constructor executed, followed by the child class constructor executed. Java Constructors in Inheritance - Example \u00b6 1 2 3 4 5 6 class ParentClass { int a ; ParentClass (){ System . out . println ( \"Inside ParentClass constructor!\" ); } } 1 2 3 4 5 6 class ChildClass extends ParentClass { ChildClass (){ System . out . println ( \"Inside ChildClass constructor!!\" ); } } Java Constructors in Inheritance - Example \u00b6 1 2 3 4 5 6 class ChildChildClass extends ChildClass { ChildChildClass (){ System . out . println ( \"Inside ChildChildClass constructor!!\" ); } } 1 2 3 4 5 6 7 public class ConstructorInInheritance { public static void main ( String [] args ) { ChildChildClass obj = new ChildChildClass (); } } Java Constructors in Inheritance \u00b6 if the parent class contains both default and parameterized constructor, then only the default constructor called automatically by the child class constructor Java Constructors in Inheritance - Example \u00b6 1 2 3 4 5 6 7 8 9 10 class ParentClass { int a ; ParentClass ( int a ){ System . out . println ( \"Inside ParentClass parameterized constructor!\" ); this . a = a ; } ParentClass (){ System . out . println ( \"Inside ParentClass default constructor!\" ); } } Java Constructors in Inheritance - Example \u00b6 1 2 3 4 5 class ChildClass extends ParentClass { ChildClass (){ System . out . println ( \"Inside ChildClass constructor!!\" ); } } 1 2 3 4 5 public class ConstructorInInheritance { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } } Java Constructors in Inheritance \u00b6 The parameterized constructor of parent class must be called explicitly using the super keyword. Method Overriding in Java Inheritance \u00b6 1 2 3 4 5 6 7 class Animal { // method in the superclass public void eat () { System . out . println ( \"I can eat\" ); } } Method Overriding in Java Inheritance \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Dog inherits Animal class Dog extends Animal { // overriding the eat() method @Override public void eat () { System . out . println ( \"I eat dog food\" ); } // new method in subclass public void bark () { System . out . println ( \"I can bark\" ); } } Method Overriding in Java Inheritance \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // call the eat() method labrador . eat (); labrador . bark (); } } Method Overriding in Java Inheritance \u00b6 In the above example, the eat() method is present in both the superclass Animal and the subclass Dog. Here, we have created an object labrador of Dog. Now when we call eat() using the object labrador, the method inside Dog is called. This is because the method inside the derived class overrides the method inside the base class. super Keyword in Java Inheritance \u00b6 super Keyword in Java Inheritance \u00b6 the same method in the subclass overrides the method in superclass. In such a situation, the super keyword is used to call the method of the parent class from the method of the child class. super Keyword in Java Inheritance \u00b6 1 2 3 4 5 6 7 class Animal { // method in the superclass public void eat () { System . out . println ( \"I can eat\" ); } } super Keyword in Java Inheritance \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Dog inherits Animal class Dog extends Animal { // overriding the eat() method @Override public void eat () { // call method of superclass super . eat (); System . out . println ( \"I eat dog food\" ); } // new method in subclass public void bark () { System . out . println ( \"I can bark\" ); } } super Keyword in Java Inheritance \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // call the eat() method labrador . eat (); labrador . bark (); } } Java this Keyword \u00b6 Java this Keyword \u00b6 In Java, this keyword is used to refer to the current object inside a method or a constructor Java this Keyword \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { int instVar ; Main ( int instVar ){ this . instVar = instVar ; System . out . println ( \"this reference = \" + this ); } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"object reference = \" + obj ); } } Using this for Ambiguity Variable Names \u00b6 In Java, it is not allowed to declare two or more variables having the same name inside a scope (class scope or method scope). However, instance variables and parameters may have the same name. Using this for Ambiguity Variable Names \u00b6 WRONG 1 2 3 4 5 6 7 8 9 10 11 12 class Main { int age ; Main ( int age ){ age = age ; } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"obj.age = \" + obj . age ); } } Using this for Ambiguity Variable Names \u00b6 CORRECT 1 2 3 4 5 6 7 8 9 10 11 12 class Main { int age ; Main ( int age ){ this . age = age ; } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"obj.age = \" + obj . age ); } } this with Getters and Setters \u00b6 Another common use of this keyword is in setters and getters methods of a class 1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { String name ; // setter method void setName ( String name ) { this . name = name ; } // getter method String getName (){ return this . name ; } ... this with Getters and Setters \u00b6 1 2 3 4 5 6 7 8 9 ... public static void main ( String [] args ) { Main obj = new Main (); // calling the setter and the getter method obj . setName ( \"Toshiba\" ); System . out . println ( \"obj.name: \" + obj . getName ()); } } Using this in Constructor Overloading \u00b6 While working with constructor overloading, we might have to invoke one constructor from another constructor. In such a case, we cannot call the constructor explicitly. Instead, we have to use this keyword. Using this in Constructor Overloading \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Complex { private int a , b ; // constructor with 2 parameters private Complex ( int i , int j ){ this . a = i ; this . b = j ; } // constructor with single parameter private Complex ( int i ){ // invokes the constructor with 2 parameters this ( i , i ); } // constructor with no parameter private Complex (){ // invokes the constructor with single parameter this ( 0 ); } ... Using this in Constructor Overloading \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override public String toString (){ return this . a + \" + \" + this . b + \"i\" ; } public static void main ( String [] args ) { // creating object of Complex class // calls the constructor with 2 parameters Complex c1 = new Complex ( 2 , 3 ); // calls the constructor with a single parameter Complex c2 = new Complex ( 3 ); // calls the constructor with no parameters Complex c3 = new Complex (); // print objects System . out . println ( c1 ); System . out . println ( c2 ); System . out . println ( c3 ); } } Using this in Constructor Overloading \u00b6 In the example, we have used this keyword, to call the constructor Complex(int i, int j) from the constructor Complex(int i) to call the constructor Complex(int i) from the constructor Complex() the line, System.out.println(c1); process, the toString() is called Since we override the toString() method inside our class, we get the output according to that method. Using this in Constructor Overloading \u00b6 One of the huge advantages of this() is to reduce the amount of duplicate code. However, we should be always careful while using this(). This is because calling constructor from another constructor adds overhead and it is a slow process. Another huge advantage of using this() is to reduce the amount of duplicate code. Using this in Constructor Overloading \u00b6 Invoking one constructor from another constructor is called explicit constructor invocation. Passing this as an Argument \u00b6 We can use this keyword to pass the current object as an argument to a method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ThisExample { // declare variables int x ; int y ; ThisExample ( int x , int y ) { // assign values of variables inside constructor this . x = x ; this . y = y ; // value of x and y before calling add() System . out . println ( \"Before passing this to addTwo() method:\" ); System . out . println ( \"x = \" + this . x + \", y = \" + this . y ); // call the add() method passing this as argument add ( this ); // value of x and y after calling add() System . out . println ( \"After passing this to addTwo() method:\" ); System . out . println ( \"x = \" + this . x + \", y = \" + this . y ); } void add ( ThisExample o ){ o . x += 2 ; o . y += 2 ; } } Passing this as an Argument \u00b6 1 2 3 4 5 class Main { public static void main ( String [] args ) { ThisExample obj = new ThisExample ( 1 , - 2 ); } } Passing this as an Argument \u00b6 In the example, inside the constructor ThisExample() , notice the line, add(this); Here, we are calling the add() method by passing this as an argument. Since this keyword contains the reference to the object obj of the class, we can change the value of x and y inside the add() method. Java instanceof Operator \u00b6 Java instanceof Operator \u00b6 The instanceof operator in Java is used to check whether an object is an instance of a particular class or not. Its syntax is objectName instanceOf className ; Example: Java instanceof \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Main { public static void main ( String [] args ) { // create a variable of string type String name = \"My App\" ; // checks if name is instance of String boolean result1 = name instanceof String ; System . out . println ( \"name is an instance of String: \" + result1 ); // create an object of Main Main obj = new Main (); // checks if obj is an instance of Main boolean result2 = obj instanceof Main ; System . out . println ( \"obj is an instance of Main: \" + result2 ); } } Example: Java instanceof \u00b6 In the example, we have created a variable name of the String type and an object obj of the Main class. Here, we have used the instanceof operator to check whether name and obj are instances of the String and Main class respectively. And, the operator returns true in both cases. Java instanceof during Inheritance \u00b6 We can use the instanceof operator to check if objects of the subclass is also an instance of the superclass. Java instanceof during Inheritance \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Java Program to check if an object of the subclass // is also an instance of the superclass // superclass class Animal { } // subclass class Dog extends Animal { } class Main { public static void main ( String [] args ) { // create an object of the subclass Dog d1 = new Dog (); // checks if d1 is an instance of the subclass System . out . println ( d1 instanceof Dog ); // prints true // checks if d1 is an instance of the superclass System . out . println ( d1 instanceof Animal ); // prints true } } Java instanceof during Inheritance \u00b6 In the above example, we have created a subclass Dog that inherits from the superclass Animal. We have created an object d1 of the Dog class. Inside the print statement, notice the expression, 1 d1 instanceof Animal Here, we are using the instanceof operator to check whether d1 is also an instance of the superclass Animal Java instanceof in Interface \u00b6 The instanceof operator is also used to check whether an object of a class is also an instance of the interface implemented by the class Java instanceof in Interface \u00b6 1 2 3 4 5 6 7 8 // Java program to check if an object of a class is also // an instance of the interface implemented by the class interface Animal { } class Dog implements Animal { } Java instanceof in Interface \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the Dog class Dog d1 = new Dog (); // checks if the object of Dog // is also an instance of Animal System . out . println ( d1 instanceof Animal ); // returns true } } Java instanceof in Interface \u00b6 In the example, the Dog class implements the Animal interface. Inside the print statement, notice the expression, 1 d1 instanceof Animal Here, d1 is an instance of Dog class. The instanceof operator checks if d1 is also an instance of the interface Animal . Java instanceof in Interface \u00b6 In Java, all the classes are inherited from the Object class. So, instances of all the classes are also an instance of the Object class. In the previous example, if we check, 1 d1 instanceof Object The result will be true . References \u00b6 https://www.site.uottawa.ca/~tcl/seg2105/ https://cruise.umple.org/index.shtml https://cruise.umple.org/umple/GettingStarted.html Sanem Sar\u0131el Associate Professor, PhD BT503 Application Development with Java (Kemerburgaz University 2013-2015) How To Define The Project Scope The Foolproof Way References \u00b6 BtechSmartClass Java OOP Concepts BtechSmartClass-Java Buzz Words JavatPoint-Cpp vs Java BtechSmartClass-Java Classes Programiz-Class Objects References \u00b6 BtechSmartClass-Java-Methods-and-Classes Programiz-Methods Programiz-Method Overloading Programiz-Constructors BtechSmartClass-Java inheritance basics References \u00b6 BtechSmartClass-Java access specifiers Programiz-Access Modifiers BtechSmartClass-java constructors in inheritance Programiz-Inheritance Programiz-this Keyword Programiz-instanceof \\(End-Of-Week-1-Module\\)","title":"Week-1 (Software Engineering and OOP with Java -I)"},{"location":"week-1/ce204-week-1/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-1/ce204-week-1/#week-1-software-engineering-and-oop-with-java-i","text":"","title":"Week-1 (Software Engineering and OOP with Java -I)"},{"location":"week-1/ce204-week-1/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-1/ce204-week-1/#brief-description-of-course-and-rules","text":"We will first talk about, Course Plan and Communication Grading System, Homeworks, and Exams please read the syllabus carefully.","title":"Brief Description of Course and Rules"},{"location":"week-1/ce204-week-1/#course-growth-track","text":"OOP with Java UML PlantUML + UMPLE + UML PlantUML + UMPLE + UML + Java Design Patterns + UML + Java + UMPLE","title":"Course Growth Track"},{"location":"week-1/ce204-week-1/#outline-1","text":"Software and Software Engineering Object Orientation and Review OOP with Java Intro Basing Software Development on Reusable Technology","title":"Outline (1)"},{"location":"week-1/ce204-week-1/#outline-2","text":"Java Classes Java Objects Java Methods Java Inheritance Java Access Modifiers This and InstanceOf Keywords","title":"Outline (2)"},{"location":"week-1/ce204-week-1/#software-and-software-engineering","text":"","title":"Software and Software Engineering"},{"location":"week-1/ce204-week-1/#software","text":"Computer Software is the product that software engineers design and build. It encompasses programs that execute within a computer of any size and architecture, documents that encompass hard-copy and virtual forms, data that combine numbers and text but also includes representations of pictorial, video, and audio information.","title":"Software"},{"location":"week-1/ce204-week-1/#the-nature-of-software-1","text":"Software is intangible Hard to understand development effort Software is easy to reproduce Cost is in its development in other engineering products, manufacturing is the costly stage The industry is labor-intensive Hard to automate Untrained people can hack something together Quality problems are hard to notice","title":"The Nature of Software... (1)"},{"location":"week-1/ce204-week-1/#the-nature-of-software-2","text":"Software is easy to modify People make changes without fully understanding it Software does not \"wear out\" It deteriorates by having its design changed: erroneously, or in ways that were not anticipated, thus making it complex Conclusions Much software has poor design and is getting worse We have to learn to \u2018engineer\u2019 software","title":"The Nature of Software... (2)"},{"location":"week-1/ce204-week-1/#some-types-of-software","text":"Real time embedded software E.g. control and monitoring systems Must react immediately Safety often a concern Data processing software Used to run businesses Accuracy and security of data are key Game software Mobile device software Web-based software Etc.","title":"Some types of Software"},{"location":"week-1/ce204-week-1/#single-chance","text":"Most of the clients use applications to ease their tasks to make money. For this reason, you do not have a chance to try your application development in real system. Before this deployment you have to use Theory Experimentation Guesses Feedback Lets talk about.","title":"Single Chance"},{"location":"week-1/ce204-week-1/#the-project-construction-cycle-the-tree-swing-example","text":"","title":"The Project Construction Cycle - The Tree Swing Example"},{"location":"week-1/ce204-week-1/#1-how-the-customer-explained-it","text":"","title":"1-How the customer explained it"},{"location":"week-1/ce204-week-1/#2-how-the-project-leader-understood-it","text":"","title":"2-How the project leader understood it."},{"location":"week-1/ce204-week-1/#3-how-the-analyst-designed-it","text":"","title":"3- How the analyst designed it"},{"location":"week-1/ce204-week-1/#4-how-the-programmer-wrote-it","text":"","title":"4-How the programmer wrote it"},{"location":"week-1/ce204-week-1/#5-what-the-beta-testers-received","text":"","title":"5-What the beta testers received"},{"location":"week-1/ce204-week-1/#6-how-the-business-consultant-described-it","text":"","title":"6-How the business consultant described it"},{"location":"week-1/ce204-week-1/#7-how-the-project-was-documented","text":"","title":"7- How the project was documented"},{"location":"week-1/ce204-week-1/#8-what-operations-installed","text":"","title":"8-What operations installed"},{"location":"week-1/ce204-week-1/#9-how-the-customer-was-billed","text":"","title":"9-How the customer was billed"},{"location":"week-1/ce204-week-1/#10-how-it-was-supported","text":"","title":"10-How it was supported"},{"location":"week-1/ce204-week-1/#11-what-marketing-advertised","text":"","title":"11-What marketing advertised"},{"location":"week-1/ce204-week-1/#12-what-the-customer-really-needed","text":"","title":"12-What the customer really needed"},{"location":"week-1/ce204-week-1/#13-the-disaster-recover-plan","text":"","title":"13-The disaster recover plan"},{"location":"week-1/ce204-week-1/#14-what-the-digg-effect-can-do-to-your-site","text":"","title":"14- What the digg effect can do to your site"},{"location":"week-1/ce204-week-1/#15-finally-when-it-was-delivered","text":"","title":"15- (Finally) When it was delivered"},{"location":"week-1/ce204-week-1/#need-for-a-good-programming-method","text":"Common problems Why does it take so long? Why are development costs so high? Why can\u2019t find all faults before delivery? Why can\u2019t we measure development? NIST reported that even though 50 percent of software development budgets go to testing, flaws in software still cost the U.S. economy $59.5 billion annually.* Updated NIST Software Uses Combination Testing to Catch Bugs Fast and Easy | NIST","title":"Need  for a good programming method"},{"location":"week-1/ce204-week-1/#what-is-software-engineering-1","text":"The process of solving customers' problems by the systematic development and evolution of large, high-quality software systems within cost, time and other constraints","title":"What is Software Engineering? (1)"},{"location":"week-1/ce204-week-1/#what-is-software-engineering-2","text":"Solving customers\u2019 problems The goal Sometimes the solution is to buy , not build Adding unnecessary features often makes software worse Software engineers must communicate effectively to identify and understand the problem","title":"What is Software Engineering? (2)"},{"location":"week-1/ce204-week-1/#what-is-software-engineering-3","text":"Systematic development and evolution An engineering process involves applying well understood techniques in a organized and disciplined way Many well-accepted practices have been formally standardized e.g. by the IEEE or ISO Most development work is evolution","title":"What is Software Engineering? (3)"},{"location":"week-1/ce204-week-1/#what-is-software-engineering-4","text":"Large, high quality software systems Software engineering techniques are needed because large systems cannot be completely understood by one person Teamwork and co-ordination are required Key challenge: Dividing up the work and ensuring that the parts of the system work properly together The end-product must be of sufficient quality","title":"What is Software Engineering? (4)"},{"location":"week-1/ce204-week-1/#what-is-software-engineering-5","text":"Cost, time and other constraints Finite resources The benefit must outweigh the cost Others are competing to do the job cheaper and faster Inaccurate estimates of cost and time have caused many project failures","title":"What is Software Engineering? (5)"},{"location":"week-1/ce204-week-1/#the-software-engineering-profession","text":"The term Software Engineering was coined in 1968 People began to realize that the principles of engineering should be applied to software development Engineering is a licensed profession In order to protect the public Engineers design artifacts following well accepted practices which involve the application of science, mathematics and economics Ethical practice is also a key tenet of the profession In many countries, much software engineering does not require an engineering licence, but is still engineering","title":"The Software Engineering Profession"},{"location":"week-1/ce204-week-1/#software-engineering-code-of-ethics","text":"Software engineers shall Act consistently with public interest Act in the best interests of their clients Develop and maintain with the highest standards possible Maintain integrity and independence Promote an ethical approach in management Advance the integrity and reputation of the profession Be fair and supportive to colleagues Participate in lifelong learning","title":"Software Engineering Code of Ethics"},{"location":"week-1/ce204-week-1/#software-quality","text":"Usability Users can learn it and fast and get their job done easily Efficiency It doesn\u2019t waste resources such as CPU time and memory Reliability It does what it is required to do without failing Maintainability It can be easily changed Reusability Its parts can be used in other projects, so reprogramming is not needed","title":"Software Quality"},{"location":"week-1/ce204-week-1/#software-quality-and-stakeholders","text":"","title":"Software Quality and Stakeholders"},{"location":"week-1/ce204-week-1/#software-quality-and-stakeholders_1","text":"Customer (those who pay): solves problems at an acceptable cost in terms of money paid and resources used User easy to learn; efficient to use; helps get work done Developer easy to design; easy to maintain; easy to reuse its parts Development manager sells more and pleases customers while costing less to develop and maintain","title":"Software Quality and Stakeholders"},{"location":"week-1/ce204-week-1/#software-quality-metrics-user","text":"A program must do its job correctly . It must be useful and - usable A program must run as fast as necessary (Real-time constraints) A program must not waste system resources (processor time, - memory, disk capacity, network capacity) too much It must be reliable It must be easily updated A good software must have sufficient documentation (users manual)","title":"Software Quality Metrics \u2013 User"},{"location":"week-1/ce204-week-1/#software-quality-metrics-sw-developer","text":"Source code must be readable and understandable It must be easy to maintain and update the program A program must consist of independent modules An error may not affect other parts of a program (Locality of errors) Modules of the program must be reusable in other projects A software project must meet its deadline Good software must have sufficient documentation","title":"Software Quality Metrics \u2013 SW Developer"},{"location":"week-1/ce204-week-1/#software-quality-metrics-oop","text":"OOP techniques ensure high-quality programs While designing and coding a program, these quality metrics must always be considered","title":"Software Quality Metrics - OOP"},{"location":"week-1/ce204-week-1/#software-quality-conflicts-and-objectives","text":"The different qualities can conflict Increasing efficiency can reduce maintainability or reusability Increasing usability can reduce efficiency Setting objectives for quality is a key engineering activity You then design to meet the objectives Avoids \"over-engineering\" which wastes money","title":"Software Quality: Conflicts and Objectives"},{"location":"week-1/ce204-week-1/#software-engineering-projects","text":"Most projects are evolutionary or maintenance projects, involving work on legacy systems Corrective projects: fixing defects Adaptive projects: changing the system in response to changes in Operating system Database Rules and regulations Enhancement projects: adding new features for users Reengineering or perfective projects: changing the system internally so it is more maintainable","title":"Software Engineering Projects"},{"location":"week-1/ce204-week-1/#software-engineering-projects-start-points","text":"Green Field Development Brownfield Development Start afresh Build on existing code Choose your technology Technology already chosen Use your best ideas, patterns, techniques Understand previous developers' code Learn from mistakes Live with mistakes","title":"Software Engineering Projects Start Points"},{"location":"week-1/ce204-week-1/#software-engineering-projects-start-points_1","text":"Requirements must be determined Clients have produced requirements New development, Green Field Project A B Evolution of Existing System, Brown Field Project C D","title":"Software Engineering Projects Start Points"},{"location":"week-1/ce204-week-1/#activities-common-to-software-projects","text":"Requirements and specification Includes Domain analysis Defining the problem Requirements gathering Obtaining input from as many sources as possible Requirements analysis Organizing the information Requirements specification Writing detailed instructions about how the software should behave","title":"Activities Common to Software Projects"},{"location":"week-1/ce204-week-1/#activities-common-to-software-projects_1","text":"Design Deciding how the requirements should be implemented, using the available technology Includes: Systems engineering: Deciding what should be in hardware and what in software Software architecture: Dividing the system into subsystems and deciding how the subsystems will interact Detailed design of the internals of a subsystem User interface design Design of databases","title":"Activities Common to Software Projects"},{"location":"week-1/ce204-week-1/#activities-common-to-software-projects_2","text":"Modeling Creating representations of the domain or the software Use case modeling Structural modeling Dynamic and behavioural modeling Programming Quality assurance Reviews and inspections Testing Deployment Managing the process","title":"Activities Common to Software Projects"},{"location":"week-1/ce204-week-1/#software-projects-development-team","text":"","title":"Software Projects Development Team"},{"location":"week-1/ce204-week-1/#software-life-cycle","text":"Requirements Phase Specification Phase Design Phase Implementation Phase Integration Phase Maintenance Phase Retirement Phase","title":"Software Life Cycle"},{"location":"week-1/ce204-week-1/#requirements-phase","text":"Defining constraints Functions Due dates Costs Reliability Size Types Functional Non-Functional","title":"Requirements Phase"},{"location":"week-1/ce204-week-1/#specification-phase","text":"Documentation of requirements Inputs & Outputs Formal Understandable for user & developer Usually functional requirements (what to do) Base for testing & maintenance The contract between customer & developer","title":"Specification Phase"},{"location":"week-1/ce204-week-1/#design-phase","text":"Defining Internal structure (how to do) Has some levels (or types of docs) Architectural design Detailed design Important To backtrack the aims of decisions To easily maintain","title":"Design Phase"},{"location":"week-1/ce204-week-1/#implementation-and-integration-phases","text":"Implementation phase: Simply coding Unit tests For verification Combining modules System tests For validation Quality tests","title":"Implementation and Integration Phases"},{"location":"week-1/ce204-week-1/#maintenance-phase","text":"Corrective Enhancement Perfective Adaptive Usually maintainers are not the same people with developers. The only input is (in general) the source code of the software","title":"Maintenance Phase"},{"location":"week-1/ce204-week-1/#retirement-phase","text":"When the cost of maintenance is not effective. Changes are so drastic, that the software should be redesigned. So many changes may have been made. The update frequency of docs is not enough. The hardware (or OS) will be changed.","title":"Retirement Phase"},{"location":"week-1/ce204-week-1/#software-development-process","text":"","title":"Software Development Process"},{"location":"week-1/ce204-week-1/#software-development-process_1","text":"Analysis : Understanding requirements. They may change during (or after) development of the system! Building the programming team. Design : Identifying the key concepts involved in a solution and creation of the models. This stage has a strong effect on the quality of the software. Therefore, before the coding, verification of the created model must be done. Design process is connected with the programming scheme. Here, our design style is object-oriented.","title":"Software Development Process"},{"location":"week-1/ce204-week-1/#software-development-process_2","text":"Coding : The solution (model) is expressed in a program. In this course we will use Java. Documentation: Each phase of a software project must be clearly explained. A users manual should also be written. Test : the behavior of the program for possible inputs must be examined. These steps are important design principles and design patterns, which help us developing high-quality software. The Unified Modeling Language (UML) is useful to express the model.","title":"Software Development Process"},{"location":"week-1/ce204-week-1/#unified-process-up","text":"The UP promotes several best practices. Iterative Incremental Risk-driven","title":"Unified Process (UP)"},{"location":"week-1/ce204-week-1/#unified-process-up_1","text":"","title":"Unified Process (UP)"},{"location":"week-1/ce204-week-1/#unified-process-up_2","text":"","title":"Unified Process (UP)"},{"location":"week-1/ce204-week-1/#object-orientation-part-1","text":"","title":"Object Orientation Part-1"},{"location":"week-1/ce204-week-1/#oop-concepts-in-java","text":"OOP stands for Object-Oriented Programming. OOP is a programming paradigm in which every program is follows the concept of object. In other words, OOP is a way of writing programs based on the object concept. The object-oriented programming paradigm has the following core concepts. Encapsulation Inheritance Polymorphism Abstraction The popular object-oriented programming languages are Smalltalk, C++, Java, PHP, C#, Python, etc.","title":"OOP Concepts in Java"},{"location":"week-1/ce204-week-1/#encapsulation","text":"Encapsulation is the process of combining data and code into a single unit (object / class). In OOP, every object is associated with its data and code. In programming, data is defined as variables and code is defined as methods. The java programming language uses the class concept to implement encapsulation.","title":"Encapsulation"},{"location":"week-1/ce204-week-1/#encapsulation_1","text":"","title":"Encapsulation"},{"location":"week-1/ce204-week-1/#inheritance","text":"Inheritance is the process of acquiring properties and behaviors from one object to another object or one class to another class. In inheritance, we derive a new class from the existing class. Here, the new class acquires the properties and behaviors from the existing class. In the inheritance concept, the class which provides properties is called as parent class and the class which recieves the properties is called as child class. The parent class is also known as base class or supre class. The child class is also known as derived class or sub class. In the inheritance, the properties and behaviors of base class extended to its derived class, but the base class never receive properties or behaviors from its derived class. In java programming language the keyword extends is used to implement inheritance.","title":"Inheritance"},{"location":"week-1/ce204-week-1/#inheritance_1","text":"","title":"Inheritance"},{"location":"week-1/ce204-week-1/#polymorphism","text":"Polymorphism is the process of defining same method with different implementation. That means creating multiple methods with different behaviors. The java uses method overloading and method overriding to implement polymorphism. Method overloading - multiple methods with same name but different parameters. Method overriding - multiple methods with same name and same parameters.","title":"Polymorphism"},{"location":"week-1/ce204-week-1/#polymorphism_1","text":"","title":"Polymorphism"},{"location":"week-1/ce204-week-1/#abstraction","text":"Abstraction is hiding the internal details and showing only esential functionality. In the abstraction concept, we do not show the actual implemention to the end user, instead we provide only esential things. For example, if we want to drive a car, we does not need to know about the internal functionality like how wheel system works? how brake system works? how music system works? etc.","title":"Abstraction"},{"location":"week-1/ce204-week-1/#abstraction_1","text":"","title":"Abstraction"},{"location":"week-1/ce204-week-1/#why-object-technology","text":"Expectations are, Reducing the effort, complexity, and cost of development and maintenance of software systems. Reducing the time to adapt an existing system (quicker reaction to changes in the business environment): Flexibility, reusability. Increasing the reliability of the system.","title":"Why Object Technology"},{"location":"week-1/ce204-week-1/#what-is-programming","text":"A programming language provides a way to express concepts. Program development involves creating models of real world - situations and building computer programs based on these models. Computer programs describe the method of implementing the model. Computer programs may contain computer world representations of the things that constitute the solutions of real world problems.","title":"What is Programming?"},{"location":"week-1/ce204-week-1/#what-is-programming_1","text":"If successful, this medium of expression (the object-oriented way) will be significantly easier, more flexible, and efficient than the alternatives as problems grow larger and more complex","title":"What is Programming?"},{"location":"week-1/ce204-week-1/#why-java","text":"Java supports writing high quality programs (pure OO) Provides an easy-to-use language Provides an interpreted environment for Improved development speed Code portability Simple Architecture Neutral and Portable Robust and Secure High Performance","title":"Why JAVA"},{"location":"week-1/ce204-week-1/#why-java_1","text":"Write less code can be four times smaller than the same program written in C++ Write better code encourages good coding practices, garbage collection for avoiding memory leaks, wide-ranging, easily extendible API Avoid platform dependencies Write once, run anywhere Gained popularity in gadgets such as PDAs, cell phones etc.","title":"Why JAVA"},{"location":"week-1/ce204-week-1/#learning-java","text":"Many syntax and grammar rules Learning how to write \u201cgood programs\u201d Focusing on concepts and not get lost in language-technical - details Paying attention to design techniques rather than details Building an effective programming scheme Practicing, practicing and practicing! Consequently, new and better ways of building systems","title":"Learning JAVA"},{"location":"week-1/ce204-week-1/#java-buzz-words","text":"Simple Secure Portable Object-oriented Robust Architecture-neutral (or) Platform Independent Multi-threaded Interpreted High performance Distributed Dynamic","title":"Java Buzz Words"},{"location":"week-1/ce204-week-1/#simple","text":"Java programming language is very simple and easy to learn, understand, and code. Most of the syntaxes in java follow basic programming language C and object-oriented programming concepts are similar to C++. In a java programming language, many complicated features like pointers, operator overloading, structures, unions, etc. have been removed. One of the most useful features is the garbage collector it makes java more simple.","title":"Simple"},{"location":"week-1/ce204-week-1/#secure","text":"Java is said to be more secure programming language because it does not have pointers concept, java provides a feature \"applet\" which can be embedded into a web application. The applet in java does not allow access to other parts of the computer, which keeps away from harmful programs like viruses and unauthorized access.","title":"Secure"},{"location":"week-1/ce204-week-1/#portable","text":"Portability is one of the core features of java which enables the java programs to run on any computer or operating system. For example, an applet developed using java runs on a wide variety of CPUs, operating systems, and browsers connected to the Internet.","title":"Portable"},{"location":"week-1/ce204-week-1/#object-oriented","text":"Java is said to be a pure object-oriented programming language. In java, everything is an object. It supports all the features of the object-oriented programming paradigm. The primitive data types java also implemented as objects using wrapper classes, but still, it allows primitive data types to archive high-performance.","title":"Object-oriented"},{"location":"week-1/ce204-week-1/#robust","text":"Java is more robust because the java code can be executed on a variety of environments, java has a strong memory management mechanism (garbage collector), java is a strictly typed language, it has a strong set of exception handling mechanism, and many more.","title":"Robust"},{"location":"week-1/ce204-week-1/#architecture-neutral-or-platform-independent","text":"Java has invented to archive \"write once; run anywhere, any time, forever\". The java provides JVM (Java Virtual Machine) to to archive architectural-neutral or platform-independent. The JVM allows the java program created using one operating system can be executed on any other operating system.","title":"Architecture-neutral (or) Platform Independent"},{"location":"week-1/ce204-week-1/#multi-threaded","text":"Java supports multi-threading programming, which allows us to write programs that do multiple operations simultaneously.","title":"Multi-threaded"},{"location":"week-1/ce204-week-1/#interpreted","text":"Java enables the creation of cross-platform programs by compiling into an intermediate representation called Java bytecode. The byte code is interpreted to any machine code so that it runs on the native machine.","title":"Interpreted"},{"location":"week-1/ce204-week-1/#high-performance","text":"Java provides high performance with the help of features like JVM, interpretation, and its simplicity.","title":"High performance"},{"location":"week-1/ce204-week-1/#distributed","text":"Java programming language supports TCP/IP protocols which enable the java to support the distributed environment of the Internet. Java also supports Remote Method Invocation (RMI), this feature enables a program to invoke methods across a network.","title":"Distributed"},{"location":"week-1/ce204-week-1/#dynamic","text":"Java is said to be dynamic because the java byte code may be dynamically updated on a running system and it has a dynamic memory allocation and deallocation (objects and garbage collector).","title":"Dynamic"},{"location":"week-1/ce204-week-1/#the-basics-of-java","text":"History The first object oriented programming language was Simula-67 designed to allow programmers to write simulation programs In the early 1980\u2019s, Smalltalk was developed at Xerox PARC New syntax, large open-source library of reusable code, bytecode, platform independence, garbage collection.","title":"The Basics of Java"},{"location":"week-1/ce204-week-1/#the-basics-of-java_1","text":"late 1980\u2019s, C++ was developed by B. Stroustrup, Recognized the advantages of OO but also recognized that there were tremendous numbers of C programmers In 1991, engineers at Sun Microsystems started a project to design a language that could be used in consumer \u2018smart devices\u2019: Oak When the Internet gained popularity, Sun saw an opportunity to exploit the technology. The new language, renamed Java, was formally presented in 1995 at the SunWorld \u201995 conference.","title":"The Basics of Java"},{"location":"week-1/ce204-week-1/#java-documentation","text":"Looking up classes and methods is an essential skill Looking up unknown classes and methods will get you a long way towards understanding code Java documentation can be automatically generated by a program called Javadoc Documentation is generated from the code and its comments You should format your comments as shown in some of the book\u2019s examples These may include embeded html","title":"Java documentation"},{"location":"week-1/ce204-week-1/#characters-and-strings","text":"Character is a class representing Unicode characters More than a byte each Represent any world language char is a primitive data type containing a Unicode character String is a class containing collections of characters + is the operator used to concatenate strings","title":"Characters and Strings"},{"location":"week-1/ce204-week-1/#arrays-and-collections","text":"Arrays are of fixed size and lack methods to manipulate them ArrayList is the most widely used class to hold a collection of other objects More powerful than arrays, but less efficient Iterators are used to access members of Vectors Enumerations were formally used, but were more complex 1 2 3 4 5 6 a = new ArrayList (); Iterator i = a . iterator (); while ( i . hasNext ()) { aMethod ( i . next ()); }","title":"Arrays and Collections"},{"location":"week-1/ce204-week-1/#casting","text":"Java is very strict about types If variable v is declared to have type X, you can only invoke operations on v that are defined in X or its superclasses Even though an instance of a subclass of X may be actually stored in the variable If you know an instance of a subclass is stored, then you can cast the variable to the subclass E.g. if I know a Vector contains instances of String, I can get the next element of its Iterator using: (String)i.next(); To avoid casting you could also have used templates:: a = ArrayList<String>; i=a.iterator(); i.next()","title":"Casting"},{"location":"week-1/ce204-week-1/#exceptions","text":"Anything that can go wrong should result in the raising of an Exception Exception is a class with many subclasses for specific things that can go wrong Use a try - catch block to trap an exception 1 2 3 4 5 6 7 8 try { // some code } catch ( ArithmeticException e ) { // code to handle division by zero }","title":"Exceptions"},{"location":"week-1/ce204-week-1/#interfaces","text":"Like abstract classes, but cannot have executable statements Define a set of operations that make sense in several classes Abstract Data Types A class can implement any number of interfaces It must have concrete methods for the operations You can declare the type of a variable to be an interface This is just like declaring the type to be an abstract class Important interfaces in Java\u2019s library include Runnable, Collection, Iterator, Comparable, Cloneable","title":"Interfaces"},{"location":"week-1/ce204-week-1/#packages-and-importing","text":"A package combines related classes into subsystems All the classes in a particular directory Classes in different packages can have the same name Although not recommended Importing a package is done as follows: import finance.banking.accounts.*;","title":"Packages and importing"},{"location":"week-1/ce204-week-1/#access-control","text":"Applies to methods and variables public Any class can access protected Only code in the package, or subclasses can access (blank) Only code in the package can access private Only code written in the class can access Inheritance still occurs!","title":"Access control"},{"location":"week-1/ce204-week-1/#threads-and-concurrency","text":"Thread : Sequence of executing statements that can be running concurrently with other threads To create a thread in Java : Create a class implementing Runnable or extending Thread Implement the run method as a loop that does something for a period of time Create an instance of this class Invoke the start operation, which calls run","title":"Threads and concurrency"},{"location":"week-1/ce204-week-1/#programming-style-guidelines","text":"Remember that programs are for people to read Always choose the simpler alternative Reject clever code that is hard to understand Shorter code is not necessarily better Choose good names Make them highly descriptive Do not worry about using long names","title":"Programming Style Guidelines"},{"location":"week-1/ce204-week-1/#programming-style","text":"Comment extensively Comment whatever is non-obvious Do not comment the obvious Comments should be 25-50% of the code Organize class elements consistently Variables, constructors, public methods then private methods Be consistent regarding layout of code","title":"Programming style"},{"location":"week-1/ce204-week-1/#programming-style_1","text":"Avoid duplication of code Do not \"clone\" if possible Create a new method and call it Cloning results in two copies that may both have bugs When one copy of the bug is fixed, the other may be forgotten","title":"Programming style"},{"location":"week-1/ce204-week-1/#programming-style_2","text":"Adhere to good object oriented principles E.g. the \u2018isa rule\u2019 Prefer private as opposed to public Do not mix user interface code with non-user interface code Interact with the user in separate classes This makes non-UI classes more reusable","title":"Programming style"},{"location":"week-1/ce204-week-1/#difficulties-and-risks-in-programming","text":"Language evolution and deprecated features : Java is evolving, so some features are \u2018deprecated\u2019 at every release Efficiency can be a concern in some object oriented systems Java can be less efficient than other languages VM-based Dynamic binding","title":"Difficulties and Risks in Programming"},{"location":"week-1/ce204-week-1/#c-vs-java","text":"Comparison Index C++ Java Platform-independent C++ is platform-dependent. Java is platform-independent. Mainly used for C++ is mainly used for system programming. Java is mainly used for application programming. It is widely used in Windows-based, web-based, enterprise, and mobile applications.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_1","text":"Comparison Index C++ Java Multiple inheritance C++ supports multiple inheritance. Java doesn't support multiple inheritance through class. It can be achieved by using interfaces in java. Operator Overloading C++ supports operator overloading. Java doesn't support operator overloading.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_2","text":"Comparison Index C++ Java Goto C++ supports the goto statement. Java doesn't support the goto statement. Compiler and Interpreter C++ uses compiler only. C++ is compiled and run using the compiler which converts source code into machine code so, C++ is platform dependent. Java uses both compiler and interpreter. Java source code is converted into bytecode at compilation time. The interpreter executes this bytecode at runtime and produces output. Java is interpreted that is why it is platform-independent.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_3","text":"Comparison Index C++ Java Pointers C++ supports pointers. You can write a pointer program in C++. Java supports pointer internally. However, you can't write the pointer program in java. It means java has restricted pointer support in java. Design Goal C++ was designed for systems and applications programming. It was an extension of the C programming language. Java was designed and created as an interpreter for printing systems but later extended as a support network computing. It was designed to be easy to use and accessible to a broader audience.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_4","text":"Comparison Index C++ Java Structure and Union C++ supports structures and unions. Java doesn't support structures and unions. Thread Support C++ doesn't have built-in support for threads. It relies on third-party libraries for thread support. Java has built-in thread support.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_5","text":"Comparison Index C++ Java Documentation comment C++ doesn't support documentation comments. Java supports documentation comment (/** ... */) to create documentation for java source code. Virtual Keyword C++ supports virtual keyword so that we can decide whether or not to override a function. Java has no virtual keyword. We can override all non-static methods by default. In other words, non-static methods are virtual by default.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_6","text":"Comparison Index C++ Java unsigned right shift >>> C++ doesn't support >>> operator. Java supports unsigned right shift >>> operator that fills zero at the top for the negative numbers. For positive numbers, it works same like >> operator. Inheritance Tree C++ always creates a new inheritance tree. Java always uses a single inheritance tree because all classes are the child of the Object class in Java. The Object class is the root of the inheritance tree in java.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#c-vs-java_7","text":"Comparison Index C++ Java Hardware C++ is nearer to hardware. Java is not so interactive with hardware. Object-oriented C++ is an object-oriented language. However, in the C language, a single root hierarchy is not possible. Java is also an object-oriented language. However, everything (except fundamental types) is an object in Java. It is a single root hierarchy as everything gets derived from java.lang.Object.","title":"C++ vs Java"},{"location":"week-1/ce204-week-1/#object-orientation-part-2","text":"","title":"Object Orientation Part-2"},{"location":"week-1/ce204-week-1/#procedural-programming","text":"Pascal, C, Basic, Fortran and similar traditional languages are procedural Each statement tells the computer to do something The emphasis is on doing things Functions A program is divided into functions Each function has a clearly defined purpose and interface","title":"Procedural Programming"},{"location":"week-1/ce204-week-1/#procedural-programming_1","text":"","title":"Procedural Programming"},{"location":"week-1/ce204-week-1/#problems-with-procedural-programming","text":"Data Is undervalued Data is, after all, the reason for a program\u2019s existence. The important parts of a program are not functions that display the data or functions that checks for correct input; they are data Procedural programs don\u2019t model the real world very well. The real world does not consist of functions Global data can be corrupted by functions that have no business changing it To add new data items, all the functions that access data must be modified so that they can also access these new items Creating new data types is difficult","title":"Problems with Procedural Programming"},{"location":"week-1/ce204-week-1/#besides","text":"It is also possible to write good programs by using procedural programming (C programs). But object-oriented programming offers programmers many advantages, enables them to write high-quality programs","title":"Besides"},{"location":"week-1/ce204-week-1/#object-oriented-programming","text":"The fundamental idea behind object-oriented programming: The real world consists of objects. Computer programs may contain computer world representations of the things (objects) that constitute the solutions of real world problems. Real world objects have two parts: Properties (or state: characteristics that can change), Behavior (or abilities: things they can do). To solve a programming problem in an object-oriented language,the programmer no longer asks how the problem will be divided into functions, but how it will be divided into objects . The emphasis is on data","title":"Object-Oriented Programming"},{"location":"week-1/ce204-week-1/#object-oriented-programming_1","text":"What kinds of things become objects in object-oriented programs? Human entities : Employees, customers, salespeople,worker, manager Graphics program : Point, line, square, circle, ... Mathematics : Complex numbers, matrix Computer user environment : Windows, menus, buttons Data-storage constructs : Customized arrays, stacks, linked lists","title":"Object-Oriented Programming"},{"location":"week-1/ce204-week-1/#oop-encapsulation-and-data-hiding","text":"Thinking in terms of objects rather than functions Close match between objects in the programming sense and objects in the real world Both data and the functions that operate on that data are combined into a single program entity Data represent the properties (state), and functions represent the behavior of an object. Data and its functions are said to be encapsulated into a single entity An object\u2019s functions, called member functions in Java typically provide the only way to access its data. The data is hidden , so it is safe from accidental alteration.","title":"OOP: Encapsulation and Data Hiding"},{"location":"week-1/ce204-week-1/#oop-encapsulation-and-data-hiding_1","text":"Encapsulation and data hiding are key terms in the description of object-oriented languages. If you want to modify the data in an object, you know exactly what functions to interact with it The member functions in the object. No other functions can access the data: This simplifies writing, debugging, and maintaining the program.","title":"OOP: Encapsulation and Data Hiding"},{"location":"week-1/ce204-week-1/#example-a-point-on-the-plane","text":"A Point on a plane has two properties; x-y coordinates. Abilities (behavior) of a Point are, moving on the plane, appearing on the screen and disappearing. A model for 2 dimensional points with the following parts: Two integer variables (x,y) to represent x and y coordinates A function to move the point: move A function to print the point on the screen: print A function to hide the point: hide","title":"Example: A Point on the plane"},{"location":"week-1/ce204-week-1/#example-a-point-on-the-plane_1","text":"Once the model has been built and tested, it is possible to create many objects of this model , in the main program. 1 2 3 4 5 6 7 8 9 10 11 Point pointOne = new Point ( 67 , 89 ); Point pointTwo = new Point ( 12 , 34 ); public class Point { public int x = 0 ; public int y = 0 ; public Point ( int a , int b ) { x = a ; y = b ; } }","title":"Example: A Point on the plane"},{"location":"week-1/ce204-week-1/#object-model","text":"A Java program typically consists of a number of objects that communicate with each other by calling one another\u2019s member functions.","title":"Object Model"},{"location":"week-1/ce204-week-1/#oop-vs-procedural-programming","text":"Procedural languages still require you to think in terms of the structure of the computer rather than the structure of the problem you are trying to solve. The programmer must establish the association between the machine model and the model of the problem that is actually being solved. The effort required to perform this mapping produces programs that are difficult to write and expensive to maintain . Because the real world thing and their models on the computer are quite different","title":"OOP vs. Procedural Programming"},{"location":"week-1/ce204-week-1/#example-procedural-programming","text":"Real world thing: student Computer model: char *, int, float It is said that the C language is closer to the computer than the problem .","title":"Example: Procedural Programming"},{"location":"week-1/ce204-week-1/#oop-vs-procedural-programming_1","text":"The OO approach provides tools for the programmer to represent elements in the problem space Objects are both in the problem space and the solution The OO programs are easy to update by adding new types of objects OOP allows you to describe the problem in terms of the problem, rather than in terms of the computer where the solution will run.","title":"OOP vs. Procedural Programming"},{"location":"week-1/ce204-week-1/#oop-vs-procedural-programming_2","text":"Benefits of the object-oriented programming: Readability Understandability Low probability of errors Maintenance Reusability Teamwork","title":"OOP vs. Procedural Programming"},{"location":"week-1/ce204-week-1/#oop-vs-procedural-programming_3","text":"Procedural paradigm: Software is organized around the notion of procedures Procedural abstraction Works as long as the data is simple Adding data abstractions groups together the pieces of data that describe some entity Helps reduce the system\u2019s complexity. Such as Records and structures Object oriented paradigm: Organizing procedural abstractions in the context of data abstractions","title":"OOP vs. Procedural Programming"},{"location":"week-1/ce204-week-1/#object-oriented-paradigm","text":"All computations are performed in the context of objects. The objects are instances of classes, which: are data abstractions contain procedural abstractions that operate on the objects A running program can be seen as a collection of objects collaborating to perform a given task","title":"Object Oriented paradigm"},{"location":"week-1/ce204-week-1/#a-view-of-the-two-paradigms","text":"","title":"A View of the Two paradigms"},{"location":"week-1/ce204-week-1/#classes-and-objects","text":"Object A chunk of structured data in a running software system Has properties Represent its state Has behaviour How it acts and reacts May simulate the behaviour of an object in the real world","title":"Classes and Objects"},{"location":"week-1/ce204-week-1/#objects-shown-as-a-uml-instance-diagram","text":"","title":"Objects: Shown as a UML instance diagram"},{"location":"week-1/ce204-week-1/#classes","text":"A class: A unit of abstraction in an object oriented (OO) program Represents similar objects Its instances A kind of software module Describes its instances\u2019 structure (properties) Contains methods to implement their behaviour section{ font-size: 25px; }","title":"Classes"},{"location":"week-1/ce204-week-1/#is-something-a-class-or-an-instance","text":"Something should be a class if it could have instances Something should be an instance if it is clearly a single member of the set defined by a class Film Class; instances are individual films. Reel of Film: Class; instances are physical reels Film reel with serial number SW19876 Instance of ReelOfFilm section{ font-size: 25px; }","title":"Is Something a Class or an Instance?"},{"location":"week-1/ce204-week-1/#is-something-a-class-or-an-instance_1","text":"Science Fiction Instance of the class Genre. Science Fiction Film Class; instances include \u2018Star Wars\u2019 Showing of \u2018Star Wars\u2019 in the Phoenix Cinema at 7 p.m.: Instance of ShowingOfFilm","title":"Is Something a Class or an Instance?"},{"location":"week-1/ce204-week-1/#naming-classes","text":"Use capital letters E.g. BankAccount not bankAccount Use singular nouns Use the right level of generality E.g. Municipality , not City Make sure the name has only one meaning E.g. \"bus\" has several meanings","title":"Naming classes"},{"location":"week-1/ce204-week-1/#instance-variables","text":"Variables defined inside a class corresponding to data present in each instance Also called fields or member variables Attributes Simple data E.g. name , dateOfBirth Associations Relationships to other important classes E.g. supervisor , coursesTaken","title":"Instance Variables"},{"location":"week-1/ce204-week-1/#variables-vs-objects","text":"A variable Refers to an object May refer to different objects at different points in time An object can be referred to by several different variables at the same time Type of a variable Determines what classes of objects it may contain","title":"Variables vs. Objects"},{"location":"week-1/ce204-week-1/#class-variables","text":"A class variable\u2019s value is shared by all instances of a class. Also called a static variable If one instance sets the value of a class variable, then all the other instances see the same changed value. Class variables are useful for: Default or \u2018constant\u2019 values (e.g. PI) Lookup tables and similar structures Caution : do not over-use class variables","title":"Class variables"},{"location":"week-1/ce204-week-1/#methods-operations-and-polymorphism","text":"Operation A higher-level procedural abstraction that specifies a type of behaviour Independent of any code which implements that behaviour E.g. calculating area (in general)","title":"Methods, Operations and Polymorphism"},{"location":"week-1/ce204-week-1/#methods-operations-and-polymorphism_1","text":"Method A procedural abstraction used to implement the behaviour of a class Several different classes can have methods with the same name They implement the same abstract operation in ways suitable to each class E.g. calculating area in a rectangle is done differently from in a circle","title":"Methods, Operations and Polymorphism"},{"location":"week-1/ce204-week-1/#polymorphism_2","text":"A property of object oriented software by which an abstract operation may be performed in different ways in different classes. Requires that there be multiple methods of the same name The choice of which one to execute depends on the object that is in a variable Reduces the need for programmers to code many if-else or switch statements","title":"Polymorphism"},{"location":"week-1/ce204-week-1/#organizing-classes-into-inheritance-hierarchies","text":"Superclasses Contain features common to a set of subclasses Inheritance hierarchies Show the relationships among superclasses and subclasses A triangle shows a generalization Inheritance The implicit possession by all subclasses of features defined in its superclasses","title":"Organizing Classes into Inheritance Hierarchies"},{"location":"week-1/ce204-week-1/#an-example-inheritance-hierarchy","text":"Inheritance The implicit possession by all subclasses of features defined in its superclasses","title":"An Example Inheritance Hierarchy"},{"location":"week-1/ce204-week-1/#the-is-a-rule","text":"Always check generalizations to ensure they obey the isa rule \"A checking account is an account\" \"A village is a municipality\" Should 'Province' be a subclass of 'Country'? No, it violates the is-a rule \"A province is a country\" is invalid!","title":"The Is-a Rule"},{"location":"week-1/ce204-week-1/#a-possible-inheritance-hierarchy-of-mathematical-objects","text":"","title":"A possible inheritance hierarchy of mathematical objects"},{"location":"week-1/ce204-week-1/#make-sure-all-inherited-features-make-sense-in-subclasses","text":"","title":"Make Sure all Inherited Features Make Sense in Subclasses"},{"location":"week-1/ce204-week-1/#inheritance-polymorphism-and-variables","text":"","title":"Inheritance, Polymorphism and Variables"},{"location":"week-1/ce204-week-1/#some-operations-in-the-shape-example","text":"","title":"Some Operations in the Shape Example"},{"location":"week-1/ce204-week-1/#abstract-classes-and-methods","text":"An operation should be declared to exist at the highest class in the hierarchy where it makes sense The operation may be abstract (lacking implementation) at that level If so, the class also must be abstract No instances can be created The opposite of an abstract class is a concrete class If a superclass has an abstract operation then its subclasses at some level must have a concrete method for the operation Leaf classes must have or inherit concrete methods for all operations Leaf classes must be concrete","title":"Abstract Classes and Methods"},{"location":"week-1/ce204-week-1/#overriding","text":"A method would be inherited, but a subclass contains a new version instead For extension E.g. SavingsAccount might charge an extra fee following every debit For optimization E.g. The getPerimeterLength method in Circle is much simpler than the one in Ellipse For restriction (best to avoid) E.g. scale(x,y) would not work in Circle","title":"Overriding"},{"location":"week-1/ce204-week-1/#how-a-decision-is-made-about-which-method-to-run","text":"If there is a concrete method for the operation in the current class, run that method. Otherwise, check in the immediate superclass to see if there is a method there; if so, run it. Repeat step 2, looking in successively higher superclasses until a concrete method is found and run. If no method is found, then there is an error In Java and C++ the program would not have compiled In Java and C++ the program would not have compiled","title":"How a decision is made about which method to run"},{"location":"week-1/ce204-week-1/#dynamic-binding","text":"Occurs when decision about which method to run can only be made at run time Needed when: A variable is declared to have a superclass as its type, and There is more than one possible polymorphic method that could be run among the type of the variable and its subclasses","title":"Dynamic binding"},{"location":"week-1/ce204-week-1/#key-terminology","text":"Abstraction Object \\(\\Longrightarrow\\) something in the world Class \\(\\Longrightarrow\\) objects Superclass \\(\\Longrightarrow\\) subclasses Operation \\(\\Longrightarrow\\) methods Attributes and associations \\(\\Longrightarrow\\) instance variables Modularity Code is divided into classes, and classes into methods Encapsulation Details can be hidden in classes This gives rise to information hiding : Programmers do not need to know all the details of a class","title":"Key Terminology"},{"location":"week-1/ce204-week-1/#basing-software-development-on-reusable-technology","text":"","title":"Basing Software Development on Reusable Technology"},{"location":"week-1/ce204-week-1/#building-on-the-experience-of-others","text":"Software engineers should avoid re-developing software already developed Types of reuse: Reuse of expertise Reuse of standard designs and algorithms Reuse of libraries of classes or procedures Reuse of powerful commands built into languages and operating systems Reuse of frameworks Reuse of complete applications","title":"Building on the Experience of Others"},{"location":"week-1/ce204-week-1/#frameworks-reusable-subsystems","text":"A framework is reusable software that implements a generic solution to a generalized problem. It provides common facilities applicable to different application programs. - Principle : Applications that do different, but related, things tend to have similar designs","title":"Frameworks: Reusable Subsystems"},{"location":"week-1/ce204-week-1/#frameworks-to-promote-reuse","text":"A framework is intrinsically incomplete Certain classes or methods are used by the framework, but are missing ( slots ) Some functionality is optional Allowance is made for developer to provide it ( hooks or extension points ) Developers use the services that the framework provides Taken together the services are called the Application Program Interface ( API )","title":"Frameworks to promote reuse"},{"location":"week-1/ce204-week-1/#object-oriented-frameworks","text":"In the object oriented paradigm, a framework is composed of a library of classes. The API is defined by the set of all public methods of these classes. Some of the classes will normally be abstract and there are often many Interfaces Example: A framework for payroll management A framework for frequent buyer clubs A framework for university registration A framework for e-commerce web sites","title":"Object-oriented frameworks"},{"location":"week-1/ce204-week-1/#frameworks-and-product-lines","text":"A product line (or product family) is a set of products built on a common base of technology. The various products in the product line have different features to satisfy different markets The software common to all products in included in a framework Each product is produced by filling the available hooks and slots E.g. software products offering \"demo\", \"lite\" or \"pro\" versions","title":"Frameworks and product lines"},{"location":"week-1/ce204-week-1/#types-of-frameworks","text":"A horizontal framework provides general application facilities that a large number of applications can use A vertical framework ( application framework ) is more \u2018complete\u2019 but still needs some slots to be filled to adapt it to specific application needs","title":"Types of frameworks"},{"location":"week-1/ce204-week-1/#the-client-server-architecture","text":"A distributed system is a system in which: computations are performed by separate programs \u2026 normally running on separate pieces of hardware \u2026 that co-operate to perform the task of the system. Server: A program that provides a service for other programs that connect to it using a communication channel Client A program that accesses a server (or several servers) to obtain services A server may be accessed by many clients simultaneously","title":"The Client-Server Architecture"},{"location":"week-1/ce204-week-1/#example-of-client-server-systems","text":"","title":"Example of client-server systems"},{"location":"week-1/ce204-week-1/#activities-of-a-server","text":"Initializes itself Starts listening for clients Handles the following types of events originating from clients accepts connections responds to messages handles client disconnection May stop listening Must cleanly terminate","title":"Activities of a server"},{"location":"week-1/ce204-week-1/#activities-of-a-client","text":"Initializes itself Initiates a connection Sends messages Handles the following types of events originating from the server responds to messages handles server disconnection Must cleanly terminate","title":"Activities of a client"},{"location":"week-1/ce204-week-1/#threads-in-a-client-server-system","text":"","title":"Threads in a client-server system"},{"location":"week-1/ce204-week-1/#thin-versus-fat-client-systems","text":"Thin-client system (a) Client is made as small as possible Most of the work is done in the server. Client easy to download over the network Fat-client system (b) As much work as possible is delegated to the clients. Server can handle more clients","title":"Thin- versus fat-client systems"},{"location":"week-1/ce204-week-1/#communications-protocols","text":"The messages the client sends to the server form a language. The server has to be programmed to understand that language. The messages the server sends to the client also form a language. The client has to be programmed to understand that language. When a client and server are communicating, they are in effect having a conversation using these two languages The two languages and the rules of the conversation, taken together, are called the protocol","title":"Communications protocols"},{"location":"week-1/ce204-week-1/#tasks-to-perform-to-develop-client-server-applications","text":"Design the primary work to be performed by both client and server Design how the work will be distributed Design the details of the set of messages that will be sent Design the mechanism for Initializing Handling connections Sending and receiving messages Terminating","title":"Tasks to perform to develop client-server applications"},{"location":"week-1/ce204-week-1/#advantages-of-client-server-systems","text":"The work can be distributed among different machines The clients can access the server\u2019s functionality from a distance The client and server can be designed separately They can both be simpler There is a choice about where to keep data: All the data can be kept centrally at the server Data can be distributed among many different clients or servers The server can be accessed simultaneously by many clients Competing clients can be written to communicate with the same server, and vice-versa","title":"Advantages of client-server systems"},{"location":"week-1/ce204-week-1/#technology-needed-to-build-client-server-systems","text":"Internet Protocol (IP) Route messages from one computer to another Long messages are normally split up into small pieces Transmission Control Protocol (TCP) Handles connections between two computers Computers can then exchange many IP messages over a connection Assures that the messages have been satisfactorily received A host has an IP address and a host name Several servers can run on the same host. Each server is identified by a port number (0 to 65535). To initiate communication with a server, a client must know both the host name and the port number","title":"Technology Needed to Build Client-Server Systems"},{"location":"week-1/ce204-week-1/#establishing-a-connection-in-java","text":"The java.net package Permits the creation of a TCP/IP connection between two applications Before a connection can be established, the server must start listening to one of the ports: 1 2 ServerSocket serverSocket = new ServerSocket ( port ); Socket clientSocket = serverSocket . accept (); For a client to connect to a server: 1 Socket clientSocket = new Socket ( host , port );","title":"Establishing a connection in Java"},{"location":"week-1/ce204-week-1/#exchanging-information-in-java","text":"Each program uses an instance of InputStream to receive messages from the other program OutputStream to send messages to the other program These are found in package java.io 1 output = clientSocket . getOutputStream (); 1 input = clientSocket . getInputStream ();","title":"Exchanging information in Java"},{"location":"week-1/ce204-week-1/#sending-and-receiving-messages","text":"without any filters (raw bytes) 1 2 output . write ( msg ); msg = input . read (); or using DataInputStream / DataOutputStream filters 1 2 output . writeDouble ( msg ); msg = input . readDouble (); or using ObjectInputStream / ObjectOutputStream filters 1 2 output . writeObject ( msg ); msg = input . readObject ();","title":"Sending and receiving messages"},{"location":"week-1/ce204-week-1/#the-object-client-server-framework-ocsf","text":"","title":"The Object Client-Server Framework (OCSF)"},{"location":"week-1/ce204-week-1/#using-ocsf","text":"Software engineers using OCSF never modify its three classes They: Create subclasses of the abstract classes in the framework Call public methods that are provided by the framework Override certain slot and hook methods (explicitly designed to be overridden)","title":"Using OCSF"},{"location":"week-1/ce204-week-1/#the-client-side","text":"Consists of a single class: AbstractClient Must be subclassed Any subclass must provide an implementation for handleMessageFromServer Takes appropriate action when a message is received from a server Implements the Runnable interface Has a run method which Contains a loop that executes for the lifetime of the thread","title":"The Client Side"},{"location":"week-1/ce204-week-1/#the-public-interface-of-abstractclient","text":"Controlling methods: openConnection closeConnection sendToServer Accessing methods: isConnected getHost setHost getPort setPort getInetAddress","title":"The public interface of AbstractClient"},{"location":"week-1/ce204-week-1/#the-callback-methods-of-abstractclient","text":"Methods that may be overridden: connectionEstablished connectionClosed Method that must be implemented: handleMessageFromServer","title":"The callback methods of AbstractClient"},{"location":"week-1/ce204-week-1/#using-abstractclient","text":"Create a subclass of AbstractClient Implement handleMessageFromServer slot method Write code that: Creates an instance of the new subclass Calls openConnection Sends messages to the server using the sendToServer service method Implement the connectionClosed callback Implement the connectionException callback","title":"Using AbstractClient"},{"location":"week-1/ce204-week-1/#internals-of-abstractclient","text":"Instance variables: A Socket which keeps all the information about the connection to the server Two streams, an ObjectOutputStream and an ObjectInputStream A Thread that runs using AbstractClient\u2019s run method Two variables storing the host and port of the server","title":"Internals of AbstractClient"},{"location":"week-1/ce204-week-1/#the-server-side","text":"Two classes: One for the thread which listens for new connections ( AbstractServer ) One for the threads that handle the connections to clients ( ConnectionToClient )","title":"The Server Side"},{"location":"week-1/ce204-week-1/#the-public-interface-of-abstractserver","text":"Controlling methods: listen stopListening close sendToAllClients Accessing methods: isListening getClientConnections getPort setPort setBacklog","title":"The public interface of AbstractServer"},{"location":"week-1/ce204-week-1/#the-callback-methods-of-abstractserver","text":"Methods that may be overridden: serverStarted clientConnected clientDisconnected clientException serverStopped listeningException serverClosed Method that must be implemented: handleMessageFromClient","title":"The callback methods of AbstractServer"},{"location":"week-1/ce204-week-1/#the-public-interface-of-connectiontoclient","text":"Controlling methods: sendToClient close Accessing methods: getInetAddress setInfo getInfo","title":"The public interface of ConnectionToClient"},{"location":"week-1/ce204-week-1/#using-abstractserver-and-connectiontoclient","text":"Create a subclass of AbstractServer Implement the slot method handleMessageFromClient Write code that: Creates an instance of the subclass of AbstractServer Calls the listen method Sends messages to clients, using: the getClientConnections and sendToClient service methods or sendToAllClients Implement one or more of the other callback methods","title":"Using AbstractServer and ConnectionToClient"},{"location":"week-1/ce204-week-1/#internals-of-abstractserver-and-connectiontoclient","text":"The setInfo and getInfo methods make use of a Java class called HashMap Many methods in the server side are synchronized The collection of instances of ConnectionToClient is stored using a special class called ThreadGroup The server must pause from listening every 500ms to see if the stopListening method has been called if not, then it resumes listening immediately","title":"Internals of AbstractServer and ConnectionToClient"},{"location":"week-1/ce204-week-1/#an-instant-messaging-application-simplechat","text":"ClientConsole can eventually be replaced by ClientGUI","title":"An Instant Messaging Application: SimpleChat"},{"location":"week-1/ce204-week-1/#the-server","text":"EchoServer is a subclass of AbstractServer The main method creates a new instance and starts it It listens for clients and handles connections until the server is stopped The three callback methods just print out a message to the user handleMessageFromClient , serverStarted and serverStopped The slot method handleMessageFromClient calls sendToAllClients This echoes any messages","title":"The server"},{"location":"week-1/ce204-week-1/#key-code-in-echoserver","text":"1 2 3 4 5 6 7 8 public void handleMessageFromClient ( Object msg , ConnectionToClient client ) { System . out . println ( \"Message received: \" + msg + \" from \" + client ); this . sendToAllClients ( msg ); }","title":"Key code in  EchoServer"},{"location":"week-1/ce204-week-1/#the-client","text":"When the client program starts, it creates instances of two classes: ChatClient A subclass of AbstractClient Overrides handleMessageFromServer This calls the display method of the user interface ClientConsole User interface class that implements the interface ChatIF Hence implements display which outputs to the console Accepts user input by calling accept in its run method Sends all user input to the ChatClient by calling its handleMessageFromClientUI This, in turn, calls sendToServer","title":"The client"},{"location":"week-1/ce204-week-1/#key-code-in-chatclient","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void handleMessageFromClientUI ( String message ) { try { sendToServer ( message ); } catch ( IOException e ) { clientUI . display ( \"Could not send message. \" + \"Terminating client.\" ); quit (); } }","title":"Key code in ChatClient"},{"location":"week-1/ce204-week-1/#key-code-in-chatclient_1","text":"1 2 3 4 public void handleMessageFromServer ( Object msg ) { clientUI . display ( msg . toString ()); }","title":"Key code in ChatClient"},{"location":"week-1/ce204-week-1/#risks-when-reusing-technology","text":"Poor quality reusable components Ensure that the developers of the reusable technology: follow good software engineering practices are willing to provide active support Compatibility not maintained Avoid obscure features Only re-use technology that others are also re-using","title":"Risks when reusing technology"},{"location":"week-1/ce204-week-1/#risks-when-developing-reusable-technology","text":"Investment uncertainty Plan the development of the reusable technology, just as if it was a product for a client The \"not invented here syndrome\" Build confidence in the reusable technology by: Guaranteeing support Ensuring it is of high quality Responding to the needs of its users","title":"Risks when developing reusable technology"},{"location":"week-1/ce204-week-1/#risks-when-developing-reusable-technology_1","text":"Competition The reusable technology must be as useful and as high quality as possible Divergence (tendency of various groups to change technology in different ways) Design it to be general enough, test it and review it in advance","title":"Risks when developing reusable technology"},{"location":"week-1/ce204-week-1/#risks-when-adopting-a-client-server-approach","text":"Security Security is a big problem with no perfect solutions: consider the use of encryption, firewalls, ... Need for adaptive maintenance Ensure that all software is forward and backward compatible with other versions of clients and servers","title":"Risks when adopting a client-server approach"},{"location":"week-1/ce204-week-1/#java-classes-and-objects","text":"","title":"Java Classes and Objects"},{"location":"week-1/ce204-week-1/#java-classes","text":"Java is an object-oriented programming language, so everything in java program must be based on the object concept. In a java programming language, the class concept defines the skeleton of an object.","title":"Java Classes"},{"location":"week-1/ce204-week-1/#java-classes_1","text":"The java class is a template of an object. The class defines the blueprint of an object. Every class in java forms a new data type. Once a class got created, we can generate as many objects as we want. Every class defines the properties and behaviors of an object. All the objects of a class have the same properties and behaviors that were defined in the class.","title":"Java Classes"},{"location":"week-1/ce204-week-1/#java-classes_2","text":"Every class of java programming language has the following characteristics. Identity - It is the name given to the class. State - Represents data values that are associated with an object. Behavior - Represents actions can be performed by an object.","title":"Java Classes"},{"location":"week-1/ce204-week-1/#java-classes_3","text":"","title":"Java Classes"},{"location":"week-1/ce204-week-1/#creating-a-class","text":"In java, we use the keyword class to create a class. A class in java contains properties as variables and behaviors as methods. Following is the syntax of class in the java. 1 2 3 4 class < ClassName > { data members declaration ; methods defination ; } Here, fields (variables) and methods represent the state and behavior of the object respectively. fields are used to store data methods are used to perform some operations","title":"Creating a Class"},{"location":"week-1/ce204-week-1/#creating-a-class_1","text":"A class is a blueprint for the object. Before we create an object, we first need to define the class. We can think of the class as a sketch (prototype) of a house. It contains all the details about the floors, doors, windows, etc. Based on these descriptions we build the house. House is the object. Since many houses can be made from the same description, we can create many objects from a class.","title":"Creating a Class"},{"location":"week-1/ce204-week-1/#creating-a-class_2","text":"The ClassName must begin with an alphabet, and the Upper-case letter is preferred. The ClassName must follow all naming rules.","title":"Creating a Class"},{"location":"week-1/ce204-week-1/#creating-a-class_3","text":"1 2 3 4 5 6 7 8 9 10 class Bicycle { // state or field private int gear = 5 ; // behavior or method public void braking () { System . out . println ( \"Working of Braking\" ); } } In the above example, we have created a class named Bicycle. It contains a field named gear and a method named braking().","title":"Creating a Class"},{"location":"week-1/ce204-week-1/#creating-a-class_4","text":"Here, Bicycle is a prototype. Now, we can create any number of bicycles using the prototype. And, all the bicycles will share the fields and methods of the prototype.","title":"Creating a Class"},{"location":"week-1/ce204-week-1/#creating-an-object","text":"In java, an object is an instance of a class. When an object of a class is created, the class is said to be instantiated. All the objects that are created using a single class have the same properties and methods. But the value of properties is different for every object. Following is the syntax of class in the java. 1 < ClassName > < objectName > = new < ClassName > ( );","title":"Creating an Object"},{"location":"week-1/ce204-week-1/#creating-an-object_1","text":"The objectName must begin with an alphabet, and a Lower-case letter is preferred. The objectName must follow all naming rules.","title":"Creating an Object"},{"location":"week-1/ce204-week-1/#creating-an-object_2","text":"An object is called an instance of a class. For example, suppose Bicycle is a class then MountainBicycle, SportsBicycle, TouringBicycle, etc can be considered as objects of the class. 1 2 3 4 5 6 className object = new className (); // for Bicycle class Bicycle sportsBicycle = new Bicycle (); Bicycle touringBicycle = new Bicycle (); We have used the new keyword along with the constructor of the class to create an object. Constructors are similar to methods and have the same name as the class. For example, Bicycle() is the constructor of the Bicycle class.","title":"Creating an Object"},{"location":"week-1/ce204-week-1/#creating-an-object_3","text":"Here, sportsBicycle and touringBicycle are the names of objects. We can use them to access fields and methods of the class.","title":"Creating an Object"},{"location":"week-1/ce204-week-1/#access-members-of-a-class","text":"sportsBicycle.gear - access the field gear sportsBicycle.braking() - access the method braking() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Bicycle { // field of class int gear = 5 ; // method of class void braking () { ... } } // create object Bicycle sportsBicycle = new Bicycle (); // access field and method sportsBicycle . gear ; sportsBicycle . braking ();","title":"Access Members of a Class"},{"location":"week-1/ce204-week-1/#example-java-class-and-objects","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Lamp { // stores the value for light // true if light is on // false if light is off boolean isOn ; // method to turn on the light void turnOn () { isOn = true ; System . out . println ( \"Light on? \" + isOn ); } // method to turnoff the light void turnOff () { isOn = false ; System . out . println ( \"Light on? \" + isOn ); } }","title":"Example: Java Class and Objects"},{"location":"week-1/ce204-week-1/#example-java-class-and-objects_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Main { public static void main ( String [] args ) { // create objects led and halogen Lamp led = new Lamp (); Lamp halogen = new Lamp (); // turn on the light by // calling method turnOn() led . turnOn (); // turn off the light by // calling method turnOff() halogen . turnOff (); } }","title":"Example: Java Class and Objects"},{"location":"week-1/ce204-week-1/#example-create-objects-inside-the-same-class","text":"Note that in the previous example, we have created objects inside another class and accessed the members from that class. However, we can also create objects inside the same class.","title":"Example: Create objects inside the same class"},{"location":"week-1/ce204-week-1/#example-create-objects-inside-the-same-class_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Lamp { // stores the value for light // true if light is on // false if light is off boolean isOn ; // method to turn on the light void turnOn () { isOn = true ; System . out . println ( \"Light on? \" + isOn ); } public static void main ( String [] args ) { // create an object of Lamp Lamp led = new Lamp (); // access method using object led . turnOn (); } }","title":"Example: Create objects inside the same class"},{"location":"week-1/ce204-week-1/#java-methods","text":"","title":"Java Methods"},{"location":"week-1/ce204-week-1/#java-methods_1","text":"A method is a block of statements under a name that gets executes only when it is called. Every method is used to perform a specific task. The major advantage of methods is code re-usability (define the code once, and use it many times).","title":"Java Methods"},{"location":"week-1/ce204-week-1/#java-methods_2","text":"In a java programming language, a method defined as a behavior of an object. That means, every method in java must belong to a class. Every method in java must be declared inside a class.","title":"Java Methods"},{"location":"week-1/ce204-week-1/#java-methods_3","text":"Every method declaration has the following characteristics. returnType - Specifies the data type of a return value. name - Specifies a unique name to identify it. parameters - The data values it may accept or recieve. { } - Defienes the block belongs to the method.","title":"Java Methods"},{"location":"week-1/ce204-week-1/#creating-a-method","text":"A method is created inside the class and it may be created with any access specifier. However, specifying access specifier is optional. Following is the syntax for creating methods in java. 1 2 3 4 5 6 7 class < ClassName > { < accessSpecifier > < returnType > < methodName > ( parameters ){ ... block of statements ; ... } }","title":"Creating a method"},{"location":"week-1/ce204-week-1/#creating-a-method_1","text":"1 2 3 modifier static returnType nameOfMethod ( parameter1 , parameter2 , ...) { // method body } modifier - It defines access types whether the method is public, private, and so on. static - If we use the static keyword, it can be accessed without creating objects.","title":"Creating a method"},{"location":"week-1/ce204-week-1/#creating-a-method_2","text":"The methodName must begin with an alphabet, and the Lower-case letter is preferred. The methodName must follow all naming rules. If you don't want to pass parameters, we ignore it. If a method defined with return type other than void, it must contain the return statement, otherwise, it may be ignored.","title":"Creating a method"},{"location":"week-1/ce204-week-1/#calling-a-method","text":"In java, a method call precedes with the object name of the class to which it belongs and a dot operator. It may call directly if the method defined with the static modifier. Every method call must be made, as to the method name with parentheses (), and it must terminate with a semicolon. 1 < objectName > . < methodName > ( actualArguments );","title":"Calling a method"},{"location":"week-1/ce204-week-1/#calling-a-method_1","text":"The method call must pass the values to parameters if it has. If the method has a return type, we must provide the receiver.","title":"Calling a method"},{"location":"week-1/ce204-week-1/#calling-a-method-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.Scanner ; public class JavaMethodsExample { int sNo ; String name ; Scanner read = new Scanner ( System . in ); void readData () { System . out . print ( \"Enter Serial Number: \" ); sNo = read . nextInt (); System . out . print ( \"Enter the Name: \" ); name = read . next (); } static void showData ( int sNo , String name ) { System . out . println ( \"Hello, \" + name + \"! your serial number is \" + sNo ); } ...","title":"Calling a Method : Example"},{"location":"week-1/ce204-week-1/#calling-a-method-example_1","text":"1 2 3 4 5 6 7 ... public static void main ( String [] args ) { JavaMethodsExample obj = new JavaMethodsExample (); obj . readData (); // method call using object showData ( obj . sNo , obj . name ); // method call without using object } }","title":"Calling a Method : Example"},{"location":"week-1/ce204-week-1/#variable-arguments-of-a-method","text":"In java, a method can be defined with a variable number of arguments. That means creating a method that receives any number of arguments of the same data type. 1 < returnType > < methodName > ( dataType ... parameterName );","title":"Variable arguments of a method"},{"location":"week-1/ce204-week-1/#variable-arguments-of-a-method-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class JavaMethodWithVariableArgs { void diaplay ( int ... list ) { System . out . println ( \"\\nNumber of arguments: \" + list . length ); for ( int i : list ) { System . out . print ( i + \"\\t\" ); } } ...","title":"Variable arguments of a method : Example"},{"location":"week-1/ce204-week-1/#variable-arguments-of-a-method-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 ... public static void main ( String [] args ) { JavaMethodWithVariableArgs obj = new JavaMethodWithVariableArgs (); obj . diaplay ( 1 , 2 ); obj . diaplay ( 10 , 20 , 30 , 40 , 50 ); } }","title":"Variable arguments of a method : Example"},{"location":"week-1/ce204-week-1/#java-normal-method-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Main { // create a method public int addNumbers ( int a , int b ) { int sum = a + b ; // return value return sum ; } public static void main ( String [] args ) { int num1 = 25 ; int num2 = 15 ; // create an object of Main Main obj = new Main (); // calling method int result = obj . addNumbers ( num1 , num2 ); System . out . println ( \"Sum is: \" + result ); } }","title":"Java Normal Method Example"},{"location":"week-1/ce204-week-1/#java-static-method-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Main { // create a method public static int square ( int num ) { // return statement return num * num ; } public static void main ( String [] args ) { int result ; // call the method // store returned value to result result = square ( 10 ); System . out . println ( \"Squared value of 10 is: \" + result ); } }","title":"Java Static Method Example"},{"location":"week-1/ce204-week-1/#java-method-parameters","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Main { // method with no parameter public void display1 () { System . out . println ( \"Method without parameter\" ); } // method with single parameter public void display2 ( int a ) { System . out . println ( \"Method with a single parameter: \" + a ); } public static void main ( String [] args ) { // create an object of Main Main obj = new Main (); // calling method with no parameter obj . display1 (); // calling method with the single parameter obj . display2 ( 24 ); } }","title":"Java Method Parameters"},{"location":"week-1/ce204-week-1/#java-method-overloading","text":"","title":"Java Method Overloading"},{"location":"week-1/ce204-week-1/#java-method-overloading_1","text":"two or more methods may have the same name if they differ in parameters (different number of parameters, different types of parameters, or both). These methods are called overloaded methods and this feature is called method overloading.","title":"Java Method Overloading"},{"location":"week-1/ce204-week-1/#java-method-overloading_2","text":"1 2 3 4 void func () { ... } void func ( int a ) { ... } float func ( double a ) { ... } float func ( int a , float b ) { ... } Note : The return types of the above methods are not the same. It is because method overloading is not associated with return types. Overloaded methods may have the same or different return types, but they must differ in parameters.","title":"Java Method Overloading"},{"location":"week-1/ce204-week-1/#why-method-overloading","text":"Suppose, you have to perform the addition of given numbers but there can be any number of arguments (let\u2019s say either 2 or 3 arguments for simplicity). In order to accomplish the task, you can create two methods sum2num(int, int) and sum3num(int, int, int) for two and three parameters respectively. However, other programmers, as well as you in the future may get confused as the behavior of both methods are the same but they differ by name. The better way to accomplish this task is by overloading methods. And, depending upon the argument passed, one of the overloaded methods is called. This helps to increase the readability of the program.","title":"Why method overloading?"},{"location":"week-1/ce204-week-1/#how-to-perform-method-overloading-in-java","text":"Overloading by changing the number of parameters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MethodOverloading { private static void display ( int a ){ System . out . println ( \"Arguments: \" + a ); } private static void display ( int a , int b ){ System . out . println ( \"Arguments: \" + a + \" and \" + b ); } public static void main ( String [] args ) { display ( 1 ); display ( 1 , 4 ); } }","title":"How to perform method overloading in Java?"},{"location":"week-1/ce204-week-1/#how-to-perform-method-overloading-in-java_1","text":"Method Overloading by changing the data type of parameters 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MethodOverloading { // this method accepts int private static void display ( int a ){ System . out . println ( \"Got Integer data.\" ); } // this method accepts String object private static void display ( String a ){ System . out . println ( \"Got String object.\" ); } public static void main ( String [] args ) { display ( 1 ); display ( \"Hello\" ); } }","title":"How to perform method overloading in Java?"},{"location":"week-1/ce204-week-1/#java-overloading-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class HelperService { private String formatNumber ( int value ) { return String . format ( \"%d\" , value ); } private String formatNumber ( double value ) { return String . format ( \"%.3f\" , value ); } private String formatNumber ( String value ) { return String . format ( \"%.2f\" , Double . parseDouble ( value )); } public static void main ( String [] args ) { HelperService hs = new HelperService (); System . out . println ( hs . formatNumber ( 500 )); System . out . println ( hs . formatNumber ( 89.9934 )); System . out . println ( hs . formatNumber ( \"550\" )); } }","title":"Java Overloading Example"},{"location":"week-1/ce204-week-1/#java-constructor","text":"","title":"Java Constructor"},{"location":"week-1/ce204-week-1/#java-constructor_1","text":"A constructor is a special method of a class that has the same name as the class name. The constructor gets executes automatically on object creation. It does not require the explicit method call. A constructor may have parameters and access specifiers too. In java, if you do not provide any constructor the compiler automatically creates a default constructor.","title":"Java Constructor"},{"location":"week-1/ce204-week-1/#java-constructor_2","text":"A constructor can not have return value. 1 2 3 4 5 6 7 8 9 10 11 12 public class ConstructorExample { ConstructorExample () { System . out . println ( \"Object created!\" ); } public static void main ( String [] args ) { ConstructorExample obj1 = new ConstructorExample (); ConstructorExample obj2 = new ConstructorExample (); } }","title":"Java Constructor"},{"location":"week-1/ce204-week-1/#types-of-constructor","text":"In Java, constructors can be divided into 3 types: No-Arg Constructor Parameterized Constructor Default Constructor","title":"Types of Constructor"},{"location":"week-1/ce204-week-1/#java-no-arg-constructors","text":"Java private no-arg constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Main { int i ; // constructor with no parameter private Main () { i = 5 ; System . out . println ( \"Constructor is called\" ); } public static void main ( String [] args ) { // calling the constructor without any parameter Main obj = new Main (); System . out . println ( \"Value of i: \" + obj . i ); } }","title":"Java No-Arg Constructors"},{"location":"week-1/ce204-week-1/#java-no-arg-constructors_1","text":"Java public no-arg constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Company { String name ; // public constructor public Company () { name = \"My Company\" ; } } class Main { public static void main ( String [] args ) { // object is created in another class Company obj = new Company (); System . out . println ( \"Company name = \" + obj . name ); } }","title":"Java No-Arg Constructors"},{"location":"week-1/ce204-week-1/#java-parameterized-constructor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Main { String languages ; // constructor accepting single value Main ( String lang ) { languages = lang ; System . out . println ( languages + \" Programming Language\" ); } public static void main ( String [] args ) { // call constructor by passing a single value Main obj1 = new Main ( \"Java\" ); Main obj2 = new Main ( \"Python\" ); Main obj3 = new Main ( \"C\" ); } }","title":"Java Parameterized Constructor"},{"location":"week-1/ce204-week-1/#java-default-constructor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { int a ; boolean b ; public static void main ( String [] args ) { // A default constructor is called Main obj = new Main (); System . out . println ( \"Default Value:\" ); System . out . println ( \"a = \" + obj . a ); System . out . println ( \"b = \" + obj . b ); } }","title":"Java Default Constructor"},{"location":"week-1/ce204-week-1/#java-default-values","text":"The default constructor initializes any uninitialized instance variables with default values. Type \\(\\Longrightarrow\\) Default Value boolean \\(\\Longrightarrow\\) false byte \\(\\Longrightarrow\\) 0 short \\(\\Longrightarrow\\) 0 int \\(\\Longrightarrow\\) 0 long \\(\\Longrightarrow\\) 0L char \\(\\Longrightarrow\\) \\u0000 float \\(\\Longrightarrow\\) 0.0f double \\(\\Longrightarrow\\) 0.0d object \\(\\Longrightarrow\\) Reference null","title":"Java Default Values"},{"location":"week-1/ce204-week-1/#java-default-constructor-equivalent","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Main { int a ; boolean b ; // a private constructor private Main () { a = 0 ; b = false ; } public static void main ( String [] args ) { // call the constructor Main obj = new Main (); System . out . println ( \"Default Value:\" ); System . out . println ( \"a = \" + obj . a ); System . out . println ( \"b = \" + obj . b ); } }","title":"Java Default Constructor Equivalent"},{"location":"week-1/ce204-week-1/#constructors-overloading-in-java","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Main { String language ; // constructor with no parameter Main () { this . language = \"Java\" ; } // constructor with a single parameter Main ( String language ) { this . language = language ; } public void getName () { System . out . println ( \"Programming Langauage: \" + this . language ); } ...","title":"Constructors Overloading in Java"},{"location":"week-1/ce204-week-1/#constructors-overloading-in-java_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 ... public static void main ( String [] args ) { // call constructor with no parameter Main obj1 = new Main (); // call constructor with a single parameter Main obj2 = new Main ( \"Python\" ); obj1 . getName (); obj2 . getName (); } }","title":"Constructors Overloading in Java"},{"location":"week-1/ce204-week-1/#java-inheritance","text":"","title":"Java Inheritance"},{"location":"week-1/ce204-week-1/#inheritance-concept","text":"The inheritance is a very useful and powerful concept of object-oriented programming. In java, using the inheritance concept, we can use the existing features of one class in another class. - The inheritance provides a greate advantage called code re-usability. With the help of code re-usability, the commonly used code in an application need not be written again and again.","title":"Inheritance Concept"},{"location":"week-1/ce204-week-1/#inheritance-concept_1","text":"","title":"Inheritance Concept"},{"location":"week-1/ce204-week-1/#inheritance-concept_2","text":"The inheritance is the process of acquiring the properties of one class to another class.","title":"Inheritance Concept"},{"location":"week-1/ce204-week-1/#inheritance-basics","text":"In inheritance, we use the terms like parent class, child class, base class, derived class, superclass, and subclass.","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_1","text":"The Parent class is the class which provides features to another class. The parent class is also known as Base class or Superclass . The Child class is the class which receives features from another class. The child class is also known as the Derived Class or Subclass .","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_2","text":"In the inheritance, the child class acquires the features from its parent class. But the parent class never acquires the features from its child class.","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_3","text":"There are five types of inheritances, and they are as follows. Simple Inheritance (or) Single Inheritance Multiple Inheritance Multi-Level Inheritance Hierarchical Inheritance Hybrid Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_4","text":"Simple Inheritance (or) Single Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_5","text":"Multiple Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_6","text":"Multi-Level Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_7","text":"Hierarchical Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_8","text":"Hybrid Inheritance","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#inheritance-basics_9","text":"The java programming language does not support multiple inheritance type. However, it provides an alternate with the concept of interfaces .","title":"Inheritance Basics"},{"location":"week-1/ce204-week-1/#creating-child-class-in-java","text":"In java, we use the keyword extends to create a child class. The following syntax used to create a child class in java. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class < ChildClassName > extends < ParentClassName > { ... //Implementation of child class ... } ``` - In a java programming language , a class extends only one class . - Extending multiple classes is not allowed in java . --- ### Single Inheritance in Java Example - 1 - In this type of inheritance , one child class derives from one parent class . ``` Java linenums = \"1\" class ParentClass { int a ; void setData ( int a ) { this . a = a ; } } 1 2 3 4 5 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Value of a is \" + a ); } }","title":"Creating Child Class in java"},{"location":"week-1/ce204-week-1/#single-inheritance-in-java-example-1","text":"1 2 3 4 5 6 7 8 9 10 public class SingleInheritance { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . setData ( 100 ); obj . showData (); } }","title":"Single Inheritance in Java Example-1"},{"location":"week-1/ce204-week-1/#single-inheritance-in-java-example-2","text":"1 2 3 4 5 6 7 8 class Animal { // field and method of the parent class String name ; public void eat () { System . out . println ( \"I can eat\" ); } } 1 2 3 4 5 6 7 8 // inherit from Animal class Dog extends Animal { // new method in subclass public void display () { System . out . println ( \"My name is \" + name ); } }","title":"Single Inheritance in Java Example-2"},{"location":"week-1/ce204-week-1/#single-inheritance-in-java-example-2_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // access field of superclass labrador . name = \"Rohu\" ; labrador . display (); // call method of superclass // using object of subclass labrador . eat (); } }","title":"Single Inheritance in Java Example-2"},{"location":"week-1/ce204-week-1/#single-inheritance-in-java-example-2_2","text":"","title":"Single Inheritance in Java Example-2"},{"location":"week-1/ce204-week-1/#single-inheritance-is-a-relationship","text":"In Java, inheritance is an is-a relationship. That is, we use inheritance only if there exists an is-a relationship between two classes. For example, Car is a Vehicle Orange is a Fruit Surgeon is a Doctor Dog is an Animal Here, Car can inherit from Vehicle, Orange can inherit from Fruit, and so on.","title":"Single Inheritance / is-a relationship"},{"location":"week-1/ce204-week-1/#multi-level-inheritance-in-java","text":"In this type of inheritance, the child class derives from a class which already derived from another class 1 2 3 4 5 6 class ParentClass { int a ; void setData ( int a ) { this . a = a ; } }","title":"Multi-level Inheritance in java"},{"location":"week-1/ce204-week-1/#multi-level-inheritance-in-java_1","text":"1 2 3 4 5 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Value of a is \" + a ); } } 1 2 3 4 5 class ChildChildClass extends ChildClass { void display () { System . out . println ( \"Inside ChildChildClass!\" ); } }","title":"Multi-level Inheritance in java"},{"location":"week-1/ce204-week-1/#multi-level-inheritance-in-java_2","text":"1 2 3 4 5 6 7 8 9 10 11 public class MultipleInheritance { public static void main ( String [] args ) { ChildChildClass obj = new ChildChildClass (); obj . setData ( 100 ); obj . showData (); obj . display (); } }","title":"Multi-level Inheritance in java"},{"location":"week-1/ce204-week-1/#hierarchical-inheritance-in-java","text":"In this type of inheritance, two or more child classes derive from one parent class. 1 2 3 4 5 6 class ParentClass { int a ; void setData ( int a ) { this . a = a ; } }","title":"Hierarchical Inheritance in java"},{"location":"week-1/ce204-week-1/#hierarchical-inheritance-in-java_1","text":"1 2 3 4 5 6 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass!\" ); System . out . println ( \"Value of a is \" + a ); } } 1 2 3 4 5 6 class ChildClassToo extends ParentClass { void display () { System . out . println ( \"Inside ChildClassToo!\" ); System . out . println ( \"Value of a is \" + a ); } }","title":"Hierarchical Inheritance in java"},{"location":"week-1/ce204-week-1/#hierarchical-inheritance-in-java_2","text":"1 2 3 4 5 6 7 8 9 10 11 public class HierarchicalInheritance { public static void main ( String [] args ) { ChildClass child_obj = new ChildClass (); child_obj . setData ( 100 ); child_obj . showData (); ChildClassToo childToo_obj = new ChildClassToo (); childToo_obj . setData ( 200 ); childToo_obj . display (); } }","title":"Hierarchical Inheritance in java"},{"location":"week-1/ce204-week-1/#hybrid-inheritance-in-java","text":"The hybrid inheritance is the combination of more than one type of inheritance. We may use any combination as a single with multiple inheritances, multi-level with multiple inheritances, etc.,","title":"Hybrid Inheritance in java"},{"location":"week-1/ce204-week-1/#java-access-modifiers","text":"","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_1","text":"In Java, the access specifiers (also known as access modifiers) used to restrict the scope or accessibility of a class, constructor, variable, method or data member of class and interface.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_2","text":"There are four access specifiers, and their list is below. default (or) no modifier public protected private","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_3","text":"In java, we can not employ all access specifiers on everything. The following table describes where we can apply the access specifiers.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_4","text":"Let's look at the following example java code, which generates an error because a class does not allow private access specifier unless it is an inner class. 1 2 3 private class Sample { ... }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_5","text":"In java, the accessibility of the members of a class or interface depends on its access specifiers. The following table provides information about the visibility of both data members and methods.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_6","text":"The public members can be accessed everywhere. The private members can be accessed only inside the same class. The protected members are accessible to every child class (same package or other packages). The default members are accessible within the same package but not outside the package.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int a = 10 ; public int b = 20 ; protected int c = 30 ; private int d = 40 ; void showData () { System . out . println ( \"Inside ParentClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); System . out . println ( \"d = \" + d ); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_8","text":"1 2 3 4 5 6 7 8 9 10 11 class ChildClass extends ParentClass { void accessData () { System . out . println ( \"Inside ChildClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); //System.out.println(\"d = \" + d); // private member can't be accessed } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_9","text":"1 2 3 4 5 6 7 8 9 10 11 public class AccessModifiersExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); obj . accessData (); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_10","text":"Default Access Modifier Here, the Logger class has the default access modifier 1 2 3 4 5 6 package defaultpackage ; class Logger { void message (){ System . out . println ( \"This is a message\" ); } } the class is visible to all the classes that belong to the defaultPackage package However, if we try to use the Logger class in another class outside of defaultPackage, we will get a compilation error.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_11","text":"Private Access Modifier When variables and methods are declared private, they cannot be accessed outside of the class 1 2 3 4 class Data { // private variable private String name ; }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_12","text":"Private Access Modifier 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] main ){ // create an object of Data Data d = new Data (); // access private variable and field from another class d . name = \"My App\" ; } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_13","text":"Private Access Modifier When we run the program, we will get the following error Main.java:18: error: name has private access in Data d.name = \"My App\" ; ^","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_14","text":"Private Access Modifier if we need to access those private variables we can use the getters and setters method 1 2 3 4 5 6 7 8 9 10 11 12 class Data { private String name ; // getter method public String getName () { return this . name ; } // setter method public void setName ( String name ) { this . name = name ; } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_15","text":"Private Access Modifier 1 2 3 4 5 6 7 8 9 public class Main { public static void main ( String [] main ){ Data d = new Data (); // access the private variable using the getter and setter d . setName ( \"My App\" ); System . out . println ( d . getName ()); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_16","text":"Private Access Modifier We cannot declare classes and interfaces private in Java. However, the nested classes can be declared private.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_17","text":"Protected Access Modifier When methods and data members are declared protected, we can access them within the same package as well as from subclasses .","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_18","text":"Protected Access Modifier 1 2 3 4 5 6 class Animal { // protected method protected void display () { System . out . println ( \"I am an animal\" ); } } 1 2 3 4 5 6 7 8 9 class Dog extends Animal { public static void main ( String [] args ) { // create an object of Dog class Dog dog = new Dog (); // access protected method dog . display (); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_19","text":"Protected Access Modifier (Ex-2) 1 2 3 4 5 6 7 class Animal { protected String name ; protected void display () { System . out . println ( \"I am an animal.\" ); } } 1 2 3 4 5 6 class Dog extends Animal { public void getInfo () { System . out . println ( \"My name is \" + name ); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_20","text":"Protected Access Modifier (Ex-2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // access protected field and method // using the object of subclass labrador . name = \"Rocky\" ; labrador . display (); labrador . getInfo (); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_21","text":"Protected Access Modifier We cannot declare classes or interfaces protected in Java.","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_22","text":"Public Access Modifier When methods, variables, classes, and so on are declared public, then we can access them from anywhere. 1 2 3 4 5 6 7 8 9 10 11 12 // Animal.java file // public class public class Animal { // public variable public int legCount ; // public method public void display () { System . out . println ( \"I am an animal.\" ); System . out . println ( \"I have \" + legCount + \" legs.\" ); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-access-modifiers_23","text":"Public Access Modifier 1 2 3 4 5 6 7 8 9 10 11 12 // Main.java public class Main { public static void main ( String [] args ) { // accessing the public class Animal animal = new Animal (); // accessing the public variable animal . legCount = 4 ; // accessing the public method animal . display (); } }","title":"Java Access Modifiers"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance","text":"","title":"Java Constructors in Inheritance"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance_1","text":"It is very important to understand how the constructors get executed in the inheritance concept. In the inheritance, the constructors never get inherited to any child class. In java, the default constructor of a parent class called automatically by the constructor of its child class. That means when we create an object of the child class, the parent class constructor executed, followed by the child class constructor executed.","title":"Java Constructors in Inheritance"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance-example","text":"1 2 3 4 5 6 class ParentClass { int a ; ParentClass (){ System . out . println ( \"Inside ParentClass constructor!\" ); } } 1 2 3 4 5 6 class ChildClass extends ParentClass { ChildClass (){ System . out . println ( \"Inside ChildClass constructor!!\" ); } }","title":"Java Constructors in Inheritance - Example"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance-example_1","text":"1 2 3 4 5 6 class ChildChildClass extends ChildClass { ChildChildClass (){ System . out . println ( \"Inside ChildChildClass constructor!!\" ); } } 1 2 3 4 5 6 7 public class ConstructorInInheritance { public static void main ( String [] args ) { ChildChildClass obj = new ChildChildClass (); } }","title":"Java Constructors in Inheritance - Example"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance_2","text":"if the parent class contains both default and parameterized constructor, then only the default constructor called automatically by the child class constructor","title":"Java Constructors in Inheritance"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance-example_2","text":"1 2 3 4 5 6 7 8 9 10 class ParentClass { int a ; ParentClass ( int a ){ System . out . println ( \"Inside ParentClass parameterized constructor!\" ); this . a = a ; } ParentClass (){ System . out . println ( \"Inside ParentClass default constructor!\" ); } }","title":"Java Constructors in Inheritance - Example"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance-example_3","text":"1 2 3 4 5 class ChildClass extends ParentClass { ChildClass (){ System . out . println ( \"Inside ChildClass constructor!!\" ); } } 1 2 3 4 5 public class ConstructorInInheritance { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } }","title":"Java Constructors in Inheritance - Example"},{"location":"week-1/ce204-week-1/#java-constructors-in-inheritance_3","text":"The parameterized constructor of parent class must be called explicitly using the super keyword.","title":"Java Constructors in Inheritance"},{"location":"week-1/ce204-week-1/#method-overriding-in-java-inheritance","text":"1 2 3 4 5 6 7 class Animal { // method in the superclass public void eat () { System . out . println ( \"I can eat\" ); } }","title":"Method Overriding in Java Inheritance"},{"location":"week-1/ce204-week-1/#method-overriding-in-java-inheritance_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Dog inherits Animal class Dog extends Animal { // overriding the eat() method @Override public void eat () { System . out . println ( \"I eat dog food\" ); } // new method in subclass public void bark () { System . out . println ( \"I can bark\" ); } }","title":"Method Overriding in Java Inheritance"},{"location":"week-1/ce204-week-1/#method-overriding-in-java-inheritance_2","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // call the eat() method labrador . eat (); labrador . bark (); } }","title":"Method Overriding in Java Inheritance"},{"location":"week-1/ce204-week-1/#method-overriding-in-java-inheritance_3","text":"In the above example, the eat() method is present in both the superclass Animal and the subclass Dog. Here, we have created an object labrador of Dog. Now when we call eat() using the object labrador, the method inside Dog is called. This is because the method inside the derived class overrides the method inside the base class.","title":"Method Overriding in Java Inheritance"},{"location":"week-1/ce204-week-1/#super-keyword-in-java-inheritance","text":"","title":"super Keyword in Java Inheritance"},{"location":"week-1/ce204-week-1/#super-keyword-in-java-inheritance_1","text":"the same method in the subclass overrides the method in superclass. In such a situation, the super keyword is used to call the method of the parent class from the method of the child class.","title":"super Keyword in Java Inheritance"},{"location":"week-1/ce204-week-1/#super-keyword-in-java-inheritance_2","text":"1 2 3 4 5 6 7 class Animal { // method in the superclass public void eat () { System . out . println ( \"I can eat\" ); } }","title":"super Keyword in Java Inheritance"},{"location":"week-1/ce204-week-1/#super-keyword-in-java-inheritance_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Dog inherits Animal class Dog extends Animal { // overriding the eat() method @Override public void eat () { // call method of superclass super . eat (); System . out . println ( \"I eat dog food\" ); } // new method in subclass public void bark () { System . out . println ( \"I can bark\" ); } }","title":"super Keyword in Java Inheritance"},{"location":"week-1/ce204-week-1/#super-keyword-in-java-inheritance_4","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the subclass Dog labrador = new Dog (); // call the eat() method labrador . eat (); labrador . bark (); } }","title":"super Keyword in Java Inheritance"},{"location":"week-1/ce204-week-1/#java-this-keyword","text":"","title":"Java this Keyword"},{"location":"week-1/ce204-week-1/#java-this-keyword_1","text":"In Java, this keyword is used to refer to the current object inside a method or a constructor","title":"Java this Keyword"},{"location":"week-1/ce204-week-1/#java-this-keyword_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { int instVar ; Main ( int instVar ){ this . instVar = instVar ; System . out . println ( \"this reference = \" + this ); } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"object reference = \" + obj ); } }","title":"Java this Keyword"},{"location":"week-1/ce204-week-1/#using-this-for-ambiguity-variable-names","text":"In Java, it is not allowed to declare two or more variables having the same name inside a scope (class scope or method scope). However, instance variables and parameters may have the same name.","title":"Using this for Ambiguity Variable Names"},{"location":"week-1/ce204-week-1/#using-this-for-ambiguity-variable-names_1","text":"WRONG 1 2 3 4 5 6 7 8 9 10 11 12 class Main { int age ; Main ( int age ){ age = age ; } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"obj.age = \" + obj . age ); } }","title":"Using this for Ambiguity Variable Names"},{"location":"week-1/ce204-week-1/#using-this-for-ambiguity-variable-names_2","text":"CORRECT 1 2 3 4 5 6 7 8 9 10 11 12 class Main { int age ; Main ( int age ){ this . age = age ; } public static void main ( String [] args ) { Main obj = new Main ( 8 ); System . out . println ( \"obj.age = \" + obj . age ); } }","title":"Using this for Ambiguity Variable Names"},{"location":"week-1/ce204-week-1/#this-with-getters-and-setters","text":"Another common use of this keyword is in setters and getters methods of a class 1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { String name ; // setter method void setName ( String name ) { this . name = name ; } // getter method String getName (){ return this . name ; } ...","title":"this with Getters and Setters"},{"location":"week-1/ce204-week-1/#this-with-getters-and-setters_1","text":"1 2 3 4 5 6 7 8 9 ... public static void main ( String [] args ) { Main obj = new Main (); // calling the setter and the getter method obj . setName ( \"Toshiba\" ); System . out . println ( \"obj.name: \" + obj . getName ()); } }","title":"this with Getters and Setters"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading","text":"While working with constructor overloading, we might have to invoke one constructor from another constructor. In such a case, we cannot call the constructor explicitly. Instead, we have to use this keyword.","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Complex { private int a , b ; // constructor with 2 parameters private Complex ( int i , int j ){ this . a = i ; this . b = j ; } // constructor with single parameter private Complex ( int i ){ // invokes the constructor with 2 parameters this ( i , i ); } // constructor with no parameter private Complex (){ // invokes the constructor with single parameter this ( 0 ); } ...","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override public String toString (){ return this . a + \" + \" + this . b + \"i\" ; } public static void main ( String [] args ) { // creating object of Complex class // calls the constructor with 2 parameters Complex c1 = new Complex ( 2 , 3 ); // calls the constructor with a single parameter Complex c2 = new Complex ( 3 ); // calls the constructor with no parameters Complex c3 = new Complex (); // print objects System . out . println ( c1 ); System . out . println ( c2 ); System . out . println ( c3 ); } }","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading_3","text":"In the example, we have used this keyword, to call the constructor Complex(int i, int j) from the constructor Complex(int i) to call the constructor Complex(int i) from the constructor Complex() the line, System.out.println(c1); process, the toString() is called Since we override the toString() method inside our class, we get the output according to that method.","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading_4","text":"One of the huge advantages of this() is to reduce the amount of duplicate code. However, we should be always careful while using this(). This is because calling constructor from another constructor adds overhead and it is a slow process. Another huge advantage of using this() is to reduce the amount of duplicate code.","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#using-this-in-constructor-overloading_5","text":"Invoking one constructor from another constructor is called explicit constructor invocation.","title":"Using this in Constructor Overloading"},{"location":"week-1/ce204-week-1/#passing-this-as-an-argument","text":"We can use this keyword to pass the current object as an argument to a method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ThisExample { // declare variables int x ; int y ; ThisExample ( int x , int y ) { // assign values of variables inside constructor this . x = x ; this . y = y ; // value of x and y before calling add() System . out . println ( \"Before passing this to addTwo() method:\" ); System . out . println ( \"x = \" + this . x + \", y = \" + this . y ); // call the add() method passing this as argument add ( this ); // value of x and y after calling add() System . out . println ( \"After passing this to addTwo() method:\" ); System . out . println ( \"x = \" + this . x + \", y = \" + this . y ); } void add ( ThisExample o ){ o . x += 2 ; o . y += 2 ; } }","title":"Passing this as an Argument"},{"location":"week-1/ce204-week-1/#passing-this-as-an-argument_1","text":"1 2 3 4 5 class Main { public static void main ( String [] args ) { ThisExample obj = new ThisExample ( 1 , - 2 ); } }","title":"Passing this as an Argument"},{"location":"week-1/ce204-week-1/#passing-this-as-an-argument_2","text":"In the example, inside the constructor ThisExample() , notice the line, add(this); Here, we are calling the add() method by passing this as an argument. Since this keyword contains the reference to the object obj of the class, we can change the value of x and y inside the add() method.","title":"Passing this as an Argument"},{"location":"week-1/ce204-week-1/#java-instanceof-operator","text":"","title":"Java instanceof Operator"},{"location":"week-1/ce204-week-1/#java-instanceof-operator_1","text":"The instanceof operator in Java is used to check whether an object is an instance of a particular class or not. Its syntax is objectName instanceOf className ;","title":"Java instanceof Operator"},{"location":"week-1/ce204-week-1/#example-java-instanceof","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Main { public static void main ( String [] args ) { // create a variable of string type String name = \"My App\" ; // checks if name is instance of String boolean result1 = name instanceof String ; System . out . println ( \"name is an instance of String: \" + result1 ); // create an object of Main Main obj = new Main (); // checks if obj is an instance of Main boolean result2 = obj instanceof Main ; System . out . println ( \"obj is an instance of Main: \" + result2 ); } }","title":"Example: Java instanceof"},{"location":"week-1/ce204-week-1/#example-java-instanceof_1","text":"In the example, we have created a variable name of the String type and an object obj of the Main class. Here, we have used the instanceof operator to check whether name and obj are instances of the String and Main class respectively. And, the operator returns true in both cases.","title":"Example: Java instanceof"},{"location":"week-1/ce204-week-1/#java-instanceof-during-inheritance","text":"We can use the instanceof operator to check if objects of the subclass is also an instance of the superclass.","title":"Java instanceof during Inheritance"},{"location":"week-1/ce204-week-1/#java-instanceof-during-inheritance_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Java Program to check if an object of the subclass // is also an instance of the superclass // superclass class Animal { } // subclass class Dog extends Animal { } class Main { public static void main ( String [] args ) { // create an object of the subclass Dog d1 = new Dog (); // checks if d1 is an instance of the subclass System . out . println ( d1 instanceof Dog ); // prints true // checks if d1 is an instance of the superclass System . out . println ( d1 instanceof Animal ); // prints true } }","title":"Java instanceof during Inheritance"},{"location":"week-1/ce204-week-1/#java-instanceof-during-inheritance_2","text":"In the above example, we have created a subclass Dog that inherits from the superclass Animal. We have created an object d1 of the Dog class. Inside the print statement, notice the expression, 1 d1 instanceof Animal Here, we are using the instanceof operator to check whether d1 is also an instance of the superclass Animal","title":"Java instanceof during Inheritance"},{"location":"week-1/ce204-week-1/#java-instanceof-in-interface","text":"The instanceof operator is also used to check whether an object of a class is also an instance of the interface implemented by the class","title":"Java instanceof in Interface"},{"location":"week-1/ce204-week-1/#java-instanceof-in-interface_1","text":"1 2 3 4 5 6 7 8 // Java program to check if an object of a class is also // an instance of the interface implemented by the class interface Animal { } class Dog implements Animal { }","title":"Java instanceof in Interface"},{"location":"week-1/ce204-week-1/#java-instanceof-in-interface_2","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create an object of the Dog class Dog d1 = new Dog (); // checks if the object of Dog // is also an instance of Animal System . out . println ( d1 instanceof Animal ); // returns true } }","title":"Java instanceof in Interface"},{"location":"week-1/ce204-week-1/#java-instanceof-in-interface_3","text":"In the example, the Dog class implements the Animal interface. Inside the print statement, notice the expression, 1 d1 instanceof Animal Here, d1 is an instance of Dog class. The instanceof operator checks if d1 is also an instance of the interface Animal .","title":"Java instanceof in Interface"},{"location":"week-1/ce204-week-1/#java-instanceof-in-interface_4","text":"In Java, all the classes are inherited from the Object class. So, instances of all the classes are also an instance of the Object class. In the previous example, if we check, 1 d1 instanceof Object The result will be true .","title":"Java instanceof in Interface"},{"location":"week-1/ce204-week-1/#references","text":"https://www.site.uottawa.ca/~tcl/seg2105/ https://cruise.umple.org/index.shtml https://cruise.umple.org/umple/GettingStarted.html Sanem Sar\u0131el Associate Professor, PhD BT503 Application Development with Java (Kemerburgaz University 2013-2015) How To Define The Project Scope The Foolproof Way","title":"References"},{"location":"week-1/ce204-week-1/#references_1","text":"BtechSmartClass Java OOP Concepts BtechSmartClass-Java Buzz Words JavatPoint-Cpp vs Java BtechSmartClass-Java Classes Programiz-Class Objects","title":"References"},{"location":"week-1/ce204-week-1/#references_2","text":"BtechSmartClass-Java-Methods-and-Classes Programiz-Methods Programiz-Method Overloading Programiz-Constructors BtechSmartClass-Java inheritance basics","title":"References"},{"location":"week-1/ce204-week-1/#references_3","text":"BtechSmartClass-Java access specifiers Programiz-Access Modifiers BtechSmartClass-java constructors in inheritance Programiz-Inheritance Programiz-this Keyword Programiz-instanceof \\(End-Of-Week-1-Module\\)","title":"References"},{"location":"week-10/ce204-week-10/","text":"CE204 Object-Oriented Programming \u00b6 Week-10 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-10 (Using Design Patterns)"},{"location":"week-10/ce204-week-10/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-10/ce204-week-10/#week-10-tbd","text":"","title":"Week-10 (TBD)"},{"location":"week-10/ce204-week-10/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-10/ce204-week-10/#title","text":"","title":"Title"},{"location":"week-10/ce204-week-10/#outline","text":"TBD","title":"Outline"},{"location":"week-10/ce204-week-10/#references","text":"TBD","title":"References"},{"location":"week-11/ce204-week-11/","text":"CE204 Object-Oriented Programming \u00b6 Week-11 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-11 (UML + UMPLE + Java Implementations)"},{"location":"week-11/ce204-week-11/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-11/ce204-week-11/#week-11-tbd","text":"","title":"Week-11 (TBD)"},{"location":"week-11/ce204-week-11/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-11/ce204-week-11/#title","text":"","title":"Title"},{"location":"week-11/ce204-week-11/#outline","text":"TBD","title":"Outline"},{"location":"week-11/ce204-week-11/#references","text":"TBD","title":"References"},{"location":"week-12/ce204-week-12/","text":"CE204 Object-Oriented Programming \u00b6 Week-12 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-12 (SMC Remote Service Case Study Part-I)"},{"location":"week-12/ce204-week-12/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-12/ce204-week-12/#week-12-tbd","text":"","title":"Week-12 (TBD)"},{"location":"week-12/ce204-week-12/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-12/ce204-week-12/#title","text":"","title":"Title"},{"location":"week-12/ce204-week-12/#outline","text":"TBD","title":"Outline"},{"location":"week-12/ce204-week-12/#references","text":"TBD","title":"References"},{"location":"week-13/ce204-week-13/","text":"CE204 Object-Oriented Programming \u00b6 Week-13 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-13 (SMC Remote Service Case Study Part-II)"},{"location":"week-13/ce204-week-13/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-13/ce204-week-13/#week-13-tbd","text":"","title":"Week-13 (TBD)"},{"location":"week-13/ce204-week-13/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-13/ce204-week-13/#title","text":"","title":"Title"},{"location":"week-13/ce204-week-13/#outline","text":"TBD","title":"Outline"},{"location":"week-13/ce204-week-13/#references","text":"TBD","title":"References"},{"location":"week-14/ce204-week-14/","text":"CE204 Object-Oriented Programming \u00b6 Week-14 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-14 (OOP ATM Case Study Part-I)"},{"location":"week-14/ce204-week-14/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-14/ce204-week-14/#week-14-tbd","text":"","title":"Week-14 (TBD)"},{"location":"week-14/ce204-week-14/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-14/ce204-week-14/#title","text":"","title":"Title"},{"location":"week-14/ce204-week-14/#outline","text":"TBD","title":"Outline"},{"location":"week-14/ce204-week-14/#references","text":"TBD","title":"References"},{"location":"week-15/ce204-week-15/","text":"CE204 Object-Oriented Programming \u00b6 Week-15 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-15 (OOP ATM Case Study Part-II)"},{"location":"week-15/ce204-week-15/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-15/ce204-week-15/#week-15-tbd","text":"","title":"Week-15 (TBD)"},{"location":"week-15/ce204-week-15/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-15/ce204-week-15/#title","text":"","title":"Title"},{"location":"week-15/ce204-week-15/#outline","text":"TBD","title":"Outline"},{"location":"week-15/ce204-week-15/#references","text":"TBD","title":"References"},{"location":"week-16/ce204-week-16-final/","text":"CE204 Object-Oriented Programming \u00b6 Week-16 (Final) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-16 (Final)"},{"location":"week-16/ce204-week-16-final/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-16/ce204-week-16-final/#week-16-final","text":"","title":"Week-16 (Final)"},{"location":"week-16/ce204-week-16-final/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-16/ce204-week-16-final/#title","text":"","title":"Title"},{"location":"week-16/ce204-week-16-final/#outline","text":"TBD","title":"Outline"},{"location":"week-16/ce204-week-16-final/#references","text":"TBD","title":"References"},{"location":"week-2/ce204-week-2/","text":"CE204 Object-Oriented Programming \u00b6 Week-2 (OOP with Java-II) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX OOP with Java-II \u00b6 Outline (1) \u00b6 Java super Keyword Java final Keyword Java Polymorphism / Encapsulation Java Method Overriding Java Nested Inner Class Java Static Class Java Anonymous Class Outline (2) \u00b6 Java Enums / Enum-Constructor / Enum-String Java Abstract Class Java Object Class Java Forms of Inheritance Java Benefits and Costs of Inheritance Java Packages Java Access Protection in Packages Java super keyword \u00b6 Java super keyword \u00b6 In java, super is a keyword used to refers to the parent class object . The super keyword came into existence to solve the naming conflicts in the inheritance. When both parent class and child class have members with the same name, then the super keyword is used to refer to the parent class version. Java super keyword \u00b6 In another word, The super keyword in Java is used in subclasses to access superclass members (attributes, constructors and methods). Java super keyword \u00b6 In java, the super keyword is used for the following purposes. To refer parent class data members To refer parent class methods To call parent class constructor Java super keyword \u00b6 To call methods of the superclass that is overridden in the subclass. To access attributes (fields) of the superclass if both superclass and subclass have attributes with the same name. To explicitly call superclass no-arg (default) or parameterized constructor from the subclass constructor. Java super keyword \u00b6 The super keyword is used inside the child class only. super to refer parent class data members \u00b6 When both parent class and child class have data members with the same name, then the super keyword is used to refer to the parent class data member from child class. super to refer parent class data members \u00b6 1 2 3 4 5 class ParentClass { int num = 10 ; } 1 2 3 4 5 6 7 8 9 10 class ChildClass extends ParentClass { int num = 20 ; void showData () { System . out . println ( \"Inside the ChildClass\" ); System . out . println ( \"ChildClass num = \" + num ); System . out . println ( \"ParentClass num = \" + super . num ); } } super to refer parent class data members \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); System . out . println ( \"\\nInside the non-child class\" ); System . out . println ( \"ChildClass num = \" + obj . num ); //System.out.println(\"ParentClass num = \" + super.num); //super can't be used here } } super to refer parent class method \u00b6 When both parent class and child class have method with the same name, then the super keyword is used to refer to the parent class method from child class. super to refer parent class method \u00b6 class ParentClass { int num1 = 10 ; void showData () { System . out . println ( \"\\nInside the ParentClass showData method\" ); System . out . println ( \"ChildClass num = \" + num1 ); } } super to refer parent class method \u00b6 class ChildClass extends ParentClass { int num2 = 20 ; void showData () { System . out . println ( \"\\nInside the ChildClass showData method\" ); System . out . println ( \"ChildClass num = \" + num2 ); super . showData (); } } super to refer parent class method \u00b6 public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); //super.showData(); // super can't be used here } } super to call parent class constructor \u00b6 When an object of child class is created, it automatically calls the parent class default-constructor before it's own. But, the parameterized constructor of parent class must be called explicitly using the super keyword inside the child class constructor. super to call parent class constructor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int num1 ; ParentClass (){ System . out . println ( \"\\nInside the ParentClass default constructor\" ); num1 = 10 ; } ParentClass ( int value ){ System . out . println ( \"\\nInside the ParentClass parameterized constructor\" ); num1 = value ; } } super to call parent class constructor \u00b6 1 2 3 4 5 6 7 8 9 10 class ChildClass extends ParentClass { int num2 ; ChildClass (){ super ( 100 ); System . out . println ( \"\\nInside the ChildClass constructor\" ); num2 = 200 ; } } super to call parent class constructor \u00b6 1 2 3 4 5 6 7 8 public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } } super to call parent class constructor \u00b6 To call the parameterized constructor of the parent class, the super keyword must be the first statement inside the child class constructor, and we must pass the parameter values. Access Overridden Methods of the superclass \u00b6 If methods with the same name are defined in both superclass and subclass, the method in the subclass overrides the method in the superclass. This is called method overriding. Example 1: Method overriding \u00b6 1 2 3 4 5 6 7 class Animal { // overridden method public void display (){ System . out . println ( \"I am an animal\" ); } } Example 1: Method overriding \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Dog extends Animal { // overriding method @Override public void display (){ System . out . println ( \"I am a dog\" ); } public void printMessage (){ display (); } } Example 1: Method overriding \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printMessage (); } } Example 1: Method overriding \u00b6 In this example, by making an object dog1 of Dog class, we can call its method printMessage() which then executes the display() statement. Since display() is defined in both the classes, the method of subclass Dog overrides the method of superclass Animal. Hence, the display() of the subclass is called. Example 1: Method overriding \u00b6 What if the overridden method of the superclass has to be called? \u00b6 We use super.display() if the overridden method display() of superclass Animal needs to be called. Example 2: super to Call Superclass Method \u00b6 1 2 3 4 5 6 7 class Animal { // overridden method public void display (){ System . out . println ( \"I am an animal\" ); } } Example 2: super to Call Superclass Method \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Dog extends Animal { // overriding method @Override public void display (){ System . out . println ( \"I am a dog\" ); } public void printMessage (){ // this calls overriding method display (); // this calls overridden method super . display (); } } Example 2: super to Call Superclass Method \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printMessage (); } } Example 2: super to Call Superclass Method \u00b6 Access Attributes of the Superclass \u00b6 The superclass and subclass can have attributes with the same name. We use the super keyword to access the attribute of the superclass. Example 3: Access superclass attribute \u00b6 1 2 3 class Animal { protected String type = \"animal\" ; } 1 2 3 4 5 6 7 8 class Dog extends Animal { public String type = \"mammal\" ; public void printType () { System . out . println ( \"I am a \" + type ); System . out . println ( \"I am an \" + super . type ); } } Example 3: Access superclass attribute \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printType (); } } Example 3: Access superclass attribute \u00b6 In this example, we have defined the same instance field type in both the superclass Animal and the subclass Dog . We then created an object dog1 of the Dog class. Then, the printType() method is called using this object. Inside the printType() function, type refers to the attribute of the subclass Dog . super.type refers to the attribute of the superclass Animal. Use of super() to access superclass constructor \u00b6 As we know, when an object of a class is created, its default constructor is automatically called. To explicitly call the superclass constructor from the subclass constructor, we use super() . It's a special form of the super keyword. super() can be used only inside the subclass constructor and must be the first statement. Example 4: Use of super() \u00b6 1 2 3 4 5 6 7 class Animal { // default or no-arg constructor of class Animal Animal () { System . out . println ( \"I am an animal\" ); } } Example 4: Use of super() \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Dog extends Animal { // default or no-arg constructor of class Dog Dog () { // calling default constructor of the superclass super (); System . out . println ( \"I am a dog\" ); } } Example 4: Use of super() \u00b6 1 2 3 4 5 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); } } Example 4: Use of super() \u00b6 when an object dog1 of Dog class is created, it automatically calls the default or no-arg constructor of that class. Inside the subclass constructor, the super() statement calls the constructor of the superclass and executes the statements inside it. Hence, we get the output I am an animal. Example 4: Use of super() \u00b6 The flow of the program then returns back to the subclass constructor and executes the remaining statements. Thus, I am a dog will be printed. However, using super() is not compulsory. Even if super() is not used in the subclass constructor, the compiler implicitly calls the default constructor of the superclass. Example 4: Use of super() \u00b6 So, why use redundant code if the compiler automatically invokes super()? It is required if the parameterized constructor (a constructor that takes arguments) of the superclass has to be called from the subclass constructor. The parameterized super() must always be the first statement in the body of the constructor of the subclass, otherwise, we get a compilation error. Example 5: Call Parameterized Constructor Using super() \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Animal { // default or no-arg constructor Animal () { System . out . println ( \"I am an animal\" ); } // parameterized constructor Animal ( String type ) { System . out . println ( \"Type: \" + type ); } } Example 5: Call Parameterized Constructor Using super() \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Dog extends Animal { // default constructor Dog () { // calling parameterized constructor of the superclass super ( \"Animal\" ); System . out . println ( \"I am a dog\" ); } } Example 5: Call Parameterized Constructor Using super() \u00b6 1 2 3 4 5 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); } } Example 5: Call Parameterized Constructor Using super() \u00b6 If a parameterized constructor has to be called, we need to explicitly define it in the subclass constructor. Example 5: Call Parameterized Constructor Using super() \u00b6 Note that in the above example, we explicitly called the parameterized constructor super(\"Animal\"). The compiler does not call the default constructor of the superclass in this case. Java final keyword \u00b6 Java final keyword \u00b6 In java, the final is a keyword and it is used with the following things. With variable (to create constant) With method (to avoid method overriding) With class (to avoid inheritance) Java final restrictions \u00b6 the final variable cannot be reinitialized with another value the final method cannot be overridden the final class cannot be extended final with variables \u00b6 When a variable defined with the final keyword, it becomes a constant, and it does not allow us to modify the value. The variable defined with the final keyword allows only a one-time assignment, once a value assigned to it, never allows us to change it again. final with variables example-1 \u00b6 1 2 3 4 5 6 7 public class FinalVariableExample { public static void main ( String [] args ) { final int a = 10 ; System . out . println ( \"a = \" + a ); a = 100 ; // Can't be modified } } final with variables example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create a final variable final int AGE = 32 ; // try to change the final variable AGE = 45 ; System . out . println ( \"Age: \" + AGE ); } } final with variables recommendation \u00b6 It is recommended to use uppercase to declare final variables in Java. final with methods \u00b6 When a method defined with the final keyword, it does not allow it to override. The final method extends to the child class, but the child class can not override or re-define it. It must be used as it has implemented in the parent class. final with methods example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 class ParentClass { int num = 10 ; final void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } } final with methods example-1 \u00b6 1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } } final with methods example-1 \u00b6 1 2 3 4 5 6 7 8 9 public class FinalKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); } } final with methods example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FinalDemo { // create a final method public final void display () { System . out . println ( \"This is a final method.\" ); } } class Main extends FinalDemo { // try to override final method public final void display () { System . out . println ( \"The final method is overridden.\" ); } public static void main ( String [] args ) { Main obj = new Main (); obj . display (); } } final with class \u00b6 When a class defined with final keyword, it can not be extended by any other class. final with class example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 final class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } } final with class example-1 \u00b6 1 2 3 4 class ChildClass extends ParentClass { } final with class example-1 \u00b6 1 2 3 4 5 6 7 8 public class FinalKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } } final with class example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // create a final class final class FinalClass { public void display () { System . out . println ( \"This is a final method.\" ); } } // try to extend the final class class Main extends FinalClass { public void display () { System . out . println ( \"The final method is overridden.\" ); } public static void main ( String [] args ) { Main obj = new Main (); obj . display (); } } Java Polymorphism \u00b6 Java Polymorphism \u00b6 The polymorphism is the process of defining same method with different implementation. That means creating multiple methods with different behaviors. In java, polymorphism implemented using method overloading and method overriding. Ad hoc polymorphism \u00b6 The ad hoc polymorphism is a technique used to define the same method with different implementations and different arguments. In a java programming language, ad hoc polymorphism carried out with a method overloading concept. Ad hoc polymorphism \u00b6 In ad hoc polymorphism the method binding happens at the time of compilation. Ad hoc polymorphism is also known as compile-time polymorphism. Every function call binded with the respective overloaded method based on the arguments. Ad hoc polymorphism \u00b6 The ad hoc polymorphism implemented within the class only. Ad hoc polymorphism example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.Arrays ; public class AdHocPolymorphismExample { void sorting ( int [] list ) { Arrays . parallelSort ( list ); System . out . println ( \"Integers after sort: \" + Arrays . toString ( list ) ); } void sorting ( String [] names ) { Arrays . parallelSort ( names ); System . out . println ( \"Names after sort: \" + Arrays . toString ( names ) ); } ... Ad hoc polymorphism example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 ... public static void main ( String [] args ) { AdHocPolymorphismExample obj = new AdHocPolymorphismExample (); int list [] = { 2 , 3 , 1 , 5 , 4 }; obj . sorting ( list ); // Calling with integer array String [] names = { \"rama\" , \"raja\" , \"shyam\" , \"seeta\" }; obj . sorting ( names ); // Calling with String array } } Pure polymorphism \u00b6 The pure polymorphism is a technique used to define the same method with the same arguments but different implementations. In a java programming language, pure polymorphism carried out with a method overriding concept. Pure polymorphism \u00b6 In pure polymorphism, the method binding happens at run time. Pure polymorphism is also known as run-time polymorphism. Every function call binding with the respective overridden method based on the object reference. When a child class has a definition for a member function of the parent class, the parent class function is said to be overridden. Pure polymorphism \u00b6 The pure polymorphism implemented in the inheritance concept only. Pure polymorphism example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } } Pure polymorphism example-1 \u00b6 1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } } Pure polymorphism example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class PurePolymorphism { public static void main ( String [] args ) { ParentClass obj = new ParentClass (); obj . showData (); obj = new ChildClass (); obj . showData (); } } Java Method Overriding \u00b6 During inheritance in Java, if the same method is present in both the superclass and the subclass. Then, the method in the subclass overrides the same method in the superclass. This is called method overriding. Polymorphism using method overriding example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Language { public void displayInfo () { System . out . println ( \"Common English Language\" ); } } class Java extends Language { @Override public void displayInfo () { System . out . println ( \"Java Programming Language\" ); } } \u00b6 Polymorphism using method overriding example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { // create an object of Java class Java j1 = new Java (); j1 . displayInfo (); // create an object of Language class Language l1 = new Language (); l1 . displayInfo (); } } Polymorphism using method overriding example-2 \u00b6 Java Method Overloading \u00b6 In a Java class, we can create methods with the same name if they differ in parameters. For example 1 2 3 4 void func () { ... } void func ( int a ) { ... } float func ( double a ) { ... } float func ( int a , float b ) { ... } This is known as method overloading in Java. Here, the same method will perform different operations based on the parameter. Polymorphism using method overloading example-3 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Pattern { // method without parameter public void display () { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( \"*\" ); } } // method with single parameter public void display ( char symbol ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( symbol ); } } } Polymorphism using method overloading example-3 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { Pattern d1 = new Pattern (); // call method without any argument d1 . display (); System . out . println ( \"\\n\" ); // call method with a single argument d1 . display ( '#' ); } } Polymorphic Variables \u00b6 A variable is called polymorphic if it refers to different values under different conditions. Object variables (instance variables) represent the behavior of polymorphic variables in Java. It is because object variables of a class can refer to objects of its class as well as objects of its subclasses. Polymorphic Variables Example-1 \u00b6 1 2 3 4 5 class ProgrammingLanguage { public void display () { System . out . println ( \"I am Programming Language.\" ); } } Polymorphic Variables Example-1 \u00b6 1 2 3 4 5 6 class Java extends ProgrammingLanguage { @Override public void display () { System . out . println ( \"I am Object-Oriented Programming Language.\" ); } } Polymorphic Variables Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { // declare an object variable ProgrammingLanguage pl ; // create object of ProgrammingLanguage pl = new ProgrammingLanguage (); pl . display (); // create object of Java class pl = new Java (); pl . display (); } } Java Encapsulation \u00b6 Java Encapsulation \u00b6 It prevents outer classes from accessing and changing fields and methods of a class. This also helps to achieve data hiding Java Encapsulation Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Area { // fields to calculate area int length ; int breadth ; // constructor to initialize values Area ( int length , int breadth ) { this . length = length ; this . breadth = breadth ; } // method to calculate area public void getArea () { int area = length * breadth ; System . out . println ( \"Area: \" + area ); } } Java Encapsulation Example \u00b6 1 2 3 4 5 6 7 8 9 class Main { public static void main ( String [] args ) { // create object of Area // pass value of length and breadth Area rectangle = new Area ( 5 , 6 ); rectangle . getArea (); } } Why Encapsulation? \u00b6 In Java, encapsulation helps us to keep related fields and methods together, which makes our code cleaner and easy to read. Why Encapsulation? \u00b6 It helps to control the values of our data fields 1 2 3 4 5 6 7 8 9 class Person { private int age ; public void setAge ( int age ) { if ( age >= 0 ) { this . age = age ; } } } Why Encapsulation? \u00b6 The getter and setter methods provide read-only or write-only access to our class fields 1 2 getName () // provides read-only access setName () // provides write-only access \u00b6 Why Encapsulation? \u00b6 It helps to decouple components of a system. For example, we can encapsulate code into multiple bundles. These decoupled components (bundle) can be developed, tested, and debugged independently and concurrently. And, any changes in a particular component do not have any effect on other components. Why Encapsulation? \u00b6 We can also achieve data hiding using encapsulation. In the next example, if we change the length and breadth variable into private, then the access to these fields is restricted. And, they are kept hidden from outer classes. This is called data hiding. Why Encapsulation? \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Area { // fields to calculate area int length ; int breadth ; // constructor to initialize values Area ( int length , int breadth ) { this . length = length ; this . breadth = breadth ; } // method to calculate area public void getArea () { int area = length * breadth ; System . out . println ( \"Area: \" + area ); } } Why Encapsulation? \u00b6 1 2 3 4 5 6 7 8 9 class Main { public static void main ( String [] args ) { // create object of Area // pass value of length and breadth Area rectangle = new Area ( 5 , 6 ); rectangle . getArea (); } } Data Hiding \u00b6 Data hiding is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding. We can use access modifiers to achieve data hiding Data hiding using the private specifier example \u00b6 Making age private allowed us to restrict unauthorized access from outside the class. This is data hiding. Data hiding using the private specifier example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Person { // private field private int age ; // getter method public int getAge () { return age ; } // setter method public void setAge ( int age ) { this . age = age ; } } Data hiding using the private specifier example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { public static void main ( String [] args ) { // create an object of Person Person p1 = new Person (); // change age using setter p1 . setAge ( 24 ); // access age using getter System . out . println ( \"My age is \" + p1 . getAge ()); } } Java Method Overriding \u00b6 Java Method Overriding \u00b6 The method overriding is the process of re-defining a method in a child class that is already defined in the parent class. When both parent and child classes have the same method, then that method is said to be the overriding method. The method overriding enables the child class to change the implementation of the method which aquired from parent class according to its requirement. Java Method Overriding \u00b6 The method overriding is also known as - dynamic method dispatch or - run time polymorphism or - pure polymorphism. Java Method Overriding Example \u00b6 1 2 3 4 5 6 7 8 9 class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } } Java Method Overriding Example \u00b6 1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } } Java Method Overriding Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class PurePolymorphism { public static void main ( String [] args ) { ParentClass obj = new ParentClass (); obj . showData (); obj = new ChildClass (); obj . showData (); } } Rules for method overriding \u00b6 While overriding a method, we must follow the below list of rules. Static methods can not be overridden. Final methods can not be overridden. Private methods can not be overridden. Constructor can not be overridden. An abstract method must be overridden. Use super keyword to invoke overridden method from child class. Rules for method overriding \u00b6 The return type of the overriding method must be same as the parent has it. The access specifier of the overriding method can be changed, but the visibility must increase but not decrease. For example, a protected method in the parent class can be made public, but not private, in the child class. Rules for method overriding \u00b6 If the overridden method does not throw an exception in the parent class, then the child class overriding method can only throw the unchecked exception, throwing a checked exception is not allowed. If the parent class overridden method does throw an exception, then the child class overriding method can only throw the same, or subclass exception, or it may not throw any exception. Method Overriding Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal { public void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { @Override public void displayInfo () { System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } } Method Overriding Example \u00b6 annotations are the metadata that we used to provide information to the compiler It is not mandatory to use @Override . However, when we use this, the method should follow all the rules of overriding. Otherwise, the compiler will generate an error. Method Overriding Example \u00b6 super Keyword in Java Overriding \u00b6 Can we access the method of the superclass after overriding? The answer is Yes. To access the method of the superclass from the subclass, we use the super keyword Use of super Keyword Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal { public void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { public void displayInfo () { super . displayInfo (); System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } } Use of super Keyword Example \u00b6 In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal. When we call the method displayInfo() using the d1 object of the Dog subclass, the method inside the Dog subclass is called; the method inside the superclass is not called Inside displayInfo() of the Dog subclass, we have used super.displayInfo() to call displayInfo() of the superclass. Use of super Keyword Example \u00b6 note that constructors in Java are not inherited. Hence, there is no such thing as constructor overriding in Java. However, we can call the constructor of the superclass from its subclasses. For that, we use super() Access Specifiers in Method Overriding \u00b6 The same method declared in the superclass and its subclasses can have different access specifiers. However, there is a restriction. We can only use those access specifiers in subclasses that provide larger access than the access specifier of the superclass. For example, Suppose, a method myClass() in the superclass is declared protected. Then, the same method myClass() in the subclass can be either public or protected, but not private. Access Specifier in Overriding Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Animal { protected void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { public void displayInfo () { System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } } Access Specifier in Overriding Example \u00b6 In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal. Whenever we call displayInfo() using the d1 (object of the subclass), the method inside the subclass is called. Notice that, the displayInfo() is declared protected in the Animal superclass. The same method has the public access specifier in the Dog subclass. This is possible because the public provides larger access than the protected. Overriding Abstract Methods \u00b6 In Java, abstract classes are created to be the superclass of other classes. And, if a class contains an abstract method, it is mandatory to override it. Java Nested and Inner Class \u00b6 Java Nested and Inner Class \u00b6 In Java, you can define a class within another class. Such class is known as nested class 1 2 3 4 5 6 class OuterClass { // ... class NestedClass { // ... } } Java Nested and Inner Class \u00b6 There are two types of nested classes you can create in Java. Non-static nested class (inner class) Static nested class Non-Static Nested Class (Inner Class) \u00b6 A non-static nested class is a class within another class. It has access to members of the enclosing class (outer class). It is commonly known as inner class. Since the inner class exists within the outer class, you must instantiate the outer class first, in order to instantiate the inner class. Non-Static Nested Class (Inner Class) Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class CPU { double price ; // nested class class Processor { // members of nested class double cores ; String manufacturer ; double getCache (){ return 4.3 ; } } // nested protected class protected class RAM { // members of protected nested class double memory ; String manufacturer ; double getClockSpeed (){ return 5.5 ; } } } Non-Static Nested Class (Inner Class) Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { // create object of Outer class CPU CPU cpu = new CPU (); // create an object of inner class Processor using outer class CPU . Processor processor = cpu . new Processor (); // create an object of inner class RAM using outer class CPU CPU . RAM ram = cpu . new RAM (); System . out . println ( \"Processor Cache = \" + processor . getCache ()); System . out . println ( \"Ram Clock speed = \" + ram . getClockSpeed ()); } } section{ font-size: 25px; } Non-Static Nested Class (Inner Class) Example \u00b6 In the example program, there are two nested classes: Processor and RAM inside the outer class: CPU. We can declare the inner class as protected. Hence, we have declared the RAM class as protected. Inside the Main class, we first created an instance of an outer class CPU named cpu. Using the instance of the outer class, we then created objects of inner classes 1 2 CPU . Processor processor = cpu . new Processor ; CPU . RAM ram = cpu . new RAM (); - We use the dot (.) operator to create an instance of the inner class using the outer class. Accessing Members of Outer Class within Inner Class \u00b6 We can access the members of the outer class by using this keyword Accessing Members of Outer Class within Inner Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car { String carName ; String carType ; // assign values using constructor public Car ( String name , String type ) { this . carName = name ; this . carType = type ; } // private method private String getCarName () { return this . carName ; } ... Accessing Members of Outer Class within Inner Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ... // inner class class Engine { String engineType ; void setEngine () { // Accessing the carType property of Car if ( Car . this . carType . equals ( \"4WD\" )){ // Invoking method getCarName() of Car if ( Car . this . getCarName (). equals ( \"Crysler\" )) { this . engineType = \"Smaller\" ; } else { this . engineType = \"Bigger\" ; } } else { this . engineType = \"Bigger\" ; } } String getEngineType (){ return this . engineType ; } } } Accessing Members of Outer Class within Inner Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main ( String [] args ) { // create an object of the outer class Car Car car1 = new Car ( \"Mazda\" , \"8WD\" ); // create an object of inner class using the outer class Car . Engine engine = car1 . new Engine (); engine . setEngine (); System . out . println ( \"Engine Type for 8WD= \" + engine . getEngineType ()); Car car2 = new Car ( \"Crysler\" , \"4WD\" ); Car . Engine c2engine = car2 . new Engine (); c2engine . setEngine (); System . out . println ( \"Engine Type for 4WD = \" + c2engine . getEngineType ()); } } section{ font-size: 30px; } Accessing Members of Outer Class within Inner Class Example \u00b6 In the example program, we have the inner class named Engine inside the outer class Car. Here, notice the line, 1 if ( Car . this . carType . equals ( \"4WD\" )) {...} We are using this keyword to access the carType variable of the outer class. You may have noticed that instead of using this.carType we have used Car.this.carType section{ font-size: 30px; } Accessing Members of Outer Class within Inner Class Example \u00b6 It is because if we had not mentioned the name of the outer class Car, then this keyword will represent the member inside the inner class. Similarly, we are also accessing the method of the outer class from the inner class. 1 if ( Car . this . getCarName (). equals ( \"Crysler\" ) {...} It is important to note that, although the getCarName() is a private method, we are able to access it from the inner class. section{ font-size: 25px; } Static Nested Class \u00b6 In Java, we can also define a static class inside another class. Such class is known as static nested class. Static nested classes are not called static inner classes. Unlike inner class, a static nested class cannot access the member variables of the outer class. It is because the static nested class doesn't require you to create an instance of the outer class. 1 OuterClass . NestedClass obj = new OuterClass . NestedClass (); Here, we are creating an object of the static nested class by simply using the class name of the outer class. Hence, the outer class cannot be referenced using OuterClass.this . section{ font-size: 25px; } Static Inner Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 class MotherBoard { // static nested class static class USB { int usb2 = 2 ; int usb3 = 1 ; int getTotalPorts (){ return usb2 + usb3 ; } } } 1 2 3 4 5 6 7 8 9 public class Main { public static void main ( String [] args ) { // create an object of the static nested class // using the name of the outer class MotherBoard . USB usb = new MotherBoard . USB (); System . out . println ( \"Total Ports = \" + usb . getTotalPorts ()); } } section{ font-size: 25px; } Static Inner Class Example \u00b6 In the above program, we have created a static class named USB inside the class MotherBoard. Notice the line, 1 MotherBoard . USB usb = new MotherBoard . USB (); Here, we are creating an object of USB using the name of the outer class. Now, let's see what would happen if you try to access the members of the outer class: Accessing members of Outer class inside Static Inner Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MotherBoard { String model ; public MotherBoard ( String model ) { this . model = model ; } // static nested class static class USB { int usb2 = 2 ; int usb3 = 1 ; int getTotalPorts (){ // accessing the variable model of the outer classs if ( MotherBoard . this . model . equals ( \"MSI\" )) { return 4 ; } else { return usb2 + usb3 ; } } } } Accessing members of Outer class inside Static Inner Class Example \u00b6 1 2 3 4 5 6 7 8 public class Main { public static void main ( String [] args ) { // create an object of the static nested class MotherBoard . USB usb = new MotherBoard . USB (); System . out . println ( \"Total Ports = \" + usb . getTotalPorts ()); } } Accessing members of Outer class inside Static Inner Class Example \u00b6 When we try to run the program, we will get an error: 1 error: non-static variable this cannot be referenced from a static context - This is because we are not using the object of the outer class to create an object of the inner class. - Hence, there is no reference to the outer class Motherboard stored in Motherboard.this . section{ font-size: 25px; } Key Points to Remember \u00b6 Java treats the inner class as a regular member of a class. They are just like methods and variables declared inside a class. Since inner classes are members of the outer class, you can apply any access modifiers like private, protected to your inner class which is not possible in normal classes. Since the nested class is a member of its enclosing outer class, you can use the dot (.) notation to access the nested class and its members. Using the nested class will make your code more readable and provide better encapsulation. Non-static nested classes (inner classes) have access to other members of the outer/enclosing class, even if they are declared private. Java Nested Static Class \u00b6 Java Nested Static Class \u00b6 we can have a class inside another class in Java. Such classes are known as nested classes. In Java, nested classes are of two types: Nested non-static class (Inner class) Nested static class. Java Nested Static Class \u00b6 We use the keyword static to make our nested class static. Note: In Java, only nested classes are allowed to be static. Like regular classes, static nested classes can include both static and non-static fields and methods. For example, 1 2 3 4 5 6 Class Animal { static class Mammal { // static and non-static members of Mammal } // members of Animal } - Static nested classes are associated with the outer class. - To access the static nested class, we don\u2019t need objects of the outer class. Static Nested Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Animal { // inner class class Reptile { public void displayInfo () { System . out . println ( \"I am a reptile.\" ); } } // static class static class Mammal { public void displayInfo () { System . out . println ( \"I am a mammal.\" ); } } } Static Nested Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { // object creation of the outer class Animal animal = new Animal (); // object creation of the non-static class Animal . Reptile reptile = animal . new Reptile (); reptile . displayInfo (); // object creation of the static nested class Animal . Mammal mammal = new Animal . Mammal (); mammal . displayInfo (); } } Static Nested Class Example \u00b6 In the example program, we have two nested class Mammal and Reptile inside a class Animal . To create an object of the non-static class Reptile, we have used 1 Animal . Reptile reptile = animal . new Reptile () To create an object of the static class Mammal, we have used 1 Animal . Mammal mammal = new Animal . Mammal () Accessing Members of Outer Class \u00b6 In Java, static nested classes are associated with the outer class. This is why static nested classes can only access the class members (static fields and methods) of the outer class. Accessing Non-static members Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { static class Mammal { public void displayInfo () { System . out . println ( \"I am a mammal.\" ); } } class Reptile { public void displayInfo () { System . out . println ( \"I am a reptile.\" ); } } public void eat () { System . out . println ( \"I eat food.\" ); } } Accessing Non-static members Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { Animal animal = new Animal (); Animal . Reptile reptile = animal . new Reptile (); reptile . displayInfo (); Animal . Mammal mammal = new Animal . Mammal (); mammal . displayInfo (); mammal . eat (); } } Accessing Non-static members Example \u00b6 In the example, we have created a non-static method eat() inside the class Animal. Now, if we try to access eat() using the object mammal , the compiler shows an error. It is because mammal is an object of a static class and we cannot access non-static methods from static classes. Static Top-level Class \u00b6 only nested classes can be static. We cannot have static top-level classes. Static Top-level Class \u00b6 if we try to make a top-level class static. 1 2 3 4 5 static class Animal { public static void displayInfo () { System . out . println ( \"I am an animal\" ); } } 1 2 3 4 5 class Main { public static void main ( String [] args ) { Animal . displayInfo (); } } Static Top-level Class \u00b6 Main.java:1: error: modifier static not allowed here static class Animal { ^ 1 error compiler exit status 1 In the example, we have tried to create a static class Animal. Since Java doesn\u2019t allow static top-level class, we will get an error. Java Anonymous Class \u00b6 Java Anonymous Class \u00b6 In Java, a class can contain another class known as nested class. It's possible to create a nested class without giving any name. A nested class that doesn't have any name is known as an anonymous class. An anonymous class must be defined inside another class. Hence, it is also known as an anonymous inner class. Its syntax is: 1 2 3 4 5 6 7 class outerClass { // defining anonymous class object1 = new Type ( parameterList ) { // body of the anonymous class }; } Java Anonymous Class \u00b6 Anonymous classes usually extend subclasses or implement interfaces. Here, Type can be a superclass that an anonymous class extends an interface that an anonymous class implements The above code creates an object, object1, of an anonymous class at runtime. Note : Anonymous classes are defined inside an expression. So, the semicolon is used at the end of anonymous classes to indicate the end of the expression. Anonymous Class Extending a Class Example \u00b6 1 2 3 4 5 class Polygon { public void display () { System . out . println ( \"Inside the Polygon class\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 class AnonymousDemo { public void createClass () { // creation of anonymous class extending class Polygon Polygon p1 = new Polygon () { public void display () { System . out . println ( \"Inside an anonymous class.\" ); } }; p1 . display (); } } Anonymous Class Extending a Class Example \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { AnonymousDemo an = new AnonymousDemo (); an . createClass (); } } Anonymous Class Extending a Class Example \u00b6 In the example, we have created a class Polygon . It has a single method display() . We then created an anonymous class that extends the class Polygon and overrides the display() method. When we run the program, an object p1 of the anonymous class is created. The object then calls the display() method of the anonymous class. Anonymous Class Implementing an Interface Example \u00b6 1 2 3 interface Polygon { public void display (); } 1 2 3 4 5 6 7 8 9 10 11 12 class AnonymousDemo { public void createClass () { // anonymous class implementing interface Polygon p1 = new Polygon () { public void display () { System . out . println ( \"Inside an anonymous class.\" ); } }; p1 . display (); } } Anonymous Class Implementing an Interface Example \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { AnonymousDemo an = new AnonymousDemo (); an . createClass (); } } In the example, we have created an anonymous class that implements the Polygon interface. Advantages of Anonymous Classes \u00b6 In anonymous classes, objects are created whenever they are required. That is, objects are created to perform some specific tasks. For example, 1 2 3 4 5 Object = new Example () { public void display () { System . out . println ( \"Anonymous class overrides the method display().\" ); } }; Here, an object of the anonymous class is created dynamically when we need to override the display() method. Anonymous classes also help us to make our code concise. Java enums \u00b6 Java enums \u00b6 In Java, an enum (short for enumeration) is a type that has a fixed set of constant values. We use the enum keyword to declare enums. For example, 1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } - Here, we have created an enum named Size. It contains fixed values SMALL , MEDIUM , LARGE , and EXTRALARGE . - These values inside the braces are called enum constants (values). - Note: The enum constants are usually represented in uppercase. Java Enum Example \u00b6 1 2 3 4 5 6 7 8 9 10 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } class Main { public static void main ( String [] args ) { System . out . println ( Size . SMALL ); System . out . println ( Size . MEDIUM ); } } Java Enum Example \u00b6 we use the enum name to access the constant values. Also, we can create variables of enum types. For example 1 Size pizzaSize ; Here, pizzaSize is a variable of the Size type. It can only be assigned with 4 values. 1 2 3 4 pizzaSize = Size . SMALL ; pizzaSize = Size . MEDIUM ; pizzaSize = Size . LARGE ; pizzaSize = Size . EXTRALARGE ; Java Enum with the switch statement example \u00b6 1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } Java Enum with the switch statement example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Test { Size pizzaSize ; public Test ( Size pizzaSize ) { this . pizzaSize = pizzaSize ; } public void orderPizza () { switch ( pizzaSize ) { case SMALL : System . out . println ( \"I ordered a small size pizza.\" ); break ; case MEDIUM : System . out . println ( \"I ordered a medium size pizza.\" ); break ; default : System . out . println ( \"I don't know which one to order.\" ); break ; } } } Java Enum with the switch statement example \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Test t1 = new Test ( Size . MEDIUM ); t1 . orderPizza (); } } Java Enum with the switch statement example \u00b6 In the example, we have created an enum type Size . - We then declared a variable pizzaSize of the Size type. Here, the variable pizzaSize can only be assigned with 4 values ( SMALL, MEDIUM, LARGE, EXTRALARGE ). Notice the statement, 1 Test t1 = new Test ( Size . MEDIUM ); It will call the Test() constructor inside the Test class. Now, the variable pizzaSize is assigned with the MEDIUM constant. Based on the value, one of the cases of the switch case statement is executed. Enum Class in Java \u00b6 In Java, enum types are considered to be a special type of class. It was introduced with the release of Java 5. An enum class can include methods and fields just like regular classes. 1 2 3 4 5 enum Size { constant1 , constant2 , \u2026 , constantN ; // methods and fields } When we create an enum class, the compiler will create instances (objects) of each enum constants. Also, all enum constant is always public static final by default. Java Enum Class Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE ; public String getSize () { // this will refer to the object SMALL switch ( this ) { case SMALL : return \"small\" ; case MEDIUM : return \"medium\" ; case LARGE : return \"large\" ; case EXTRALARGE : return \"extra large\" ; default : return null ; } } ... Java Enum Class Example \u00b6 1 2 3 4 5 6 7 8 ... public static void main ( String [] args ) { // call getSize() // using the object SMALL System . out . println ( \"The size of the pizza is \" + Size . SMALL . getSize ()); } } Java Enum Class Example \u00b6 In the example, we have created an enum class Size. It has four constants SMALL, MEDIUM, LARGE and EXTRALARGE. Since Size is an enum class, the compiler automatically creates instances for each enum constants. Here inside the main() method, we have used the instance SMALL to call the getSize() method. Note : Like regular classes, an enum class also may include constructors Methods of Java Enum Class \u00b6 There are some predefined methods in enum classes that are readily available for use. Methods of Java Enum Class \u00b6 Java Enum ordinal() \u00b6 The ordinal() method returns the position of an enum constant. For example, 1 2 ordinal ( SMALL ) // returns 0 Methods of Java Enum Class \u00b6 Enum compareTo() \u00b6 The compareTo() method compares the enum constants based on their ordinal value. For example, 1 2 Size . SMALL . compareTo ( Size . MEDIUM ) // returns ordinal(SMALL) - ordinal(MEDIUM) Methods of Java Enum Class \u00b6 Enum toString() \u00b6 The toString() method returns the string representation of the enum constants. For example, 1 2 SMALL . toString () // returns \"SMALL\" Methods of Java Enum Class \u00b6 Enum name() \u00b6 The name() method returns the defined name of an enum constant in string form. The returned value from the name() method is final. For example, 1 2 name ( SMALL ) // returns \"SMALL\" Methods of Java Enum Class \u00b6 Java Enum valueOf() \u00b6 The valueOf() method takes a string and returns an enum constant having the same string name. For example, 1 2 Size . valueOf ( \"SMALL\" ) // returns constant SMALL. Methods of Java Enum Class \u00b6 Enum values() \u00b6 The values() method returns an array of enum type containing all the enum constants. For example, 1 Size [] enumArray = Size . value (); Why Java Enums? \u00b6 In Java, enum was introduced to replace the use of int constants. Suppose we have used a collection of int constants. 1 2 3 4 5 6 class Size { public final static int SMALL = 1 ; public final static int MEDIUM = 2 ; public final static int LARGE = 3 ; public final static int EXTRALARGE = 4 ; } Here, the problem arises if we print the constants. It is because only the number is printed which might not be helpful. Why Java Enums? \u00b6 So, instead of using int constants, we can simply use enums. For example, 1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } This makes our code more intuitive. Why Java Enums? \u00b6 Also, enum provides compile-time type safety. If we declare a variable of the Size type. For example, 1 Size size ; Here, it is guaranteed that the variable will hold one of the four values. Now, If we try to pass values other than those four values, the compiler will generate an error. Java enum Constructor \u00b6 In Java, an enum class may include a constructor like a regular class. These enum constructors are either private - accessible within the class or package-private - accessible within the package enum Constructor Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enum Size { // enum constants calling the enum constructors SMALL ( \"The size is small.\" ), MEDIUM ( \"The size is medium.\" ), LARGE ( \"The size is large.\" ), EXTRALARGE ( \"The size is extra large.\" ); private final String pizzaSize ; // private enum constructor private Size ( String pizzaSize ) { this . pizzaSize = pizzaSize ; } public String getSize () { return pizzaSize ; } } enum Constructor Example \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Size size = Size . SMALL ; System . out . println ( size . getSize ()); } } enum Constructor Example \u00b6 In the example, we have created an enum Size. It includes a private enum constructor. The constructor takes a string value as a parameter and assigns value to the variable pizzaSize. Since the constructor is private, we cannot access it from outside the class. However, we can use enum constants to call the constructor. In the Main class, we assigned SMALL to an enum variable size. The constant SMALL then calls the constructor Size with string as an argument. Finally, we called getSize() using size. Java enum Strings \u00b6 Java enum Strings \u00b6 In Java, we can get the string representation of enum constants using the toString() method or the name() method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } class Main { public static void main ( String [] args ) { System . out . println ( \"string value of SMALL is \" + Size . SMALL . toString ()); System . out . println ( \"string value of MEDIUM is \" + Size . MEDIUM . name ()); } } - we have seen the default string representation of an enum constant is the name of the same constant. Change Default String Value of enums \u00b6 We can change the default string representation of enum constants by overriding the toString() method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum Size { SMALL { // overriding toString() for SMALL public String toString () { return \"The size is small.\" ; } }, MEDIUM { // overriding toString() for MEDIUM public String toString () { return \"The size is medium.\" ; } }; } ... Change Default String Value of enums \u00b6 1 2 3 4 5 6 ... class Main { public static void main ( String [] args ) { System . out . println ( Size . MEDIUM . toString ()); } } In the above program, we have created an enum Size. And we have overridden the toString() method for enum constants SMALL and MEDIUM . Note: We cannot override the name() method. It is because the name() method is final . Java Abstract Class \u00b6 Java Abstract Class \u00b6 An abstract class is a class that created using abstract keyword. In other words, a class prefixed with abstract keyword is known as an abstract class. In java, an abstract class may contain abstract methods (methods without implementation) and also non-abstract methods (methods with implementation). We use the following syntax to create an abstract class. 1 2 3 abstract class < ClassName > { ... } Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 9 import java.util.* ; abstract class Shape { int length , breadth , radius ; Scanner input = new Scanner ( System . in ); abstract void printArea (); } Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 9 class Rectangle extends Shape { void printArea () { System . out . println ( \"*** Finding the Area of Rectangle ***\" ); System . out . print ( \"Enter length and breadth: \" ); length = input . nextInt (); breadth = input . nextInt (); System . out . println ( \"The area of Rectangle is: \" + length * breadth ); } } Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 9 class Triangle extends Shape { void printArea () { System . out . println ( \"\\n*** Finding the Area of Triangle ***\" ); System . out . print ( \"Enter Base And Height: \" ); length = input . nextInt (); breadth = input . nextInt (); System . out . println ( \"The area of Triangle is: \" + ( length * breadth ) / 2 ); } } Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 class Cricle extends Shape { void printArea () { System . out . println ( \"\\n*** Finding the Area of Cricle ***\" ); System . out . print ( \"Enter Radius: \" ); radius = input . nextInt (); System . out . println ( \"The area of Cricle is: \" + 3.14f * radius * radius ); } } Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class AbstractClassExample { public static void main ( String [] args ) { Rectangle rec = new Rectangle (); rec . printArea (); Triangle tri = new Triangle (); tri . printArea (); Cricle cri = new Cricle (); cri . printArea (); } } Java Abstract Class Example-1 \u00b6 An abstract class can not be instantiated but can be referenced. That means we can not create an object of an abstract class, but base reference can be created. Java Abstract Class Example-1 \u00b6 In the example program, the child class objects are created to invoke the overridden abstract method. But we may also create base class reference and assign it with child class instance to invoke the same. The main method of the above program can be written as follows that produce the same output. Java Abstract Class Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 public static void main ( String [] args ) { Shape obj = new Rectangle (); //Base class reference to Child class instance obj . printArea (); obj = new Triangle (); obj . printArea (); obj = new Cricle (); obj . printArea (); } Java Abstract Class Example-2 \u00b6 1 2 3 4 5 6 7 abstract class Animal { abstract void makeSound (); public void eat () { System . out . println ( \"I can eat.\" ); } } Java Abstract Class Example-2 \u00b6 1 2 3 4 5 6 7 class Dog extends Animal { // provide implementation of abstract method public void makeSound () { System . out . println ( \"Bark bark\" ); } } Java Abstract Class Example-2 \u00b6 1 2 3 4 5 6 7 8 9 10 class Main { public static void main ( String [] args ) { // create an object of Dog class Dog d1 = new Dog (); d1 . makeSound (); d1 . eat (); } } Java Abstract Class Example-3 \u00b6 1 2 3 abstract class MotorBike { abstract void brake (); } Java Abstract Class Example-3 \u00b6 1 2 3 4 5 6 7 class SportsBike extends MotorBike { // implementation of abstract method public void brake () { System . out . println ( \"SportsBike Brake\" ); } } Java Abstract Class Example-3 \u00b6 1 2 3 4 5 6 7 class MountainBike extends MotorBike { // implementation of abstract method public void brake () { System . out . println ( \"MountainBike Brake\" ); } } Java Abstract Class Example-3 \u00b6 1 2 3 4 5 6 7 8 class Main { public static void main ( String [] args ) { MountainBike m1 = new MountainBike (); m1 . brake (); SportsBike s1 = new SportsBike (); s1 . brake (); } } Accesses Constructor of Abstract Classes \u00b6 An abstract class can have constructors like the regular class. And, we can access the constructor of an abstract class from the subclass using the super keyword. For example, 1 2 3 4 5 6 7 8 9 10 11 12 abstract class Animal { Animal () { \u2026 . } } class Dog extends Animal { Dog () { super (); ... } } Accesses Constructor of Abstract Classes \u00b6 Note that the super should always be the first statement of the subclass constructor Java Abstract Class \u00b6 Rules for method overriding \u00b6 An abstract class must follow the below list of rules. An abstract class must be created with abstract keyword. An abstract class can be created without any abstract method. An abstract class may contain abstract methods and non-abstract methods. An abstract class may contain final methods that can not be overridden. Java Abstract Class \u00b6 Rules for method overriding \u00b6 An abstract class may contain static methods, but the abstract method can not be static. An abstract class may have a constructor that gets executed when the child class object created. An abstract method must be overridden by the child class, otherwise, it must be defined as an abstract class. An abstract class can not be instantiated but can be referenced. Java Abstract Class Review \u00b6 Java Abstract Class Review \u00b6 The abstract class in Java cannot be instantiated (we cannot create objects of abstract classes). We use the abstract keyword to declare an abstract class. For example, 1 2 3 4 5 6 7 8 9 // create an abstract class abstract class Language { // fields and methods } ... // try to create an object Language // throws an error Language obj = new Language (); Java Abstract Class Review \u00b6 An abstract class can have both the regular methods and abstract methods. For example, 1 2 3 4 5 6 7 8 9 10 abstract class Language { // abstract method abstract void method1 (); // regular method void method2 () { System . out . println ( \"This is regular method\" ); } } section{ font-size: 25px; } Java Abstract Method Review \u00b6 A method that doesn't have its body is known as an abstract method. We use the same abstract keyword to create abstract methods. For example, 1 abstract void display (); Here, display() is an abstract method. The body of display() is replaced by ;. If a class contains an abstract method, then the class should be declared abstract. Otherwise, it will generate an error. For example, 1 2 3 4 5 6 7 // error // class should be abstract class Language { // abstract method abstract void method1 (); } Java Abstract Class and Method Example \u00b6 Though abstract classes cannot be instantiated, we can create subclasses from it. We can then access members of the abstract class using the object of the subclass. Java Abstract Class and Method Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 abstract class Language { // method of abstract class public void display () { System . out . println ( \"This is Java Programming\" ); } } class Main extends Language { public static void main ( String [] args ) { // create an object of Main Main obj = new Main (); // access method of abstract class // using object of Main class obj . display (); } } Java Abstract Class and Method Example \u00b6 In the example, we have created an abstract class named Language. The class contains a regular method display(). We have created the Main class that inherits the abstract class. Notice the statement, 1 obj . display (); Here, obj is the object of the child class Main. We are calling the method of the abstract class using the object obj. section{ font-size: 25px; } Java Abstract Method Review Keypoints \u00b6 We use the abstract keyword to create abstract classes and methods. An abstract method doesn't have any implementation (method body). A class containing abstract methods should also be abstract. We cannot create objects of an abstract class. To implement features of an abstract class, we inherit subclasses from it and create objects of the subclass. A subclass must override all abstract methods of an abstract class. However, if the subclass is declared abstract, it's not mandatory to override abstract methods. We can access the static attributes and methods of an abstract class using the reference of the abstract class. For example, 1 Animal . staticMethod (); Java Object Class \u00b6 Java Object Class \u00b6 In java, the Object class is the super most class of any class hierarchy. The Object class in the java programming language is present inside the java.lang package. Every class in the java programming language is a subclass of Object class by default. The Object class is useful when you want to refer to any object whose type you don't know. Because it is the superclass of all other classes in java, it can refer to any type of object. Methods of Object class \u00b6 object getClass() Returns Class class object int hashCode() returns the hashcode number for object being used. boolean equals(Object obj) compares the argument object to calling object. int clone() Compares two strings, ignoring case Methods of Object class \u00b6 object concat(String) Creates copy of invoking object String toString() Returns the string representation of invoking object. void notify() Wakes up a thread, waiting on invoking object's monitor. void notifyAll() wakes up all the threads, waiting on invoking object's - monitor. Methods of Object class \u00b6 void wait() causes the current thread to wait, until another thread - notifies void wait(long,int) causes the current thread to wait for the specified - milliseconds and nanoseconds, until another thread notifies. void finalize() It is invoked by the garbage collector before an object is being garbage collected. Java Forms of Inheritance \u00b6 The inheritance concept used for the number of purposes in the java programming language. One of the main purposes is substitutability. The substitutability means that when a child class acquires properties from its parent class, the object of the parent class may be substituted with the child class object. For example, if B is a child class of A, anywhere we expect an instance of A we can use an instance of B. The substitutability can achieve using inheritance, whether using extends or implements keywords. Java Forms of Inheritance \u00b6 The following are the differnt forms of inheritance in java. Specialization Specification Construction Extension Limitation Combination Java Forms of Inheritance \u00b6 Specialization \u00b6 It is the most ideal form of inheritance. The subclass is a special case of the parent class. It holds the principle of substitutability. Java Forms of Inheritance \u00b6 Specification \u00b6 This is another commonly used form of inheritance. In this form of inheritance, the parent class just specifies which methods should be available to the child class but doesn't implement them. The java provides concepts like abstract and interfaces to support this form of inheritance. It holds the principle of substitutability. Java Forms of Inheritance \u00b6 Construction \u00b6 This is another form of inheritance where the child class may change the behavior defined by the parent class (overriding). It does not hold the principle of substitutability. Java Forms of Inheritance \u00b6 Extension \u00b6 This is another form of inheritance where the child class may add its new properties. It holds the principle of substitutability. Java Forms of Inheritance \u00b6 Limitation \u00b6 This is another form of inheritance where the subclass restricts the inherited behavior. It does not hold the principle of substitutability. Java Forms of Inheritance \u00b6 Combination \u00b6 This is another form of inheritance where the subclass inherits properties from multiple parent classes. Java does not support multiple inheritance type. Benefits and Costs of Inheritance in java \u00b6 Inheritance is the core and more useful concept of Object-Oriented Programming. It proWith inheritance, we will be able to override the methods of the base class so that the meaningful implementation of the base class method can be designed in the derived class. An inheritance leads to less development and maintenance costs. Vides many benefits, and a few of them are listed below. Benefits of Inheritance \u00b6 Inheritance helps in code reuse. The child class may use the code defined in the parent class without re-writing it. Inheritance can save time and effort as the main code need not be written again. Inheritance provides a clear model structure which is easy to understand. An inheritance leads to less development and maintenance costs. With inheritance, we will be able to override the methods of the base class so that the meaningful implementation of the base class method can be designed in the derived class. An inheritance leads to less development and maintenance costs. In inheritance base class can decide to keep some data private so that it cannot be altered by the derived class. Costs of Inheritance \u00b6 Inheritance decreases the execution speed due to the increased time and effort it takes, the program to jump through all the levels of overloaded classes. Inheritance makes the two classes (base and inherited class) get tightly coupled. This means one cannot be used independently of each other. The changes made in the parent class will affect the behavior of child class too. The overuse of inheritance makes the program more complex. Defining Packages in java \u00b6 Defining Packages in java \u00b6 In java, a package is a container of classes, interfaces, and sub-packages. We may think of it as a folder in a file directory. We use the packages to avoid naming conflicts and to organize project-related classes, interfaces, and sub-packages into a bundle. Defining Packages in java \u00b6 In java, the packages have divided into two types. Built-in Packages User-defined Packages Built-in Packages \u00b6 The built-in packages are the packages from java API. The Java API is a library of pre-defined classes, interfaces, and sub-packages. The built-in packages were included in the JDK. There are many built-in packages in java, few of them are as java, lang, io, util, awt, javax, swing, net, sql , etc. We need to import the built-in packages to use them in our program. To import a package, we use the import statement. User-defined Packages \u00b6 The user-defined packages are the packages created by the user. User is free to create their own packages. Definig a Package in java \u00b6 We use the package keyword to create or define a package in java programming language. 1 package packageName ; Definig a Package in java \u00b6 The package statement must be the first statement in the program. The package name must be a single word. The package name must use Camel case notation. Definig a Package in java \u00b6 create a user-defined package myPackage 1 2 3 4 5 6 7 8 9 10 11 package myPackage ; public class DefiningPackage { public static void main ( String [] args ) { System . out . println ( \"This class belongs to myPackage.\" ); } } Definig a Package in java \u00b6 Now, save the example code in a file DefiningPackage.java , and compile it using the following command. javac -d . DefiningPackage.java The above command creates a directory with the package name myPackage, and the DefiningPackage.class is saved into it. Run the program use the following command. java myPackage.DefiningPackage When we use IDE like Eclipse, Netbeans, etc. the package structure is created automatically. Access protection in java packages \u00b6 In java, the access modifiers define the accessibility of the class and its members. For example, private members are accessible within the same class members only. Java has four access modifiers, and they are default, private, protected, and public. In java, the package is a container of classes, sub-classes, interfaces, and sub-packages. The class acts as a container of data and methods. So, the access modifier decides the accessibility of class members across the different packages. In java, the accessibility of the members of a class or interface depends on its access specifiers. Access protection in java packages \u00b6 Access protection in java packages \u00b6 The public members can be accessed everywhere. The private members can be accessed only inside the same class. The protected members are accessible to every child class (same package or other packages). The default members are accessible within the same package but not outside the package. Access protection in java packages example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int a = 10 ; public int b = 20 ; protected int c = 30 ; private int d = 40 ; void showData () { System . out . println ( \"Inside ParentClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); System . out . println ( \"d = \" + d ); } } Access protection in java packages example \u00b6 1 2 3 4 5 6 7 8 9 10 11 class ChildClass extends ParentClass { void accessData () { System . out . println ( \"Inside ChildClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); //System.out.println(\"d = \" + d); // private member can't be accessed } } Access protection in java packages example \u00b6 1 2 3 4 5 6 7 8 9 public class AccessModifiersExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); obj . accessData (); } } Importing Packages in java \u00b6 In java, the import keyword used to import built-in and user-defined packages. When a package has imported, we can refer to all the classes of that package using their name directly. The import statement must be after the package statement, and before any other statement. Using an import statement, we may import a specific class or all the classes from a package. Importing Packages in java \u00b6 Using one import statement, we may import only one package or a class. Using an import statement, we can not import a class directly, but it must be a part of a package. A program may contain any number of import statements. Importing specific class \u00b6 1 import packageName.ClassName ; Importing specific class \u00b6 import a built-in package and Scanner class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package myPackage ; import java.util.Scanner ; public class ImportingExample { public static void main ( String [] args ) { Scanner read = new Scanner ( System . in ); int i = read . nextInt (); System . out . println ( \"You have entered a number \" + i ); } } Importing all the classes \u00b6 Using an importing statement, we can import all the classes of a package. To import all the classes of the package, we use * symbol. The following syntax is employed to import all the classes of a package. 1 import packageName.* ; Importing all the classes \u00b6 import a built-in package. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package myPackage ; import java.util.* ; public class ImportingExample { public static void main ( String [] args ) { Scanner read = new Scanner ( System . in ); int i = read . nextInt (); System . out . println ( \"You have entered a number \" + i ); Random rand = new Random (); int num = rand . nextInt ( 100 ); System . out . println ( \"Randomly generated number \" + num ); } } Importing all the classes \u00b6 The import statement imports only classes of the package, but not sub-packages and its classes. We may also import sub-packages by using a symbol '.' (dot) to separate parent package and sub-package. References \u00b6 BtechSmartClass-super Keyword Programiz-super Keyword BtechSmartClass-Java final Keyword Programiz-final Keyword BtechSmartClass-java Polymorphism Programiz-Polymorphism Programiz-Encapsulation BtechSmartClass-Java Method Overriding References \u00b6 Programiz-Method Overriding Programiz-Nested Inner Class Programiz-Static Class Programiz-Anonymous Class Programiz-enums Programiz-enum constructor Programiz-enum string BtechSmartClass-Java Abstract Class Programiz-Abstract Classes Methods References \u00b6 BtechSmartClass-Java Object class BtechSmartClass-Java Forms of Inheritance Programiz-Interfaces BtechSmartClass-Java Benefits and Costs of Inheritance BtechSmartClass-Java Defining Packages BtechSmartClass-Java Access Protection in Packages BtechSmartClass-Java Importing Packages \\(End-Of-Week-2-Module\\)","title":"Week-2 (OOP with Java -II)"},{"location":"week-2/ce204-week-2/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-2/ce204-week-2/#week-2-oop-with-java-ii","text":"","title":"Week-2 (OOP with Java-II)"},{"location":"week-2/ce204-week-2/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-2/ce204-week-2/#oop-with-java-ii","text":"","title":"OOP with Java-II"},{"location":"week-2/ce204-week-2/#outline-1","text":"Java super Keyword Java final Keyword Java Polymorphism / Encapsulation Java Method Overriding Java Nested Inner Class Java Static Class Java Anonymous Class","title":"Outline (1)"},{"location":"week-2/ce204-week-2/#outline-2","text":"Java Enums / Enum-Constructor / Enum-String Java Abstract Class Java Object Class Java Forms of Inheritance Java Benefits and Costs of Inheritance Java Packages Java Access Protection in Packages","title":"Outline (2)"},{"location":"week-2/ce204-week-2/#java-super-keyword","text":"","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#java-super-keyword_1","text":"In java, super is a keyword used to refers to the parent class object . The super keyword came into existence to solve the naming conflicts in the inheritance. When both parent class and child class have members with the same name, then the super keyword is used to refer to the parent class version.","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#java-super-keyword_2","text":"In another word, The super keyword in Java is used in subclasses to access superclass members (attributes, constructors and methods).","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#java-super-keyword_3","text":"In java, the super keyword is used for the following purposes. To refer parent class data members To refer parent class methods To call parent class constructor","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#java-super-keyword_4","text":"To call methods of the superclass that is overridden in the subclass. To access attributes (fields) of the superclass if both superclass and subclass have attributes with the same name. To explicitly call superclass no-arg (default) or parameterized constructor from the subclass constructor.","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#java-super-keyword_5","text":"The super keyword is used inside the child class only.","title":"Java super keyword"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-data-members","text":"When both parent class and child class have data members with the same name, then the super keyword is used to refer to the parent class data member from child class.","title":"super to refer parent class data members"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-data-members_1","text":"1 2 3 4 5 class ParentClass { int num = 10 ; } 1 2 3 4 5 6 7 8 9 10 class ChildClass extends ParentClass { int num = 20 ; void showData () { System . out . println ( \"Inside the ChildClass\" ); System . out . println ( \"ChildClass num = \" + num ); System . out . println ( \"ParentClass num = \" + super . num ); } }","title":"super to refer parent class data members"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-data-members_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); System . out . println ( \"\\nInside the non-child class\" ); System . out . println ( \"ChildClass num = \" + obj . num ); //System.out.println(\"ParentClass num = \" + super.num); //super can't be used here } }","title":"super to refer parent class data members"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-method","text":"When both parent class and child class have method with the same name, then the super keyword is used to refer to the parent class method from child class.","title":"super to refer parent class method"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-method_1","text":"class ParentClass { int num1 = 10 ; void showData () { System . out . println ( \"\\nInside the ParentClass showData method\" ); System . out . println ( \"ChildClass num = \" + num1 ); } }","title":"super to refer parent class method"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-method_2","text":"class ChildClass extends ParentClass { int num2 = 20 ; void showData () { System . out . println ( \"\\nInside the ChildClass showData method\" ); System . out . println ( \"ChildClass num = \" + num2 ); super . showData (); } }","title":"super to refer parent class method"},{"location":"week-2/ce204-week-2/#super-to-refer-parent-class-method_3","text":"public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); //super.showData(); // super can't be used here } }","title":"super to refer parent class method"},{"location":"week-2/ce204-week-2/#super-to-call-parent-class-constructor","text":"When an object of child class is created, it automatically calls the parent class default-constructor before it's own. But, the parameterized constructor of parent class must be called explicitly using the super keyword inside the child class constructor.","title":"super to call parent class constructor"},{"location":"week-2/ce204-week-2/#super-to-call-parent-class-constructor_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int num1 ; ParentClass (){ System . out . println ( \"\\nInside the ParentClass default constructor\" ); num1 = 10 ; } ParentClass ( int value ){ System . out . println ( \"\\nInside the ParentClass parameterized constructor\" ); num1 = value ; } }","title":"super to call parent class constructor"},{"location":"week-2/ce204-week-2/#super-to-call-parent-class-constructor_2","text":"1 2 3 4 5 6 7 8 9 10 class ChildClass extends ParentClass { int num2 ; ChildClass (){ super ( 100 ); System . out . println ( \"\\nInside the ChildClass constructor\" ); num2 = 200 ; } }","title":"super to call parent class constructor"},{"location":"week-2/ce204-week-2/#super-to-call-parent-class-constructor_3","text":"1 2 3 4 5 6 7 8 public class SuperKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } }","title":"super to call parent class constructor"},{"location":"week-2/ce204-week-2/#super-to-call-parent-class-constructor_4","text":"To call the parameterized constructor of the parent class, the super keyword must be the first statement inside the child class constructor, and we must pass the parameter values.","title":"super to call parent class constructor"},{"location":"week-2/ce204-week-2/#access-overridden-methods-of-the-superclass","text":"If methods with the same name are defined in both superclass and subclass, the method in the subclass overrides the method in the superclass. This is called method overriding.","title":"Access Overridden Methods of the superclass"},{"location":"week-2/ce204-week-2/#example-1-method-overriding","text":"1 2 3 4 5 6 7 class Animal { // overridden method public void display (){ System . out . println ( \"I am an animal\" ); } }","title":"Example 1: Method overriding"},{"location":"week-2/ce204-week-2/#example-1-method-overriding_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Dog extends Animal { // overriding method @Override public void display (){ System . out . println ( \"I am a dog\" ); } public void printMessage (){ display (); } }","title":"Example 1: Method overriding"},{"location":"week-2/ce204-week-2/#example-1-method-overriding_2","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printMessage (); } }","title":"Example 1: Method overriding"},{"location":"week-2/ce204-week-2/#example-1-method-overriding_3","text":"In this example, by making an object dog1 of Dog class, we can call its method printMessage() which then executes the display() statement. Since display() is defined in both the classes, the method of subclass Dog overrides the method of superclass Animal. Hence, the display() of the subclass is called.","title":"Example 1: Method overriding"},{"location":"week-2/ce204-week-2/#example-1-method-overriding_4","text":"","title":"Example 1: Method overriding"},{"location":"week-2/ce204-week-2/#what-if-the-overridden-method-of-the-superclass-has-to-be-called","text":"We use super.display() if the overridden method display() of superclass Animal needs to be called.","title":"What if the overridden method of the superclass has to be called?"},{"location":"week-2/ce204-week-2/#example-2-super-to-call-superclass-method","text":"1 2 3 4 5 6 7 class Animal { // overridden method public void display (){ System . out . println ( \"I am an animal\" ); } }","title":"Example 2: super to Call Superclass Method"},{"location":"week-2/ce204-week-2/#example-2-super-to-call-superclass-method_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Dog extends Animal { // overriding method @Override public void display (){ System . out . println ( \"I am a dog\" ); } public void printMessage (){ // this calls overriding method display (); // this calls overridden method super . display (); } }","title":"Example 2: super to Call Superclass Method"},{"location":"week-2/ce204-week-2/#example-2-super-to-call-superclass-method_2","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printMessage (); } }","title":"Example 2: super to Call Superclass Method"},{"location":"week-2/ce204-week-2/#example-2-super-to-call-superclass-method_3","text":"","title":"Example 2: super to Call Superclass Method"},{"location":"week-2/ce204-week-2/#access-attributes-of-the-superclass","text":"The superclass and subclass can have attributes with the same name. We use the super keyword to access the attribute of the superclass.","title":"Access Attributes of the Superclass"},{"location":"week-2/ce204-week-2/#example-3-access-superclass-attribute","text":"1 2 3 class Animal { protected String type = \"animal\" ; } 1 2 3 4 5 6 7 8 class Dog extends Animal { public String type = \"mammal\" ; public void printType () { System . out . println ( \"I am a \" + type ); System . out . println ( \"I am an \" + super . type ); } }","title":"Example 3: Access superclass attribute"},{"location":"week-2/ce204-week-2/#example-3-access-superclass-attribute_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); dog1 . printType (); } }","title":"Example 3: Access superclass attribute"},{"location":"week-2/ce204-week-2/#example-3-access-superclass-attribute_2","text":"In this example, we have defined the same instance field type in both the superclass Animal and the subclass Dog . We then created an object dog1 of the Dog class. Then, the printType() method is called using this object. Inside the printType() function, type refers to the attribute of the subclass Dog . super.type refers to the attribute of the superclass Animal.","title":"Example 3: Access superclass attribute"},{"location":"week-2/ce204-week-2/#use-of-super-to-access-superclass-constructor","text":"As we know, when an object of a class is created, its default constructor is automatically called. To explicitly call the superclass constructor from the subclass constructor, we use super() . It's a special form of the super keyword. super() can be used only inside the subclass constructor and must be the first statement.","title":"Use of super() to access superclass constructor"},{"location":"week-2/ce204-week-2/#example-4-use-of-super","text":"1 2 3 4 5 6 7 class Animal { // default or no-arg constructor of class Animal Animal () { System . out . println ( \"I am an animal\" ); } }","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-4-use-of-super_1","text":"1 2 3 4 5 6 7 8 9 10 11 class Dog extends Animal { // default or no-arg constructor of class Dog Dog () { // calling default constructor of the superclass super (); System . out . println ( \"I am a dog\" ); } }","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-4-use-of-super_2","text":"1 2 3 4 5 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); } }","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-4-use-of-super_3","text":"when an object dog1 of Dog class is created, it automatically calls the default or no-arg constructor of that class. Inside the subclass constructor, the super() statement calls the constructor of the superclass and executes the statements inside it. Hence, we get the output I am an animal.","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-4-use-of-super_4","text":"The flow of the program then returns back to the subclass constructor and executes the remaining statements. Thus, I am a dog will be printed. However, using super() is not compulsory. Even if super() is not used in the subclass constructor, the compiler implicitly calls the default constructor of the superclass.","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-4-use-of-super_5","text":"So, why use redundant code if the compiler automatically invokes super()? It is required if the parameterized constructor (a constructor that takes arguments) of the superclass has to be called from the subclass constructor. The parameterized super() must always be the first statement in the body of the constructor of the subclass, otherwise, we get a compilation error.","title":"Example 4: Use of super()"},{"location":"week-2/ce204-week-2/#example-5-call-parameterized-constructor-using-super","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Animal { // default or no-arg constructor Animal () { System . out . println ( \"I am an animal\" ); } // parameterized constructor Animal ( String type ) { System . out . println ( \"Type: \" + type ); } }","title":"Example 5: Call Parameterized Constructor Using super()"},{"location":"week-2/ce204-week-2/#example-5-call-parameterized-constructor-using-super_1","text":"1 2 3 4 5 6 7 8 9 10 11 class Dog extends Animal { // default constructor Dog () { // calling parameterized constructor of the superclass super ( \"Animal\" ); System . out . println ( \"I am a dog\" ); } }","title":"Example 5: Call Parameterized Constructor Using super()"},{"location":"week-2/ce204-week-2/#example-5-call-parameterized-constructor-using-super_2","text":"1 2 3 4 5 class Main { public static void main ( String [] args ) { Dog dog1 = new Dog (); } }","title":"Example 5: Call Parameterized Constructor Using super()"},{"location":"week-2/ce204-week-2/#example-5-call-parameterized-constructor-using-super_3","text":"If a parameterized constructor has to be called, we need to explicitly define it in the subclass constructor.","title":"Example 5: Call Parameterized Constructor Using super()"},{"location":"week-2/ce204-week-2/#example-5-call-parameterized-constructor-using-super_4","text":"Note that in the above example, we explicitly called the parameterized constructor super(\"Animal\"). The compiler does not call the default constructor of the superclass in this case.","title":"Example 5: Call Parameterized Constructor Using super()"},{"location":"week-2/ce204-week-2/#java-final-keyword","text":"","title":"Java final keyword"},{"location":"week-2/ce204-week-2/#java-final-keyword_1","text":"In java, the final is a keyword and it is used with the following things. With variable (to create constant) With method (to avoid method overriding) With class (to avoid inheritance)","title":"Java final keyword"},{"location":"week-2/ce204-week-2/#java-final-restrictions","text":"the final variable cannot be reinitialized with another value the final method cannot be overridden the final class cannot be extended","title":"Java final restrictions"},{"location":"week-2/ce204-week-2/#final-with-variables","text":"When a variable defined with the final keyword, it becomes a constant, and it does not allow us to modify the value. The variable defined with the final keyword allows only a one-time assignment, once a value assigned to it, never allows us to change it again.","title":"final with variables"},{"location":"week-2/ce204-week-2/#final-with-variables-example-1","text":"1 2 3 4 5 6 7 public class FinalVariableExample { public static void main ( String [] args ) { final int a = 10 ; System . out . println ( \"a = \" + a ); a = 100 ; // Can't be modified } }","title":"final with variables example-1"},{"location":"week-2/ce204-week-2/#final-with-variables-example-2","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { // create a final variable final int AGE = 32 ; // try to change the final variable AGE = 45 ; System . out . println ( \"Age: \" + AGE ); } }","title":"final with variables example-2"},{"location":"week-2/ce204-week-2/#final-with-variables-recommendation","text":"It is recommended to use uppercase to declare final variables in Java.","title":"final with variables recommendation"},{"location":"week-2/ce204-week-2/#final-with-methods","text":"When a method defined with the final keyword, it does not allow it to override. The final method extends to the child class, but the child class can not override or re-define it. It must be used as it has implemented in the parent class.","title":"final with methods"},{"location":"week-2/ce204-week-2/#final-with-methods-example-1","text":"1 2 3 4 5 6 7 8 9 10 class ParentClass { int num = 10 ; final void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"final with methods example-1"},{"location":"week-2/ce204-week-2/#final-with-methods-example-1_1","text":"1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"final with methods example-1"},{"location":"week-2/ce204-week-2/#final-with-methods-example-1_2","text":"1 2 3 4 5 6 7 8 9 public class FinalKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); } }","title":"final with methods example-1"},{"location":"week-2/ce204-week-2/#final-with-methods-example-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FinalDemo { // create a final method public final void display () { System . out . println ( \"This is a final method.\" ); } } class Main extends FinalDemo { // try to override final method public final void display () { System . out . println ( \"The final method is overridden.\" ); } public static void main ( String [] args ) { Main obj = new Main (); obj . display (); } }","title":"final with methods example-2"},{"location":"week-2/ce204-week-2/#final-with-class","text":"When a class defined with final keyword, it can not be extended by any other class.","title":"final with class"},{"location":"week-2/ce204-week-2/#final-with-class-example-1","text":"1 2 3 4 5 6 7 8 9 10 final class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"final with class example-1"},{"location":"week-2/ce204-week-2/#final-with-class-example-1_1","text":"1 2 3 4 class ChildClass extends ParentClass { }","title":"final with class example-1"},{"location":"week-2/ce204-week-2/#final-with-class-example-1_2","text":"1 2 3 4 5 6 7 8 public class FinalKeywordExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); } }","title":"final with class example-1"},{"location":"week-2/ce204-week-2/#final-with-class-example-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // create a final class final class FinalClass { public void display () { System . out . println ( \"This is a final method.\" ); } } // try to extend the final class class Main extends FinalClass { public void display () { System . out . println ( \"The final method is overridden.\" ); } public static void main ( String [] args ) { Main obj = new Main (); obj . display (); } }","title":"final with class example-2"},{"location":"week-2/ce204-week-2/#java-polymorphism","text":"","title":"Java Polymorphism"},{"location":"week-2/ce204-week-2/#java-polymorphism_1","text":"The polymorphism is the process of defining same method with different implementation. That means creating multiple methods with different behaviors. In java, polymorphism implemented using method overloading and method overriding.","title":"Java Polymorphism"},{"location":"week-2/ce204-week-2/#ad-hoc-polymorphism","text":"The ad hoc polymorphism is a technique used to define the same method with different implementations and different arguments. In a java programming language, ad hoc polymorphism carried out with a method overloading concept.","title":"Ad hoc polymorphism"},{"location":"week-2/ce204-week-2/#ad-hoc-polymorphism_1","text":"In ad hoc polymorphism the method binding happens at the time of compilation. Ad hoc polymorphism is also known as compile-time polymorphism. Every function call binded with the respective overloaded method based on the arguments.","title":"Ad hoc polymorphism"},{"location":"week-2/ce204-week-2/#ad-hoc-polymorphism_2","text":"The ad hoc polymorphism implemented within the class only.","title":"Ad hoc polymorphism"},{"location":"week-2/ce204-week-2/#ad-hoc-polymorphism-example-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.Arrays ; public class AdHocPolymorphismExample { void sorting ( int [] list ) { Arrays . parallelSort ( list ); System . out . println ( \"Integers after sort: \" + Arrays . toString ( list ) ); } void sorting ( String [] names ) { Arrays . parallelSort ( names ); System . out . println ( \"Names after sort: \" + Arrays . toString ( names ) ); } ...","title":"Ad hoc polymorphism example-1"},{"location":"week-2/ce204-week-2/#ad-hoc-polymorphism-example-1_1","text":"1 2 3 4 5 6 7 8 9 10 11 ... public static void main ( String [] args ) { AdHocPolymorphismExample obj = new AdHocPolymorphismExample (); int list [] = { 2 , 3 , 1 , 5 , 4 }; obj . sorting ( list ); // Calling with integer array String [] names = { \"rama\" , \"raja\" , \"shyam\" , \"seeta\" }; obj . sorting ( names ); // Calling with String array } }","title":"Ad hoc polymorphism example-1"},{"location":"week-2/ce204-week-2/#pure-polymorphism","text":"The pure polymorphism is a technique used to define the same method with the same arguments but different implementations. In a java programming language, pure polymorphism carried out with a method overriding concept.","title":"Pure polymorphism"},{"location":"week-2/ce204-week-2/#pure-polymorphism_1","text":"In pure polymorphism, the method binding happens at run time. Pure polymorphism is also known as run-time polymorphism. Every function call binding with the respective overridden method based on the object reference. When a child class has a definition for a member function of the parent class, the parent class function is said to be overridden.","title":"Pure polymorphism"},{"location":"week-2/ce204-week-2/#pure-polymorphism_2","text":"The pure polymorphism implemented in the inheritance concept only.","title":"Pure polymorphism"},{"location":"week-2/ce204-week-2/#pure-polymorphism-example-1","text":"1 2 3 4 5 6 7 8 9 10 class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"Pure polymorphism example-1"},{"location":"week-2/ce204-week-2/#pure-polymorphism-example-1_1","text":"1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"Pure polymorphism example-1"},{"location":"week-2/ce204-week-2/#pure-polymorphism-example-1_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class PurePolymorphism { public static void main ( String [] args ) { ParentClass obj = new ParentClass (); obj . showData (); obj = new ChildClass (); obj . showData (); } }","title":"Pure polymorphism example-1"},{"location":"week-2/ce204-week-2/#java-method-overriding","text":"During inheritance in Java, if the same method is present in both the superclass and the subclass. Then, the method in the subclass overrides the same method in the superclass. This is called method overriding.","title":"Java Method Overriding"},{"location":"week-2/ce204-week-2/#polymorphism-using-method-overriding-example-2","text":"","title":"Polymorphism using method overriding example-2"},{"location":"week-2/ce204-week-2/#1-2-3-4-5-6-7-8-9-10-11-12class-language-public-void-displayinfo-systemoutprintlncommon-english-language-class-java-extends-language-override-public-void-displayinfo-systemoutprintlnjava-programming-language","text":"","title":" 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12class Language {\n  public void displayInfo() {\n    System.out.println(&quot;Common English Language&quot;);\n  }\n}\n\nclass Java extends Language {\n  @Override\n  public void displayInfo() {\n    System.out.println(&quot;Java Programming Language&quot;);\n  }\n}\n\n"},{"location":"week-2/ce204-week-2/#polymorphism-using-method-overriding-example-2_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { // create an object of Java class Java j1 = new Java (); j1 . displayInfo (); // create an object of Language class Language l1 = new Language (); l1 . displayInfo (); } }","title":"Polymorphism using method overriding example-2"},{"location":"week-2/ce204-week-2/#polymorphism-using-method-overriding-example-2_2","text":"","title":"Polymorphism using method overriding example-2"},{"location":"week-2/ce204-week-2/#java-method-overloading","text":"In a Java class, we can create methods with the same name if they differ in parameters. For example 1 2 3 4 void func () { ... } void func ( int a ) { ... } float func ( double a ) { ... } float func ( int a , float b ) { ... } This is known as method overloading in Java. Here, the same method will perform different operations based on the parameter.","title":"Java Method Overloading"},{"location":"week-2/ce204-week-2/#polymorphism-using-method-overloading-example-3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Pattern { // method without parameter public void display () { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( \"*\" ); } } // method with single parameter public void display ( char symbol ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( symbol ); } } }","title":"Polymorphism using method overloading example-3"},{"location":"week-2/ce204-week-2/#polymorphism-using-method-overloading-example-3_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Main { public static void main ( String [] args ) { Pattern d1 = new Pattern (); // call method without any argument d1 . display (); System . out . println ( \"\\n\" ); // call method with a single argument d1 . display ( '#' ); } }","title":"Polymorphism using method overloading example-3"},{"location":"week-2/ce204-week-2/#polymorphic-variables","text":"A variable is called polymorphic if it refers to different values under different conditions. Object variables (instance variables) represent the behavior of polymorphic variables in Java. It is because object variables of a class can refer to objects of its class as well as objects of its subclasses.","title":"Polymorphic Variables"},{"location":"week-2/ce204-week-2/#polymorphic-variables-example-1","text":"1 2 3 4 5 class ProgrammingLanguage { public void display () { System . out . println ( \"I am Programming Language.\" ); } }","title":"Polymorphic Variables Example-1"},{"location":"week-2/ce204-week-2/#polymorphic-variables-example-1_1","text":"1 2 3 4 5 6 class Java extends ProgrammingLanguage { @Override public void display () { System . out . println ( \"I am Object-Oriented Programming Language.\" ); } }","title":"Polymorphic Variables Example-1"},{"location":"week-2/ce204-week-2/#polymorphic-variables-example-1_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { // declare an object variable ProgrammingLanguage pl ; // create object of ProgrammingLanguage pl = new ProgrammingLanguage (); pl . display (); // create object of Java class pl = new Java (); pl . display (); } }","title":"Polymorphic Variables Example-1"},{"location":"week-2/ce204-week-2/#java-encapsulation","text":"","title":"Java Encapsulation"},{"location":"week-2/ce204-week-2/#java-encapsulation_1","text":"It prevents outer classes from accessing and changing fields and methods of a class. This also helps to achieve data hiding","title":"Java Encapsulation"},{"location":"week-2/ce204-week-2/#java-encapsulation-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Area { // fields to calculate area int length ; int breadth ; // constructor to initialize values Area ( int length , int breadth ) { this . length = length ; this . breadth = breadth ; } // method to calculate area public void getArea () { int area = length * breadth ; System . out . println ( \"Area: \" + area ); } }","title":"Java Encapsulation Example"},{"location":"week-2/ce204-week-2/#java-encapsulation-example_1","text":"1 2 3 4 5 6 7 8 9 class Main { public static void main ( String [] args ) { // create object of Area // pass value of length and breadth Area rectangle = new Area ( 5 , 6 ); rectangle . getArea (); } }","title":"Java Encapsulation Example"},{"location":"week-2/ce204-week-2/#why-encapsulation","text":"In Java, encapsulation helps us to keep related fields and methods together, which makes our code cleaner and easy to read.","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#why-encapsulation_1","text":"It helps to control the values of our data fields 1 2 3 4 5 6 7 8 9 class Person { private int age ; public void setAge ( int age ) { if ( age >= 0 ) { this . age = age ; } } }","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#why-encapsulation_2","text":"The getter and setter methods provide read-only or write-only access to our class fields","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#1-2getname-provides-read-only-access-setname-provides-write-only-access","text":"","title":"1\n2getName()  // provides read-only access\nsetName() // provides write-only access\n\n"},{"location":"week-2/ce204-week-2/#why-encapsulation_3","text":"It helps to decouple components of a system. For example, we can encapsulate code into multiple bundles. These decoupled components (bundle) can be developed, tested, and debugged independently and concurrently. And, any changes in a particular component do not have any effect on other components.","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#why-encapsulation_4","text":"We can also achieve data hiding using encapsulation. In the next example, if we change the length and breadth variable into private, then the access to these fields is restricted. And, they are kept hidden from outer classes. This is called data hiding.","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#why-encapsulation_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Area { // fields to calculate area int length ; int breadth ; // constructor to initialize values Area ( int length , int breadth ) { this . length = length ; this . breadth = breadth ; } // method to calculate area public void getArea () { int area = length * breadth ; System . out . println ( \"Area: \" + area ); } }","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#why-encapsulation_6","text":"1 2 3 4 5 6 7 8 9 class Main { public static void main ( String [] args ) { // create object of Area // pass value of length and breadth Area rectangle = new Area ( 5 , 6 ); rectangle . getArea (); } }","title":"Why Encapsulation?"},{"location":"week-2/ce204-week-2/#data-hiding","text":"Data hiding is a way of restricting the access of our data members by hiding the implementation details. Encapsulation also provides a way for data hiding. We can use access modifiers to achieve data hiding","title":"Data Hiding"},{"location":"week-2/ce204-week-2/#data-hiding-using-the-private-specifier-example","text":"Making age private allowed us to restrict unauthorized access from outside the class. This is data hiding.","title":"Data hiding using the private specifier example"},{"location":"week-2/ce204-week-2/#data-hiding-using-the-private-specifier-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Person { // private field private int age ; // getter method public int getAge () { return age ; } // setter method public void setAge ( int age ) { this . age = age ; } }","title":"Data hiding using the private specifier example"},{"location":"week-2/ce204-week-2/#data-hiding-using-the-private-specifier-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { public static void main ( String [] args ) { // create an object of Person Person p1 = new Person (); // change age using setter p1 . setAge ( 24 ); // access age using getter System . out . println ( \"My age is \" + p1 . getAge ()); } }","title":"Data hiding using the private specifier example"},{"location":"week-2/ce204-week-2/#java-method-overriding_1","text":"","title":"Java Method Overriding"},{"location":"week-2/ce204-week-2/#java-method-overriding_2","text":"The method overriding is the process of re-defining a method in a child class that is already defined in the parent class. When both parent and child classes have the same method, then that method is said to be the overriding method. The method overriding enables the child class to change the implementation of the method which aquired from parent class according to its requirement.","title":"Java Method Overriding"},{"location":"week-2/ce204-week-2/#java-method-overriding_3","text":"The method overriding is also known as - dynamic method dispatch or - run time polymorphism or - pure polymorphism.","title":"Java Method Overriding"},{"location":"week-2/ce204-week-2/#java-method-overriding-example","text":"1 2 3 4 5 6 7 8 9 class ParentClass { int num = 10 ; void showData () { System . out . println ( \"Inside ParentClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"Java Method Overriding Example"},{"location":"week-2/ce204-week-2/#java-method-overriding-example_1","text":"1 2 3 4 5 6 7 class ChildClass extends ParentClass { void showData () { System . out . println ( \"Inside ChildClass showData() method\" ); System . out . println ( \"num = \" + num ); } }","title":"Java Method Overriding Example"},{"location":"week-2/ce204-week-2/#java-method-overriding-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class PurePolymorphism { public static void main ( String [] args ) { ParentClass obj = new ParentClass (); obj . showData (); obj = new ChildClass (); obj . showData (); } }","title":"Java Method Overriding Example"},{"location":"week-2/ce204-week-2/#rules-for-method-overriding","text":"While overriding a method, we must follow the below list of rules. Static methods can not be overridden. Final methods can not be overridden. Private methods can not be overridden. Constructor can not be overridden. An abstract method must be overridden. Use super keyword to invoke overridden method from child class.","title":"Rules for method overriding"},{"location":"week-2/ce204-week-2/#rules-for-method-overriding_1","text":"The return type of the overriding method must be same as the parent has it. The access specifier of the overriding method can be changed, but the visibility must increase but not decrease. For example, a protected method in the parent class can be made public, but not private, in the child class.","title":"Rules for method overriding"},{"location":"week-2/ce204-week-2/#rules-for-method-overriding_2","text":"If the overridden method does not throw an exception in the parent class, then the child class overriding method can only throw the unchecked exception, throwing a checked exception is not allowed. If the parent class overridden method does throw an exception, then the child class overriding method can only throw the same, or subclass exception, or it may not throw any exception.","title":"Rules for method overriding"},{"location":"week-2/ce204-week-2/#method-overriding-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal { public void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { @Override public void displayInfo () { System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } }","title":"Method Overriding Example"},{"location":"week-2/ce204-week-2/#method-overriding-example_1","text":"annotations are the metadata that we used to provide information to the compiler It is not mandatory to use @Override . However, when we use this, the method should follow all the rules of overriding. Otherwise, the compiler will generate an error.","title":"Method Overriding Example"},{"location":"week-2/ce204-week-2/#method-overriding-example_2","text":"","title":"Method Overriding Example"},{"location":"week-2/ce204-week-2/#super-keyword-in-java-overriding","text":"Can we access the method of the superclass after overriding? The answer is Yes. To access the method of the superclass from the subclass, we use the super keyword","title":"super Keyword in Java Overriding"},{"location":"week-2/ce204-week-2/#use-of-super-keyword-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Animal { public void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { public void displayInfo () { super . displayInfo (); System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } }","title":"Use of super Keyword Example"},{"location":"week-2/ce204-week-2/#use-of-super-keyword-example_1","text":"In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal. When we call the method displayInfo() using the d1 object of the Dog subclass, the method inside the Dog subclass is called; the method inside the superclass is not called Inside displayInfo() of the Dog subclass, we have used super.displayInfo() to call displayInfo() of the superclass.","title":"Use of super Keyword Example"},{"location":"week-2/ce204-week-2/#use-of-super-keyword-example_2","text":"note that constructors in Java are not inherited. Hence, there is no such thing as constructor overriding in Java. However, we can call the constructor of the superclass from its subclasses. For that, we use super()","title":"Use of super Keyword Example"},{"location":"week-2/ce204-week-2/#access-specifiers-in-method-overriding","text":"The same method declared in the superclass and its subclasses can have different access specifiers. However, there is a restriction. We can only use those access specifiers in subclasses that provide larger access than the access specifier of the superclass. For example, Suppose, a method myClass() in the superclass is declared protected. Then, the same method myClass() in the subclass can be either public or protected, but not private.","title":"Access Specifiers in Method Overriding"},{"location":"week-2/ce204-week-2/#access-specifier-in-overriding-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Animal { protected void displayInfo () { System . out . println ( \"I am an animal.\" ); } } class Dog extends Animal { public void displayInfo () { System . out . println ( \"I am a dog.\" ); } } class Main { public static void main ( String [] args ) { Dog d1 = new Dog (); d1 . displayInfo (); } }","title":"Access Specifier in Overriding Example"},{"location":"week-2/ce204-week-2/#access-specifier-in-overriding-example_1","text":"In the above example, the subclass Dog overrides the method displayInfo() of the superclass Animal. Whenever we call displayInfo() using the d1 (object of the subclass), the method inside the subclass is called. Notice that, the displayInfo() is declared protected in the Animal superclass. The same method has the public access specifier in the Dog subclass. This is possible because the public provides larger access than the protected.","title":"Access Specifier in Overriding Example"},{"location":"week-2/ce204-week-2/#overriding-abstract-methods","text":"In Java, abstract classes are created to be the superclass of other classes. And, if a class contains an abstract method, it is mandatory to override it.","title":"Overriding Abstract Methods"},{"location":"week-2/ce204-week-2/#java-nested-and-inner-class","text":"","title":"Java Nested and Inner Class"},{"location":"week-2/ce204-week-2/#java-nested-and-inner-class_1","text":"In Java, you can define a class within another class. Such class is known as nested class 1 2 3 4 5 6 class OuterClass { // ... class NestedClass { // ... } }","title":"Java Nested and Inner Class"},{"location":"week-2/ce204-week-2/#java-nested-and-inner-class_2","text":"There are two types of nested classes you can create in Java. Non-static nested class (inner class) Static nested class","title":"Java Nested and Inner Class"},{"location":"week-2/ce204-week-2/#non-static-nested-class-inner-class","text":"A non-static nested class is a class within another class. It has access to members of the enclosing class (outer class). It is commonly known as inner class. Since the inner class exists within the outer class, you must instantiate the outer class first, in order to instantiate the inner class.","title":"Non-Static Nested Class (Inner Class)"},{"location":"week-2/ce204-week-2/#non-static-nested-class-inner-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class CPU { double price ; // nested class class Processor { // members of nested class double cores ; String manufacturer ; double getCache (){ return 4.3 ; } } // nested protected class protected class RAM { // members of protected nested class double memory ; String manufacturer ; double getClockSpeed (){ return 5.5 ; } } }","title":"Non-Static Nested Class (Inner Class) Example"},{"location":"week-2/ce204-week-2/#non-static-nested-class-inner-class-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Main { public static void main ( String [] args ) { // create object of Outer class CPU CPU cpu = new CPU (); // create an object of inner class Processor using outer class CPU . Processor processor = cpu . new Processor (); // create an object of inner class RAM using outer class CPU CPU . RAM ram = cpu . new RAM (); System . out . println ( \"Processor Cache = \" + processor . getCache ()); System . out . println ( \"Ram Clock speed = \" + ram . getClockSpeed ()); } } section{ font-size: 25px; }","title":"Non-Static Nested Class (Inner Class) Example"},{"location":"week-2/ce204-week-2/#non-static-nested-class-inner-class-example_2","text":"In the example program, there are two nested classes: Processor and RAM inside the outer class: CPU. We can declare the inner class as protected. Hence, we have declared the RAM class as protected. Inside the Main class, we first created an instance of an outer class CPU named cpu. Using the instance of the outer class, we then created objects of inner classes 1 2 CPU . Processor processor = cpu . new Processor ; CPU . RAM ram = cpu . new RAM (); - We use the dot (.) operator to create an instance of the inner class using the outer class.","title":"Non-Static Nested Class (Inner Class) Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class","text":"We can access the members of the outer class by using this keyword","title":"Accessing Members of Outer Class within Inner Class"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car { String carName ; String carType ; // assign values using constructor public Car ( String name , String type ) { this . carName = name ; this . carType = type ; } // private method private String getCarName () { return this . carName ; } ...","title":"Accessing Members of Outer Class within Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ... // inner class class Engine { String engineType ; void setEngine () { // Accessing the carType property of Car if ( Car . this . carType . equals ( \"4WD\" )){ // Invoking method getCarName() of Car if ( Car . this . getCarName (). equals ( \"Crysler\" )) { this . engineType = \"Smaller\" ; } else { this . engineType = \"Bigger\" ; } } else { this . engineType = \"Bigger\" ; } } String getEngineType (){ return this . engineType ; } } }","title":"Accessing Members of Outer Class within Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main ( String [] args ) { // create an object of the outer class Car Car car1 = new Car ( \"Mazda\" , \"8WD\" ); // create an object of inner class using the outer class Car . Engine engine = car1 . new Engine (); engine . setEngine (); System . out . println ( \"Engine Type for 8WD= \" + engine . getEngineType ()); Car car2 = new Car ( \"Crysler\" , \"4WD\" ); Car . Engine c2engine = car2 . new Engine (); c2engine . setEngine (); System . out . println ( \"Engine Type for 4WD = \" + c2engine . getEngineType ()); } } section{ font-size: 30px; }","title":"Accessing Members of Outer Class within Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class-example_3","text":"In the example program, we have the inner class named Engine inside the outer class Car. Here, notice the line, 1 if ( Car . this . carType . equals ( \"4WD\" )) {...} We are using this keyword to access the carType variable of the outer class. You may have noticed that instead of using this.carType we have used Car.this.carType section{ font-size: 30px; }","title":"Accessing Members of Outer Class within Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-within-inner-class-example_4","text":"It is because if we had not mentioned the name of the outer class Car, then this keyword will represent the member inside the inner class. Similarly, we are also accessing the method of the outer class from the inner class. 1 if ( Car . this . getCarName (). equals ( \"Crysler\" ) {...} It is important to note that, although the getCarName() is a private method, we are able to access it from the inner class. section{ font-size: 25px; }","title":"Accessing Members of Outer Class within Inner Class Example"},{"location":"week-2/ce204-week-2/#static-nested-class","text":"In Java, we can also define a static class inside another class. Such class is known as static nested class. Static nested classes are not called static inner classes. Unlike inner class, a static nested class cannot access the member variables of the outer class. It is because the static nested class doesn't require you to create an instance of the outer class. 1 OuterClass . NestedClass obj = new OuterClass . NestedClass (); Here, we are creating an object of the static nested class by simply using the class name of the outer class. Hence, the outer class cannot be referenced using OuterClass.this . section{ font-size: 25px; }","title":"Static Nested Class"},{"location":"week-2/ce204-week-2/#static-inner-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 class MotherBoard { // static nested class static class USB { int usb2 = 2 ; int usb3 = 1 ; int getTotalPorts (){ return usb2 + usb3 ; } } } 1 2 3 4 5 6 7 8 9 public class Main { public static void main ( String [] args ) { // create an object of the static nested class // using the name of the outer class MotherBoard . USB usb = new MotherBoard . USB (); System . out . println ( \"Total Ports = \" + usb . getTotalPorts ()); } } section{ font-size: 25px; }","title":"Static Inner Class Example"},{"location":"week-2/ce204-week-2/#static-inner-class-example_1","text":"In the above program, we have created a static class named USB inside the class MotherBoard. Notice the line, 1 MotherBoard . USB usb = new MotherBoard . USB (); Here, we are creating an object of USB using the name of the outer class. Now, let's see what would happen if you try to access the members of the outer class:","title":"Static Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-inside-static-inner-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MotherBoard { String model ; public MotherBoard ( String model ) { this . model = model ; } // static nested class static class USB { int usb2 = 2 ; int usb3 = 1 ; int getTotalPorts (){ // accessing the variable model of the outer classs if ( MotherBoard . this . model . equals ( \"MSI\" )) { return 4 ; } else { return usb2 + usb3 ; } } } }","title":"Accessing members of Outer class inside Static Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-inside-static-inner-class-example_1","text":"1 2 3 4 5 6 7 8 public class Main { public static void main ( String [] args ) { // create an object of the static nested class MotherBoard . USB usb = new MotherBoard . USB (); System . out . println ( \"Total Ports = \" + usb . getTotalPorts ()); } }","title":"Accessing members of Outer class inside Static Inner Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class-inside-static-inner-class-example_2","text":"When we try to run the program, we will get an error: 1 error: non-static variable this cannot be referenced from a static context - This is because we are not using the object of the outer class to create an object of the inner class. - Hence, there is no reference to the outer class Motherboard stored in Motherboard.this . section{ font-size: 25px; }","title":"Accessing members of Outer class inside Static Inner Class Example"},{"location":"week-2/ce204-week-2/#key-points-to-remember","text":"Java treats the inner class as a regular member of a class. They are just like methods and variables declared inside a class. Since inner classes are members of the outer class, you can apply any access modifiers like private, protected to your inner class which is not possible in normal classes. Since the nested class is a member of its enclosing outer class, you can use the dot (.) notation to access the nested class and its members. Using the nested class will make your code more readable and provide better encapsulation. Non-static nested classes (inner classes) have access to other members of the outer/enclosing class, even if they are declared private.","title":"Key Points to Remember"},{"location":"week-2/ce204-week-2/#java-nested-static-class","text":"","title":"Java Nested Static Class"},{"location":"week-2/ce204-week-2/#java-nested-static-class_1","text":"we can have a class inside another class in Java. Such classes are known as nested classes. In Java, nested classes are of two types: Nested non-static class (Inner class) Nested static class.","title":"Java Nested Static Class"},{"location":"week-2/ce204-week-2/#java-nested-static-class_2","text":"We use the keyword static to make our nested class static. Note: In Java, only nested classes are allowed to be static. Like regular classes, static nested classes can include both static and non-static fields and methods. For example, 1 2 3 4 5 6 Class Animal { static class Mammal { // static and non-static members of Mammal } // members of Animal } - Static nested classes are associated with the outer class. - To access the static nested class, we don\u2019t need objects of the outer class.","title":"Java Nested Static Class"},{"location":"week-2/ce204-week-2/#static-nested-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Animal { // inner class class Reptile { public void displayInfo () { System . out . println ( \"I am a reptile.\" ); } } // static class static class Mammal { public void displayInfo () { System . out . println ( \"I am a mammal.\" ); } } }","title":"Static Nested Class Example"},{"location":"week-2/ce204-week-2/#static-nested-class-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { // object creation of the outer class Animal animal = new Animal (); // object creation of the non-static class Animal . Reptile reptile = animal . new Reptile (); reptile . displayInfo (); // object creation of the static nested class Animal . Mammal mammal = new Animal . Mammal (); mammal . displayInfo (); } }","title":"Static Nested Class Example"},{"location":"week-2/ce204-week-2/#static-nested-class-example_2","text":"In the example program, we have two nested class Mammal and Reptile inside a class Animal . To create an object of the non-static class Reptile, we have used 1 Animal . Reptile reptile = animal . new Reptile () To create an object of the static class Mammal, we have used 1 Animal . Mammal mammal = new Animal . Mammal ()","title":"Static Nested Class Example"},{"location":"week-2/ce204-week-2/#accessing-members-of-outer-class","text":"In Java, static nested classes are associated with the outer class. This is why static nested classes can only access the class members (static fields and methods) of the outer class.","title":"Accessing Members of Outer Class"},{"location":"week-2/ce204-week-2/#accessing-non-static-members-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Animal { static class Mammal { public void displayInfo () { System . out . println ( \"I am a mammal.\" ); } } class Reptile { public void displayInfo () { System . out . println ( \"I am a reptile.\" ); } } public void eat () { System . out . println ( \"I eat food.\" ); } }","title":"Accessing Non-static members Example"},{"location":"week-2/ce204-week-2/#accessing-non-static-members-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { Animal animal = new Animal (); Animal . Reptile reptile = animal . new Reptile (); reptile . displayInfo (); Animal . Mammal mammal = new Animal . Mammal (); mammal . displayInfo (); mammal . eat (); } }","title":"Accessing Non-static members Example"},{"location":"week-2/ce204-week-2/#accessing-non-static-members-example_2","text":"In the example, we have created a non-static method eat() inside the class Animal. Now, if we try to access eat() using the object mammal , the compiler shows an error. It is because mammal is an object of a static class and we cannot access non-static methods from static classes.","title":"Accessing Non-static members Example"},{"location":"week-2/ce204-week-2/#static-top-level-class","text":"only nested classes can be static. We cannot have static top-level classes.","title":"Static Top-level Class"},{"location":"week-2/ce204-week-2/#static-top-level-class_1","text":"if we try to make a top-level class static. 1 2 3 4 5 static class Animal { public static void displayInfo () { System . out . println ( \"I am an animal\" ); } } 1 2 3 4 5 class Main { public static void main ( String [] args ) { Animal . displayInfo (); } }","title":"Static Top-level Class"},{"location":"week-2/ce204-week-2/#static-top-level-class_2","text":"Main.java:1: error: modifier static not allowed here static class Animal { ^ 1 error compiler exit status 1 In the example, we have tried to create a static class Animal. Since Java doesn\u2019t allow static top-level class, we will get an error.","title":"Static Top-level Class"},{"location":"week-2/ce204-week-2/#java-anonymous-class","text":"","title":"Java Anonymous Class"},{"location":"week-2/ce204-week-2/#java-anonymous-class_1","text":"In Java, a class can contain another class known as nested class. It's possible to create a nested class without giving any name. A nested class that doesn't have any name is known as an anonymous class. An anonymous class must be defined inside another class. Hence, it is also known as an anonymous inner class. Its syntax is: 1 2 3 4 5 6 7 class outerClass { // defining anonymous class object1 = new Type ( parameterList ) { // body of the anonymous class }; }","title":"Java Anonymous Class"},{"location":"week-2/ce204-week-2/#java-anonymous-class_2","text":"Anonymous classes usually extend subclasses or implement interfaces. Here, Type can be a superclass that an anonymous class extends an interface that an anonymous class implements The above code creates an object, object1, of an anonymous class at runtime. Note : Anonymous classes are defined inside an expression. So, the semicolon is used at the end of anonymous classes to indicate the end of the expression.","title":"Java Anonymous Class"},{"location":"week-2/ce204-week-2/#anonymous-class-extending-a-class-example","text":"1 2 3 4 5 class Polygon { public void display () { System . out . println ( \"Inside the Polygon class\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 class AnonymousDemo { public void createClass () { // creation of anonymous class extending class Polygon Polygon p1 = new Polygon () { public void display () { System . out . println ( \"Inside an anonymous class.\" ); } }; p1 . display (); } }","title":"Anonymous Class Extending a Class Example"},{"location":"week-2/ce204-week-2/#anonymous-class-extending-a-class-example_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { AnonymousDemo an = new AnonymousDemo (); an . createClass (); } }","title":"Anonymous Class Extending a Class Example"},{"location":"week-2/ce204-week-2/#anonymous-class-extending-a-class-example_2","text":"In the example, we have created a class Polygon . It has a single method display() . We then created an anonymous class that extends the class Polygon and overrides the display() method. When we run the program, an object p1 of the anonymous class is created. The object then calls the display() method of the anonymous class.","title":"Anonymous Class Extending a Class Example"},{"location":"week-2/ce204-week-2/#anonymous-class-implementing-an-interface-example","text":"1 2 3 interface Polygon { public void display (); } 1 2 3 4 5 6 7 8 9 10 11 12 class AnonymousDemo { public void createClass () { // anonymous class implementing interface Polygon p1 = new Polygon () { public void display () { System . out . println ( \"Inside an anonymous class.\" ); } }; p1 . display (); } }","title":"Anonymous Class Implementing an Interface Example"},{"location":"week-2/ce204-week-2/#anonymous-class-implementing-an-interface-example_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { AnonymousDemo an = new AnonymousDemo (); an . createClass (); } } In the example, we have created an anonymous class that implements the Polygon interface.","title":"Anonymous Class Implementing an Interface Example"},{"location":"week-2/ce204-week-2/#advantages-of-anonymous-classes","text":"In anonymous classes, objects are created whenever they are required. That is, objects are created to perform some specific tasks. For example, 1 2 3 4 5 Object = new Example () { public void display () { System . out . println ( \"Anonymous class overrides the method display().\" ); } }; Here, an object of the anonymous class is created dynamically when we need to override the display() method. Anonymous classes also help us to make our code concise.","title":"Advantages of Anonymous Classes"},{"location":"week-2/ce204-week-2/#java-enums","text":"","title":"Java enums"},{"location":"week-2/ce204-week-2/#java-enums_1","text":"In Java, an enum (short for enumeration) is a type that has a fixed set of constant values. We use the enum keyword to declare enums. For example, 1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } - Here, we have created an enum named Size. It contains fixed values SMALL , MEDIUM , LARGE , and EXTRALARGE . - These values inside the braces are called enum constants (values). - Note: The enum constants are usually represented in uppercase.","title":"Java enums"},{"location":"week-2/ce204-week-2/#java-enum-example","text":"1 2 3 4 5 6 7 8 9 10 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } class Main { public static void main ( String [] args ) { System . out . println ( Size . SMALL ); System . out . println ( Size . MEDIUM ); } }","title":"Java Enum Example"},{"location":"week-2/ce204-week-2/#java-enum-example_1","text":"we use the enum name to access the constant values. Also, we can create variables of enum types. For example 1 Size pizzaSize ; Here, pizzaSize is a variable of the Size type. It can only be assigned with 4 values. 1 2 3 4 pizzaSize = Size . SMALL ; pizzaSize = Size . MEDIUM ; pizzaSize = Size . LARGE ; pizzaSize = Size . EXTRALARGE ;","title":"Java Enum Example"},{"location":"week-2/ce204-week-2/#java-enum-with-the-switch-statement-example","text":"1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE }","title":"Java Enum with the switch statement example"},{"location":"week-2/ce204-week-2/#java-enum-with-the-switch-statement-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Test { Size pizzaSize ; public Test ( Size pizzaSize ) { this . pizzaSize = pizzaSize ; } public void orderPizza () { switch ( pizzaSize ) { case SMALL : System . out . println ( \"I ordered a small size pizza.\" ); break ; case MEDIUM : System . out . println ( \"I ordered a medium size pizza.\" ); break ; default : System . out . println ( \"I don't know which one to order.\" ); break ; } } }","title":"Java Enum with the switch statement example"},{"location":"week-2/ce204-week-2/#java-enum-with-the-switch-statement-example_2","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Test t1 = new Test ( Size . MEDIUM ); t1 . orderPizza (); } }","title":"Java Enum with the switch statement example"},{"location":"week-2/ce204-week-2/#java-enum-with-the-switch-statement-example_3","text":"In the example, we have created an enum type Size . - We then declared a variable pizzaSize of the Size type. Here, the variable pizzaSize can only be assigned with 4 values ( SMALL, MEDIUM, LARGE, EXTRALARGE ). Notice the statement, 1 Test t1 = new Test ( Size . MEDIUM ); It will call the Test() constructor inside the Test class. Now, the variable pizzaSize is assigned with the MEDIUM constant. Based on the value, one of the cases of the switch case statement is executed.","title":"Java Enum with the switch statement example"},{"location":"week-2/ce204-week-2/#enum-class-in-java","text":"In Java, enum types are considered to be a special type of class. It was introduced with the release of Java 5. An enum class can include methods and fields just like regular classes. 1 2 3 4 5 enum Size { constant1 , constant2 , \u2026 , constantN ; // methods and fields } When we create an enum class, the compiler will create instances (objects) of each enum constants. Also, all enum constant is always public static final by default.","title":"Enum Class in Java"},{"location":"week-2/ce204-week-2/#java-enum-class-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE ; public String getSize () { // this will refer to the object SMALL switch ( this ) { case SMALL : return \"small\" ; case MEDIUM : return \"medium\" ; case LARGE : return \"large\" ; case EXTRALARGE : return \"extra large\" ; default : return null ; } } ...","title":"Java Enum Class Example"},{"location":"week-2/ce204-week-2/#java-enum-class-example_1","text":"1 2 3 4 5 6 7 8 ... public static void main ( String [] args ) { // call getSize() // using the object SMALL System . out . println ( \"The size of the pizza is \" + Size . SMALL . getSize ()); } }","title":"Java Enum Class Example"},{"location":"week-2/ce204-week-2/#java-enum-class-example_2","text":"In the example, we have created an enum class Size. It has four constants SMALL, MEDIUM, LARGE and EXTRALARGE. Since Size is an enum class, the compiler automatically creates instances for each enum constants. Here inside the main() method, we have used the instance SMALL to call the getSize() method. Note : Like regular classes, an enum class also may include constructors","title":"Java Enum Class Example"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class","text":"There are some predefined methods in enum classes that are readily available for use.","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_1","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#java-enum-ordinal","text":"The ordinal() method returns the position of an enum constant. For example, 1 2 ordinal ( SMALL ) // returns 0","title":"Java Enum ordinal()"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_2","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#enum-compareto","text":"The compareTo() method compares the enum constants based on their ordinal value. For example, 1 2 Size . SMALL . compareTo ( Size . MEDIUM ) // returns ordinal(SMALL) - ordinal(MEDIUM)","title":"Enum compareTo()"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_3","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#enum-tostring","text":"The toString() method returns the string representation of the enum constants. For example, 1 2 SMALL . toString () // returns \"SMALL\"","title":"Enum toString()"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_4","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#enum-name","text":"The name() method returns the defined name of an enum constant in string form. The returned value from the name() method is final. For example, 1 2 name ( SMALL ) // returns \"SMALL\"","title":"Enum name()"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_5","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#java-enum-valueof","text":"The valueOf() method takes a string and returns an enum constant having the same string name. For example, 1 2 Size . valueOf ( \"SMALL\" ) // returns constant SMALL.","title":"Java Enum valueOf()"},{"location":"week-2/ce204-week-2/#methods-of-java-enum-class_6","text":"","title":"Methods of Java Enum Class"},{"location":"week-2/ce204-week-2/#enum-values","text":"The values() method returns an array of enum type containing all the enum constants. For example, 1 Size [] enumArray = Size . value ();","title":"Enum values()"},{"location":"week-2/ce204-week-2/#why-java-enums","text":"In Java, enum was introduced to replace the use of int constants. Suppose we have used a collection of int constants. 1 2 3 4 5 6 class Size { public final static int SMALL = 1 ; public final static int MEDIUM = 2 ; public final static int LARGE = 3 ; public final static int EXTRALARGE = 4 ; } Here, the problem arises if we print the constants. It is because only the number is printed which might not be helpful.","title":"Why Java Enums?"},{"location":"week-2/ce204-week-2/#why-java-enums_1","text":"So, instead of using int constants, we can simply use enums. For example, 1 2 3 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } This makes our code more intuitive.","title":"Why Java Enums?"},{"location":"week-2/ce204-week-2/#why-java-enums_2","text":"Also, enum provides compile-time type safety. If we declare a variable of the Size type. For example, 1 Size size ; Here, it is guaranteed that the variable will hold one of the four values. Now, If we try to pass values other than those four values, the compiler will generate an error.","title":"Why Java Enums?"},{"location":"week-2/ce204-week-2/#java-enum-constructor","text":"In Java, an enum class may include a constructor like a regular class. These enum constructors are either private - accessible within the class or package-private - accessible within the package","title":"Java enum Constructor"},{"location":"week-2/ce204-week-2/#enum-constructor-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 enum Size { // enum constants calling the enum constructors SMALL ( \"The size is small.\" ), MEDIUM ( \"The size is medium.\" ), LARGE ( \"The size is large.\" ), EXTRALARGE ( \"The size is extra large.\" ); private final String pizzaSize ; // private enum constructor private Size ( String pizzaSize ) { this . pizzaSize = pizzaSize ; } public String getSize () { return pizzaSize ; } }","title":"enum Constructor Example"},{"location":"week-2/ce204-week-2/#enum-constructor-example_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Size size = Size . SMALL ; System . out . println ( size . getSize ()); } }","title":"enum Constructor Example"},{"location":"week-2/ce204-week-2/#enum-constructor-example_2","text":"In the example, we have created an enum Size. It includes a private enum constructor. The constructor takes a string value as a parameter and assigns value to the variable pizzaSize. Since the constructor is private, we cannot access it from outside the class. However, we can use enum constants to call the constructor. In the Main class, we assigned SMALL to an enum variable size. The constant SMALL then calls the constructor Size with string as an argument. Finally, we called getSize() using size.","title":"enum Constructor Example"},{"location":"week-2/ce204-week-2/#java-enum-strings","text":"","title":"Java enum Strings"},{"location":"week-2/ce204-week-2/#java-enum-strings_1","text":"In Java, we can get the string representation of enum constants using the toString() method or the name() method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 enum Size { SMALL , MEDIUM , LARGE , EXTRALARGE } class Main { public static void main ( String [] args ) { System . out . println ( \"string value of SMALL is \" + Size . SMALL . toString ()); System . out . println ( \"string value of MEDIUM is \" + Size . MEDIUM . name ()); } } - we have seen the default string representation of an enum constant is the name of the same constant.","title":"Java enum Strings"},{"location":"week-2/ce204-week-2/#change-default-string-value-of-enums","text":"We can change the default string representation of enum constants by overriding the toString() method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 enum Size { SMALL { // overriding toString() for SMALL public String toString () { return \"The size is small.\" ; } }, MEDIUM { // overriding toString() for MEDIUM public String toString () { return \"The size is medium.\" ; } }; } ...","title":"Change Default String Value of enums"},{"location":"week-2/ce204-week-2/#change-default-string-value-of-enums_1","text":"1 2 3 4 5 6 ... class Main { public static void main ( String [] args ) { System . out . println ( Size . MEDIUM . toString ()); } } In the above program, we have created an enum Size. And we have overridden the toString() method for enum constants SMALL and MEDIUM . Note: We cannot override the name() method. It is because the name() method is final .","title":"Change Default String Value of enums"},{"location":"week-2/ce204-week-2/#java-abstract-class","text":"","title":"Java Abstract Class"},{"location":"week-2/ce204-week-2/#java-abstract-class_1","text":"An abstract class is a class that created using abstract keyword. In other words, a class prefixed with abstract keyword is known as an abstract class. In java, an abstract class may contain abstract methods (methods without implementation) and also non-abstract methods (methods with implementation). We use the following syntax to create an abstract class. 1 2 3 abstract class < ClassName > { ... }","title":"Java Abstract Class"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1","text":"1 2 3 4 5 6 7 8 9 import java.util.* ; abstract class Shape { int length , breadth , radius ; Scanner input = new Scanner ( System . in ); abstract void printArea (); }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_1","text":"1 2 3 4 5 6 7 8 9 class Rectangle extends Shape { void printArea () { System . out . println ( \"*** Finding the Area of Rectangle ***\" ); System . out . print ( \"Enter length and breadth: \" ); length = input . nextInt (); breadth = input . nextInt (); System . out . println ( \"The area of Rectangle is: \" + length * breadth ); } }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_2","text":"1 2 3 4 5 6 7 8 9 class Triangle extends Shape { void printArea () { System . out . println ( \"\\n*** Finding the Area of Triangle ***\" ); System . out . print ( \"Enter Base And Height: \" ); length = input . nextInt (); breadth = input . nextInt (); System . out . println ( \"The area of Triangle is: \" + ( length * breadth ) / 2 ); } }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_3","text":"1 2 3 4 5 6 7 8 class Cricle extends Shape { void printArea () { System . out . println ( \"\\n*** Finding the Area of Cricle ***\" ); System . out . print ( \"Enter Radius: \" ); radius = input . nextInt (); System . out . println ( \"The area of Cricle is: \" + 3.14f * radius * radius ); } }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class AbstractClassExample { public static void main ( String [] args ) { Rectangle rec = new Rectangle (); rec . printArea (); Triangle tri = new Triangle (); tri . printArea (); Cricle cri = new Cricle (); cri . printArea (); } }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_5","text":"An abstract class can not be instantiated but can be referenced. That means we can not create an object of an abstract class, but base reference can be created.","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_6","text":"In the example program, the child class objects are created to invoke the overridden abstract method. But we may also create base class reference and assign it with child class instance to invoke the same. The main method of the above program can be written as follows that produce the same output.","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-1_7","text":"1 2 3 4 5 6 7 8 9 10 public static void main ( String [] args ) { Shape obj = new Rectangle (); //Base class reference to Child class instance obj . printArea (); obj = new Triangle (); obj . printArea (); obj = new Cricle (); obj . printArea (); }","title":"Java Abstract Class Example-1"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-2","text":"1 2 3 4 5 6 7 abstract class Animal { abstract void makeSound (); public void eat () { System . out . println ( \"I can eat.\" ); } }","title":"Java Abstract Class Example-2"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-2_1","text":"1 2 3 4 5 6 7 class Dog extends Animal { // provide implementation of abstract method public void makeSound () { System . out . println ( \"Bark bark\" ); } }","title":"Java Abstract Class Example-2"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-2_2","text":"1 2 3 4 5 6 7 8 9 10 class Main { public static void main ( String [] args ) { // create an object of Dog class Dog d1 = new Dog (); d1 . makeSound (); d1 . eat (); } }","title":"Java Abstract Class Example-2"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-3","text":"1 2 3 abstract class MotorBike { abstract void brake (); }","title":"Java Abstract Class Example-3"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-3_1","text":"1 2 3 4 5 6 7 class SportsBike extends MotorBike { // implementation of abstract method public void brake () { System . out . println ( \"SportsBike Brake\" ); } }","title":"Java Abstract Class Example-3"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-3_2","text":"1 2 3 4 5 6 7 class MountainBike extends MotorBike { // implementation of abstract method public void brake () { System . out . println ( \"MountainBike Brake\" ); } }","title":"Java Abstract Class Example-3"},{"location":"week-2/ce204-week-2/#java-abstract-class-example-3_3","text":"1 2 3 4 5 6 7 8 class Main { public static void main ( String [] args ) { MountainBike m1 = new MountainBike (); m1 . brake (); SportsBike s1 = new SportsBike (); s1 . brake (); } }","title":"Java Abstract Class Example-3"},{"location":"week-2/ce204-week-2/#accesses-constructor-of-abstract-classes","text":"An abstract class can have constructors like the regular class. And, we can access the constructor of an abstract class from the subclass using the super keyword. For example, 1 2 3 4 5 6 7 8 9 10 11 12 abstract class Animal { Animal () { \u2026 . } } class Dog extends Animal { Dog () { super (); ... } }","title":"Accesses Constructor of Abstract Classes"},{"location":"week-2/ce204-week-2/#accesses-constructor-of-abstract-classes_1","text":"Note that the super should always be the first statement of the subclass constructor","title":"Accesses Constructor of Abstract Classes"},{"location":"week-2/ce204-week-2/#java-abstract-class_2","text":"","title":"Java Abstract Class"},{"location":"week-2/ce204-week-2/#rules-for-method-overriding_3","text":"An abstract class must follow the below list of rules. An abstract class must be created with abstract keyword. An abstract class can be created without any abstract method. An abstract class may contain abstract methods and non-abstract methods. An abstract class may contain final methods that can not be overridden.","title":"Rules for method overriding"},{"location":"week-2/ce204-week-2/#java-abstract-class_3","text":"","title":"Java Abstract Class"},{"location":"week-2/ce204-week-2/#rules-for-method-overriding_4","text":"An abstract class may contain static methods, but the abstract method can not be static. An abstract class may have a constructor that gets executed when the child class object created. An abstract method must be overridden by the child class, otherwise, it must be defined as an abstract class. An abstract class can not be instantiated but can be referenced.","title":"Rules for method overriding"},{"location":"week-2/ce204-week-2/#java-abstract-class-review","text":"","title":"Java Abstract Class Review"},{"location":"week-2/ce204-week-2/#java-abstract-class-review_1","text":"The abstract class in Java cannot be instantiated (we cannot create objects of abstract classes). We use the abstract keyword to declare an abstract class. For example, 1 2 3 4 5 6 7 8 9 // create an abstract class abstract class Language { // fields and methods } ... // try to create an object Language // throws an error Language obj = new Language ();","title":"Java Abstract Class Review"},{"location":"week-2/ce204-week-2/#java-abstract-class-review_2","text":"An abstract class can have both the regular methods and abstract methods. For example, 1 2 3 4 5 6 7 8 9 10 abstract class Language { // abstract method abstract void method1 (); // regular method void method2 () { System . out . println ( \"This is regular method\" ); } } section{ font-size: 25px; }","title":"Java Abstract Class Review"},{"location":"week-2/ce204-week-2/#java-abstract-method-review","text":"A method that doesn't have its body is known as an abstract method. We use the same abstract keyword to create abstract methods. For example, 1 abstract void display (); Here, display() is an abstract method. The body of display() is replaced by ;. If a class contains an abstract method, then the class should be declared abstract. Otherwise, it will generate an error. For example, 1 2 3 4 5 6 7 // error // class should be abstract class Language { // abstract method abstract void method1 (); }","title":"Java Abstract Method Review"},{"location":"week-2/ce204-week-2/#java-abstract-class-and-method-example","text":"Though abstract classes cannot be instantiated, we can create subclasses from it. We can then access members of the abstract class using the object of the subclass.","title":"Java Abstract Class and Method Example"},{"location":"week-2/ce204-week-2/#java-abstract-class-and-method-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 abstract class Language { // method of abstract class public void display () { System . out . println ( \"This is Java Programming\" ); } } class Main extends Language { public static void main ( String [] args ) { // create an object of Main Main obj = new Main (); // access method of abstract class // using object of Main class obj . display (); } }","title":"Java Abstract Class and Method Example"},{"location":"week-2/ce204-week-2/#java-abstract-class-and-method-example_2","text":"In the example, we have created an abstract class named Language. The class contains a regular method display(). We have created the Main class that inherits the abstract class. Notice the statement, 1 obj . display (); Here, obj is the object of the child class Main. We are calling the method of the abstract class using the object obj. section{ font-size: 25px; }","title":"Java Abstract Class and Method Example"},{"location":"week-2/ce204-week-2/#java-abstract-method-review-keypoints","text":"We use the abstract keyword to create abstract classes and methods. An abstract method doesn't have any implementation (method body). A class containing abstract methods should also be abstract. We cannot create objects of an abstract class. To implement features of an abstract class, we inherit subclasses from it and create objects of the subclass. A subclass must override all abstract methods of an abstract class. However, if the subclass is declared abstract, it's not mandatory to override abstract methods. We can access the static attributes and methods of an abstract class using the reference of the abstract class. For example, 1 Animal . staticMethod ();","title":"Java Abstract Method Review Keypoints"},{"location":"week-2/ce204-week-2/#java-object-class","text":"","title":"Java Object Class"},{"location":"week-2/ce204-week-2/#java-object-class_1","text":"In java, the Object class is the super most class of any class hierarchy. The Object class in the java programming language is present inside the java.lang package. Every class in the java programming language is a subclass of Object class by default. The Object class is useful when you want to refer to any object whose type you don't know. Because it is the superclass of all other classes in java, it can refer to any type of object.","title":"Java Object Class"},{"location":"week-2/ce204-week-2/#methods-of-object-class","text":"object getClass() Returns Class class object int hashCode() returns the hashcode number for object being used. boolean equals(Object obj) compares the argument object to calling object. int clone() Compares two strings, ignoring case","title":"Methods of Object class"},{"location":"week-2/ce204-week-2/#methods-of-object-class_1","text":"object concat(String) Creates copy of invoking object String toString() Returns the string representation of invoking object. void notify() Wakes up a thread, waiting on invoking object's monitor. void notifyAll() wakes up all the threads, waiting on invoking object's - monitor.","title":"Methods of Object class"},{"location":"week-2/ce204-week-2/#methods-of-object-class_2","text":"void wait() causes the current thread to wait, until another thread - notifies void wait(long,int) causes the current thread to wait for the specified - milliseconds and nanoseconds, until another thread notifies. void finalize() It is invoked by the garbage collector before an object is being garbage collected.","title":"Methods of Object class"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance","text":"The inheritance concept used for the number of purposes in the java programming language. One of the main purposes is substitutability. The substitutability means that when a child class acquires properties from its parent class, the object of the parent class may be substituted with the child class object. For example, if B is a child class of A, anywhere we expect an instance of A we can use an instance of B. The substitutability can achieve using inheritance, whether using extends or implements keywords.","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_1","text":"The following are the differnt forms of inheritance in java. Specialization Specification Construction Extension Limitation Combination","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_2","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#specialization","text":"It is the most ideal form of inheritance. The subclass is a special case of the parent class. It holds the principle of substitutability.","title":"Specialization"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_3","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#specification","text":"This is another commonly used form of inheritance. In this form of inheritance, the parent class just specifies which methods should be available to the child class but doesn't implement them. The java provides concepts like abstract and interfaces to support this form of inheritance. It holds the principle of substitutability.","title":"Specification"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_4","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#construction","text":"This is another form of inheritance where the child class may change the behavior defined by the parent class (overriding). It does not hold the principle of substitutability.","title":"Construction"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_5","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#extension","text":"This is another form of inheritance where the child class may add its new properties. It holds the principle of substitutability.","title":"Extension"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_6","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#limitation","text":"This is another form of inheritance where the subclass restricts the inherited behavior. It does not hold the principle of substitutability.","title":"Limitation"},{"location":"week-2/ce204-week-2/#java-forms-of-inheritance_7","text":"","title":"Java Forms of Inheritance"},{"location":"week-2/ce204-week-2/#combination","text":"This is another form of inheritance where the subclass inherits properties from multiple parent classes. Java does not support multiple inheritance type.","title":"Combination"},{"location":"week-2/ce204-week-2/#benefits-and-costs-of-inheritance-in-java","text":"Inheritance is the core and more useful concept of Object-Oriented Programming. It proWith inheritance, we will be able to override the methods of the base class so that the meaningful implementation of the base class method can be designed in the derived class. An inheritance leads to less development and maintenance costs. Vides many benefits, and a few of them are listed below.","title":"Benefits and Costs of Inheritance in java"},{"location":"week-2/ce204-week-2/#benefits-of-inheritance","text":"Inheritance helps in code reuse. The child class may use the code defined in the parent class without re-writing it. Inheritance can save time and effort as the main code need not be written again. Inheritance provides a clear model structure which is easy to understand. An inheritance leads to less development and maintenance costs. With inheritance, we will be able to override the methods of the base class so that the meaningful implementation of the base class method can be designed in the derived class. An inheritance leads to less development and maintenance costs. In inheritance base class can decide to keep some data private so that it cannot be altered by the derived class.","title":"Benefits of Inheritance"},{"location":"week-2/ce204-week-2/#costs-of-inheritance","text":"Inheritance decreases the execution speed due to the increased time and effort it takes, the program to jump through all the levels of overloaded classes. Inheritance makes the two classes (base and inherited class) get tightly coupled. This means one cannot be used independently of each other. The changes made in the parent class will affect the behavior of child class too. The overuse of inheritance makes the program more complex.","title":"Costs of Inheritance"},{"location":"week-2/ce204-week-2/#defining-packages-in-java","text":"","title":"Defining Packages in java"},{"location":"week-2/ce204-week-2/#defining-packages-in-java_1","text":"In java, a package is a container of classes, interfaces, and sub-packages. We may think of it as a folder in a file directory. We use the packages to avoid naming conflicts and to organize project-related classes, interfaces, and sub-packages into a bundle.","title":"Defining Packages in java"},{"location":"week-2/ce204-week-2/#defining-packages-in-java_2","text":"In java, the packages have divided into two types. Built-in Packages User-defined Packages","title":"Defining Packages in java"},{"location":"week-2/ce204-week-2/#built-in-packages","text":"The built-in packages are the packages from java API. The Java API is a library of pre-defined classes, interfaces, and sub-packages. The built-in packages were included in the JDK. There are many built-in packages in java, few of them are as java, lang, io, util, awt, javax, swing, net, sql , etc. We need to import the built-in packages to use them in our program. To import a package, we use the import statement.","title":"Built-in Packages"},{"location":"week-2/ce204-week-2/#user-defined-packages","text":"The user-defined packages are the packages created by the user. User is free to create their own packages.","title":"User-defined Packages"},{"location":"week-2/ce204-week-2/#definig-a-package-in-java","text":"We use the package keyword to create or define a package in java programming language. 1 package packageName ;","title":"Definig a Package in java"},{"location":"week-2/ce204-week-2/#definig-a-package-in-java_1","text":"The package statement must be the first statement in the program. The package name must be a single word. The package name must use Camel case notation.","title":"Definig a Package in java"},{"location":"week-2/ce204-week-2/#definig-a-package-in-java_2","text":"create a user-defined package myPackage 1 2 3 4 5 6 7 8 9 10 11 package myPackage ; public class DefiningPackage { public static void main ( String [] args ) { System . out . println ( \"This class belongs to myPackage.\" ); } }","title":"Definig a Package in java"},{"location":"week-2/ce204-week-2/#definig-a-package-in-java_3","text":"Now, save the example code in a file DefiningPackage.java , and compile it using the following command. javac -d . DefiningPackage.java The above command creates a directory with the package name myPackage, and the DefiningPackage.class is saved into it. Run the program use the following command. java myPackage.DefiningPackage When we use IDE like Eclipse, Netbeans, etc. the package structure is created automatically.","title":"Definig a Package in java"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages","text":"In java, the access modifiers define the accessibility of the class and its members. For example, private members are accessible within the same class members only. Java has four access modifiers, and they are default, private, protected, and public. In java, the package is a container of classes, sub-classes, interfaces, and sub-packages. The class acts as a container of data and methods. So, the access modifier decides the accessibility of class members across the different packages. In java, the accessibility of the members of a class or interface depends on its access specifiers.","title":"Access protection in java packages"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages_1","text":"","title":"Access protection in java packages"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages_2","text":"The public members can be accessed everywhere. The private members can be accessed only inside the same class. The protected members are accessible to every child class (same package or other packages). The default members are accessible within the same package but not outside the package.","title":"Access protection in java packages"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ParentClass { int a = 10 ; public int b = 20 ; protected int c = 30 ; private int d = 40 ; void showData () { System . out . println ( \"Inside ParentClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); System . out . println ( \"d = \" + d ); } }","title":"Access protection in java packages example"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 class ChildClass extends ParentClass { void accessData () { System . out . println ( \"Inside ChildClass\" ); System . out . println ( \"a = \" + a ); System . out . println ( \"b = \" + b ); System . out . println ( \"c = \" + c ); //System.out.println(\"d = \" + d); // private member can't be accessed } }","title":"Access protection in java packages example"},{"location":"week-2/ce204-week-2/#access-protection-in-java-packages-example_2","text":"1 2 3 4 5 6 7 8 9 public class AccessModifiersExample { public static void main ( String [] args ) { ChildClass obj = new ChildClass (); obj . showData (); obj . accessData (); } }","title":"Access protection in java packages example"},{"location":"week-2/ce204-week-2/#importing-packages-in-java","text":"In java, the import keyword used to import built-in and user-defined packages. When a package has imported, we can refer to all the classes of that package using their name directly. The import statement must be after the package statement, and before any other statement. Using an import statement, we may import a specific class or all the classes from a package.","title":"Importing Packages in java"},{"location":"week-2/ce204-week-2/#importing-packages-in-java_1","text":"Using one import statement, we may import only one package or a class. Using an import statement, we can not import a class directly, but it must be a part of a package. A program may contain any number of import statements.","title":"Importing Packages in java"},{"location":"week-2/ce204-week-2/#importing-specific-class","text":"1 import packageName.ClassName ;","title":"Importing specific class"},{"location":"week-2/ce204-week-2/#importing-specific-class_1","text":"import a built-in package and Scanner class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package myPackage ; import java.util.Scanner ; public class ImportingExample { public static void main ( String [] args ) { Scanner read = new Scanner ( System . in ); int i = read . nextInt (); System . out . println ( \"You have entered a number \" + i ); } }","title":"Importing specific class"},{"location":"week-2/ce204-week-2/#importing-all-the-classes","text":"Using an importing statement, we can import all the classes of a package. To import all the classes of the package, we use * symbol. The following syntax is employed to import all the classes of a package. 1 import packageName.* ;","title":"Importing all the classes"},{"location":"week-2/ce204-week-2/#importing-all-the-classes_1","text":"import a built-in package. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package myPackage ; import java.util.* ; public class ImportingExample { public static void main ( String [] args ) { Scanner read = new Scanner ( System . in ); int i = read . nextInt (); System . out . println ( \"You have entered a number \" + i ); Random rand = new Random (); int num = rand . nextInt ( 100 ); System . out . println ( \"Randomly generated number \" + num ); } }","title":"Importing all the classes"},{"location":"week-2/ce204-week-2/#importing-all-the-classes_2","text":"The import statement imports only classes of the package, but not sub-packages and its classes. We may also import sub-packages by using a symbol '.' (dot) to separate parent package and sub-package.","title":"Importing all the classes"},{"location":"week-2/ce204-week-2/#references","text":"BtechSmartClass-super Keyword Programiz-super Keyword BtechSmartClass-Java final Keyword Programiz-final Keyword BtechSmartClass-java Polymorphism Programiz-Polymorphism Programiz-Encapsulation BtechSmartClass-Java Method Overriding","title":"References"},{"location":"week-2/ce204-week-2/#references_1","text":"Programiz-Method Overriding Programiz-Nested Inner Class Programiz-Static Class Programiz-Anonymous Class Programiz-enums Programiz-enum constructor Programiz-enum string BtechSmartClass-Java Abstract Class Programiz-Abstract Classes Methods","title":"References"},{"location":"week-2/ce204-week-2/#references_2","text":"BtechSmartClass-Java Object class BtechSmartClass-Java Forms of Inheritance Programiz-Interfaces BtechSmartClass-Java Benefits and Costs of Inheritance BtechSmartClass-Java Defining Packages BtechSmartClass-Java Access Protection in Packages BtechSmartClass-Java Importing Packages \\(End-Of-Week-2-Module\\)","title":"References"},{"location":"week-3/ce204-week-3/","text":"CE204 Object-Oriented Programming \u00b6 Week-3 (OOP with Java-III) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX OOP with Java-III \u00b6 Outline (1) \u00b6 Defining an Interface in Java Implementing an Interface in Java Nested Interfaces in Java Variables in Java Interfaces Extending an Interface in java Outline (2) \u00b6 Advantages of Interface in Java default methods in Java Interfaces private and static Methods in Interface Java Reflection Java Wrapper Classes Java Lambda Expressions Defining an Interface in Java \u00b6 Defining an Interface in Java \u00b6 In java, an interface is similar to a class, but it contains abstract methods and static final variables only. The interface in Java is another mechanism to achieve abstraction. We may think of an interface as a completely abstract class. None of the methods in the interface has an implementation, and all the variables in the interface are constants. All the methods of an interface, implemented by the class that implements it. The interface in java enables java to support multiple-inheritance. An interface may extend only one interface, but a class may implement any number of interfaces. Defining an Interface in Java \u00b6 An interface is a container of abstract methods and static final variables. An interface, implemented by a class. (class implements interface). An interface may extend another interface. (Interface extends Interface). An interface never implements another interface, or class. A class may implement any number of interfaces. We can not instantiate an interface. Specifying the keyword abstract for interface methods is optional, it automatically added. All the members of an interface are public by default. Defining an Interface in Java \u00b6 Defining an interface is similar to that of a class. We use the keyword interface to define an interface. All the members of an interface are public by default. The following is the syntax for defining an interface. 1 2 3 4 5 interface InterfaceName { ... members declaration ; ... } Defining an Interface in Java \u00b6 In the example we defined an interface HumanInterfaceExample that contains two abstract methods learn(), work() and one constant duration. 1 2 3 4 5 6 7 8 interface HumanInterfaceExample { void learn ( String str ); void work (); int duration = 10 ; } Defining an Interface in Java Example-1 \u00b6 Every interface in Java is auto-completed by the compiler. For example, in the above example code, no member is defined as public, but all are public automatically. The above code automatically converted as follows. 1 2 3 4 5 6 7 8 interface HumanInterfaceExample { public abstract void learn ( String str ); public abstract void work (); public static final int duration = 10 ; } Implementing an Interface in Java \u00b6 Implementing an Interface in Java \u00b6 In java, an interface is implemented by a class. The class that implements an interface must provide code for all the methods defined in the interface, otherwise, it must be defined as an abstract class. The class uses a keyword implements to implement an interface. A class can implement any number of interfaces. When a class wants to implement more than one interface, we use the implements keyword is followed by a comma-separated list of the interfaces implemented by the class. Implementing an Interface in Java \u00b6 The following is the syntax for defineing a class that implements an interface. 1 2 3 4 5 class className implements InterfaceName { ... boby - of - the - class ... } Implementing an Interface in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 interface Human { void learn ( String str ); void work (); int duration = 10 ; } Implementing an Interface in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 class Programmer implements Human { public void learn ( String str ) { System . out . println ( \"Learn using \" + str ); } public void work () { System . out . println ( \"Develop applications\" ); } } Implementing an Interface in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 public class HumanTest { public static void main ( String [] args ) { Programmer trainee = new Programmer (); trainee . learn ( \"coding\" ); trainee . work (); } } Implementing an Interface in Java Example-1 \u00b6 In the example we defined an interface Human that contains two abstract methods learn(), work() and one constant duration. The class Programmer implements the interface. As it implementing the Human interface it must provide the body of all the methods those defined in the Human interface. Implementing an Interface in Java Example-2 \u00b6 1 2 3 interface Polygon { void getArea ( int length , int breadth ); } 1 2 3 4 5 6 7 8 // implement the Polygon interface class Rectangle implements Polygon { // implementation of abstract method public void getArea ( int length , int breadth ) { System . out . println ( \"The area of the rectangle is \" + ( length * breadth )); } } Implementing an Interface in Java Example-2 \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Rectangle r1 = new Rectangle (); r1 . getArea ( 5 , 6 ); } } Implementing an Interface in Java Example-3 \u00b6 1 2 3 4 // create an interface interface Language { void getName ( String name ); } 1 2 3 4 5 6 7 8 // class implements interface class ProgrammingLanguage implements Language { // implementation of abstract method public void getName ( String name ) { System . out . println ( \"Programming Language: \" + name ); } } Implementing an Interface in Java Example-3 \u00b6 1 2 3 4 5 6 class Main { public static void main ( String [] args ) { ProgrammingLanguage language = new ProgrammingLanguage (); language . getName ( \"Java\" ); } } Implementing multiple Interfaces \u00b6 When a class wants to implement more than one interface, we use the implements keyword is followed by a comma-separated list of the interfaces implemented by the class. Implementing multiple Interfaces \u00b6 The following is the syntax for defineing a class that implements multiple interfaces. 1 2 3 4 5 class className implements InterfaceName1 , InterfaceName2 , ...{ ... boby - of - the - class ... } Implementing multiple Interfaces Example-1 \u00b6 In the example we defined a class that implements multiple interfaces. 1 2 3 4 interface Human { void learn ( String str ); void work (); } 1 2 3 4 interface Recruitment { boolean screening ( int score ); boolean interview ( boolean selected ); } Implementing multiple Interfaces Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Programmer implements Human , Recruitment { public void learn ( String str ) { System . out . println ( \"Learn using \" + str ); } public boolean screening ( int score ) { System . out . println ( \"Attend screening test\" ); int thresold = 20 ; if ( score > thresold ) return true ; return false ; } public boolean interview ( boolean selected ) { System . out . println ( \"Attend interview\" ); if ( selected ) return true ; return false ; } public void work () { System . out . println ( \"Develop applications\" ); } } Implementing multiple Interfaces Example-1 \u00b6 1 2 3 4 5 6 7 8 9 public class HumanTest { public static void main ( String [] args ) { Programmer trainee = new Programmer (); trainee . learn ( \"Coding\" ); trainee . screening ( 30 ); trainee . interview ( true ); trainee . work (); } } In the example, two interfaces Human and Recruitment , and a class Programmer implements both the interfaces. Implementing multiple Interfaces Example-2 \u00b6 1 2 3 interface A { // members of A } 1 2 3 interface B { // members of B } 1 2 3 4 class C implements A , B { // abstract members of A // abstract members of B } Nested Interfaces in Java \u00b6 Nested Interfaces in Java \u00b6 In java, an interface may be defined inside another interface, and also inside a class. The interface that defined inside another interface or a class is konwn as nested interface. The nested interface is also refered as inner interface. Nested Interfaces in Java \u00b6 The nested interface declared within an interface is public by default. The nested interface declared within a class can be with any access modifier. Every nested interface is static by default. Nested Interfaces in Java \u00b6 The nested interface cannot be accessed directly. We can only access the nested interface by using outer interface or outer class name followed by dot( . ), followed by the nested interface name. Nested interface inside another interface Example \u00b6 The nested interface that defined inside another interface must be accessed as OuterInterface.InnerInterface . 1 2 3 4 5 6 7 interface OuterInterface { void outerMethod (); interface InnerInterface { void innerMethod (); } } Nested interface inside another interface Example \u00b6 1 2 3 4 5 class OnlyOuter implements OuterInterface { public void outerMethod () { System . out . println ( \"This is OuterInterface method\" ); } } 1 2 3 4 5 class OnlyInner implements OuterInterface . InnerInterface { public void innerMethod () { System . out . println ( \"This is InnerInterface method\" ); } } Nested interface inside another interface Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 public class NestedInterfaceExample { public static void main ( String [] args ) { OnlyOuter obj_1 = new OnlyOuter (); OnlyInner obj_2 = new OnlyInner (); obj_1 . outerMethod (); obj_2 . innerMethod (); } } Nested interface inside a class Example \u00b6 The nested interface that defined inside a class must be accessed as ClassName.InnerInterface 1 2 3 4 5 6 class OuterClass { interface InnerInterface { void innerMethod (); } } Nested interface inside a class Example \u00b6 1 2 3 4 5 class ImplementingClass implements OuterClass . InnerInterface { public void innerMethod () { System . out . println ( \"This is InnerInterface method\" ); } } Nested interface inside a class Example \u00b6 1 2 3 4 5 6 7 8 9 public class NestedInterfaceExample { public static void main ( String [] args ) { ImplementingClass obj = new ImplementingClass (); obj . innerMethod (); } } Variables in Java Interfaces \u00b6 Variables in Java Interfaces \u00b6 In java, an interface is a completely abstract class. An interface is a container of abstract methods and static final variables. The interface contains the static final variables. The variables defined in an interface can not be modified by the class that implements the interface, but it may use as it defined in the interface. Variables in Java Interfaces \u00b6 The variable in an interface is public, static, and final by default. If any variable in an interface is defined without public, static, and final keywords then, the compiler automatically adds the same. No access modifier is allowed except the public for interface variables. Every variable of an interface must be initialized in the interface itself. The class that implements an interface can not modify the interface variable, but it may use as it defined in the interface. Variables in Java Interfaces Example-1 \u00b6 1 2 3 4 5 6 7 interface SampleInterface { int UPPER_LIMIT = 100 ; //int LOWER_LIMIT; // Error - must be initialised } 1 2 3 4 5 6 7 8 9 public class InterfaceVariablesExample implements SampleInterface { public static void main ( String [] args ) { System . out . println ( \"UPPER LIMIT = \" + UPPER_LIMIT ); // UPPER_LIMIT = 150; // Can not be modified } } Extending an Interface in java \u00b6 Extending an Interface in java \u00b6 In java, an interface can extend another interface. When an interface wants to extend another interface, it uses the keyword extends. The interface that extends another interface has its own members and all the members defined in its parent interface too. The class which implements a child interface needs to provide code for the methods defined in both child and parent interfaces, otherwise, it needs to be defined as abstract class. Extending an Interface in Java \u00b6 An interface can extend another interface. An interface can not extend multiple interfaces. An interface can implement neither an interface nor a class. The class that implements child interface needs to provide code for all the methods defined in both child and parent interfaces. Extending an Interface in Java Example-1 \u00b6 1 2 3 interface ParentInterface { void parentMethod (); } 1 2 3 interface ChildInterface extends ParentInterface { void childMethod (); } Extending an Interface in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 class ImplementingClass implements ChildInterface { public void childMethod () { System . out . println ( \"Child Interface method!!\" ); } public void parentMethod () { System . out . println ( \"Parent Interface mehtod!\" ); } } Extending an Interface in Java Example-1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 public class ExtendingAnInterface { public static void main ( String [] args ) { ImplementingClass obj = new ImplementingClass (); obj . childMethod (); obj . parentMethod (); } } Extending an Interface in Java Example-2 \u00b6 Here, the Polygon interface extends the Line interface. Now, if any class implements Polygon, it should provide implementations for all the abstract methods of both Line and Polygon 1 2 3 4 5 6 7 8 9 interface Line { // members of Line interface } // extending interface interface Polygon extends Line { // members of Polygon interface // members of Line interface } Extending Multiple Interfaces in Java Example \u00b6 1 2 3 interface A { ... } 1 2 3 interface B { ... } 1 2 3 interface C extends A , B { ... } Advantages of Interface in Java \u00b6 Advantages of Interface in Java \u00b6 Similar to abstract classes, interfaces help us to achieve abstraction in Java Here, we know getArea() calculates the area of polygons but the way area is calculated is different for different polygons. Hence, the implementation of getArea() is independent of one another. Advantages of Interface in Java \u00b6 Interfaces provide specifications that a class (which implements it) must follow. In our previous example, we have used getArea() as a specification inside the interface Polygon. This is like setting a rule that we should be able to get the area of every polygon. Now any class that implements the Polygon interface must provide an implementation for the getArea() method. Advantages of Interface in Java \u00b6 Interfaces are also used to achieve multiple inheritance in Java In the example, the class Rectangle is implementing two different interfaces. This is how we achieve multiple inheritance in Java. 1 2 3 4 5 6 7 8 9 10 11 interface Line { \u2026 } interface Polygon { \u2026 } class Rectangle implements Line , Polygon { \u2026 } Advantages of Interface in Java \u00b6 All the methods inside an interface are implicitly public and all fields are implicitly public static final. For example, 1 2 3 4 5 6 7 8 interface Language { // by default public static final String type = \"programming language\" ; // by default public void getName (); } default methods in Java Interfaces \u00b6 default methods in Java Interfaces \u00b6 With the release of Java 8, we can now add methods with implementation inside an interface. These methods are called default methods. To declare default methods inside interfaces, we use the default keyword. For example, 1 2 3 public default void getSides () { // body of getSides() } why default methods in Java Interfaces \u00b6 Let's take a scenario to understand why default methods are introduced in Java. Suppose, we need to add a new method in an interface. We can add the method in our interface easily without implementation. However, that's not the end of the story. All our classes that implement that interface must provide an implementation for the method. If a large number of classes were implementing this interface, we need to track all these classes and make changes to them. This is not only tedious but error-prone as well. To resolve this, Java introduced default methods. Default methods are inherited like ordinary methods. Default Method in Java Interface Example \u00b6 1 2 3 4 5 6 7 8 interface Polygon { void getArea (); // default method default void getSides () { System . out . println ( \"I can get sides of a polygon.\" ); } } Default Method in Java Interface Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // implements the interface class Rectangle implements Polygon { public void getArea () { int length = 6 ; int breadth = 5 ; int area = length * breadth ; System . out . println ( \"The area of the rectangle is \" + area ); } // overrides the getSides() public void getSides () { System . out . println ( \"I have 4 sides.\" ); } } Default Method in Java Interface Example \u00b6 1 2 3 4 5 6 7 8 // implements the interface class Square implements Polygon { public void getArea () { int length = 5 ; int area = length * length ; System . out . println ( \"The area of the square is \" + area ); } } Default Method in Java Interface Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { // create an object of Rectangle Rectangle r1 = new Rectangle (); r1 . getArea (); r1 . getSides (); // create an object of Square Square s1 = new Square (); s1 . getArea (); s1 . getSides (); } } Default Method in Java Interface Example \u00b6 In the example, we have created an interface named Polygon. It has a default method getSides() and an abstract method getArea(). Here, we have created two classes Rectangle and Square that implement Polygon. The Rectangle class provides the implementation of the getArea() method and overrides the getSides() method. However, the Square class only provides the implementation of the getArea() method. Now, while calling the getSides() method using the Rectangle object, the overridden method is called. However, in the case of the Square object, the default method is called. private and static Methods in Interface \u00b6 private and static Methods in Interface \u00b6 The Java 8 also added another feature to include static methods inside an interface. Similar to a class, we can access static methods of an interface using its references. For example, 1 2 3 4 5 6 7 // create an interface interface Polygon { staticMethod (){..} } // access static method Polygon . staticMethod (); private and static Methods in Interface \u00b6 Note: With the release of Java 9, private methods are also supported in interfaces. We cannot create objects of an interface. Hence, private methods are used as helper methods that provide support to other methods in interfaces. Java Interface Practical Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // To use the sqrt function import java.lang.Math ; interface Polygon { void getArea (); // calculate the perimeter of a Polygon default void getPerimeter ( int ... sides ) { int perimeter = 0 ; for ( int side : sides ) { perimeter += side ; } System . out . println ( \"Perimeter: \" + perimeter ); } } Java Interface Practical Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Triangle implements Polygon { private int a , b , c ; private double s , area ; // initializing sides of a triangle Triangle ( int a , int b , int c ) { this . a = a ; this . b = b ; this . c = c ; s = 0 ; } // calculate the area of a triangle public void getArea () { s = ( double ) ( a + b + c ) / 2 ; area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )); System . out . println ( \"Area: \" + area ); } } Java Interface Practical Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { Triangle t1 = new Triangle ( 2 , 3 , 4 ); // calls the method of the Triangle class t1 . getArea (); // calls the method of Polygon t1 . getPerimeter ( 2 , 3 , 4 ); } } Java Interface Practical Example \u00b6 In the example, we have created an interface named Polygon. It includes a default method getPerimeter() and an abstract method getArea(). We can calculate the perimeter of all polygons in the same manner so we implemented the body of getPerimeter() in Polygon. Now, all polygons that implement Polygon can use getPerimeter() to calculate perimeter. However, the rule for calculating the area is different for different polygons. Hence, getArea() is included without implementation. Any class that implements Polygon must provide an implementation of getArea(). Java Reflection \u00b6 Java Reflection \u00b6 In Java, reflection allows us to inspect and manipulate classes, interfaces, constructors, methods, and fields at run time. There is a class in Java named Class that keeps all the information about objects and classes at runtime. The object of Class can be used to perform reflection. Reflection of Java Classes \u00b6 In order to reflect a Java class, we first need to create an object of Class. And, using the object we can call various methods to get information about methods, fields, and constructors present in a class. There exists three ways to create objects of Class: Reflection of Java Classes \u00b6 Using forName() method 1 2 3 4 5 class Dog {...} // create object of Class // to reflect the Dog class Class a = Class . forName ( \"Dog\" ); - Here, the forName() method takes the name of the class to be reflected as its argument. Reflection of Java Classes \u00b6 Using getClass() method 1 2 3 4 5 6 // create an object of Dog class Dog d1 = new Dog (); // create an object of Class // to reflect Dog Class b = d1 . getClass (); - Here, we are using the object of the Dog class to create an object of Class. Reflection of Java Classes \u00b6 Using .class extension 1 2 3 // create an object of Class // to reflect the Dog class Class c = Dog . class ; Now that we know how we can create objects of the Class. We can use this object to get information about the corresponding class at runtime. Java Class Reflection Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.Class ; import java.lang.reflect.* ; class Animal { } // put this class in different Dog.java file public class Dog extends Animal { public void display () { System . out . println ( \"I am a dog.\" ); } } Java Class Reflection Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // put this in Main.java file class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // get name of the class String name = obj . getName (); System . out . println ( \"Name: \" + name ); // get the access modifier of the class int modifier = obj . getModifiers (); // convert the access modifier to string String mod = Modifier . toString ( modifier ); System . out . println ( \"Modifier: \" + mod ); // get the superclass of Dog Class superClass = obj . getSuperclass (); System . out . println ( \"Superclass: \" + superClass . getName ()); } catch ( Exception e ) { e . printStackTrace ();} } } \u00b6 Java Class Reflection Example \u00b6 In the example, we have created a superclass: Animal and a subclass: Dog. Here, we are trying to inspect the class Dog. Notice the statement, 1 Class obj = d1 . getClass (); Here, we are creating an object obj of Class using the getClass() method. Using the object, we are calling different methods of Class. obj.getName() - returns the name of the class obj.getModifiers() - returns the access modifier of the class obj.getSuperclass() - returns the super class of the class Note: We are using the Modifier class to convert the integer access modifier to a string. Reflecting Fields, Methods, and Constructors \u00b6 The package java.lang.reflect provides classes that can be used for manipulating class members. For example, Method class - provides information about methods in a class Field class - provides information about fields in a class Constructor class - provides information about constructors in a class Reflection of Java Methods \u00b6 The Method class provides various methods that can be used to get information about the methods present in a class. Reflection of Java Methods Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.lang.Class ; import java.lang.reflect.* ; class Dog { // methods of the class public void display () { System . out . println ( \"I am a dog.\" ); } private void makeSound () { System . out . println ( \"Bark Bark\" ); } } Reflection of Java Methods Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // using object of Class to // get all the declared methods of Dog Method [] methods = obj . getDeclaredMethods (); ... Reflection of Java Methods Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... // create an object of the Method class for ( Method m : methods ) { // get names of methods System . out . println ( \"Method Name: \" + m . getName ()); // get the access modifier of methods int modifier = m . getModifiers (); System . out . println ( \"Modifier: \" + Modifier . toString ( modifier )); // get the return types of method System . out . println ( \"Return Types: \" + m . getReturnType ()); System . out . println ( \" \" ); } } catch ( Exception e ) { e . printStackTrace (); } } } Reflection of Java Methods Example \u00b6 In the example, we are trying to get information about the methods present in the Dog class. As mentioned earlier, we have first created an object obj of Class using the getClass() method. Notice the expression, 1 Method [] methods = obj . getDeclaredMethod (); Here, the getDeclaredMethod() returns all the methods present inside the class. Reflection of Java Methods Example \u00b6 Also, we have created an object m of the Method class. Here, m.getName() - returns the name of a method m.getModifiers() - returns the access modifier of methods in integer form m.getReturnType() - returns the return type of methods The Method class also provides various other methods that can be used to inspect methods at run time. Reflection of Java Fields \u00b6 Like methods, we can also inspect and modify different fields of a class using the methods of the Field class. Reflection of Java Public Fields Example \u00b6 1 2 3 4 5 6 import java.lang.Class ; import java.lang.reflect.* ; class Dog { public String type ; } Reflection of Java Public Fields Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // access and set the type field Field field1 = obj . getField ( \"type\" ); field1 . set ( d1 , \"labrador\" ); ... Reflection of Java Public Fields Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ... // get the value of the field type String typeValue = ( String ) field1 . get ( d1 ); System . out . println ( \"Value: \" + typeValue ); // get the access modifier of the field type int mod = field1 . getModifiers (); // convert the modifier to String form String modifier1 = Modifier . toString ( mod ); System . out . println ( \"Modifier: \" + modifier1 ); System . out . println ( \" \" ); } catch ( Exception e ) { e . printStackTrace (); } } } \u00b6 Reflection of Java Public Fields Example \u00b6 In the example, we have created a class named Dog. It includes a public field named type. Notice the statement, 1 Field field1 = obj . getField ( \"type\" ); Here, we are accessing the public field of the Dog class and assigning it to the object field1 of the Field class. We then used various methods of the Field class: field1.set() - sets the value of the field field1.get() - returns the value of field field1.getModifiers() - returns the value of the field in integer form Reflection of Java Private Fields Example \u00b6 Similarly, we can also access and modify private fields as well. However, the reflection of private field is little bit different than the public field Reflection of Java Private Fields Example \u00b6 1 2 3 4 5 6 import java.lang.Class ; import java.lang.reflect.* ; class Dog { private String color ; } Reflection of Java Private Fields Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // access the private field color Field field1 = obj . getDeclaredField ( \"color\" ); // allow modification of the private field field1 . setAccessible ( true ); ... Reflection of Java Private Fields Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... // set the value of color field1 . set ( d1 , \"brown\" ); // get the value of field color String colorValue = ( String ) field1 . get ( d1 ); System . out . println ( \"Value: \" + colorValue ); // get the access modifier of color int mod2 = field1 . getModifiers (); // convert the access modifier to string String modifier2 = Modifier . toString ( mod2 ); System . out . println ( \"Modifier: \" + modifier2 ); } catch ( Exception e ) { e . printStackTrace (); } } } Reflection of Java Private Fields Example \u00b6 In the example, we have created a class named Dog . The class contains a private field named color . Notice the statement. 1 2 Field field1 = obj . getDeclaredField ( \"color\" ); field1 . setAccessible ( true ); Here, we are accessing color and assigning it to the object field1 of the Field class. We then used field1 to modify the accessibility of color and allows us to make changes to it. We then used field1 to perform various operations on the private field color. Reflection of Java Constructor \u00b6 We can also inspect different constructors of a class using various methods provided by the Constructor class Reflection of Java Constructor Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.lang.Class ; import java.lang.reflect.* ; class Dog { // public constructor without parameter public Dog () { } // private constructor with a single parameter private Dog ( int age ) { } } Reflection of Java Constructor Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // get all constructors of Dog Constructor [] constructors = obj . getDeclaredConstructors (); ... Reflection of Java Constructor Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ... for ( Constructor c : constructors ) { // get the name of constructors System . out . println ( \"Constructor Name: \" + c . getName ()); // get the access modifier of constructors // convert it into string form int modifier = c . getModifiers (); String mod = Modifier . toString ( modifier ); System . out . println ( \"Modifier: \" + mod ); // get the number of parameters in constructors System . out . println ( \"Parameters: \" + c . getParameterCount ()); System . out . println ( \"\" ); } } catch ( Exception e ) { e . printStackTrace (); } } } Reflection of Java Constructor Example \u00b6 In the example, we have created a class named Dog. The class includes two constructors. We are using reflection to find the information about the constructors of the class. Notice the statement, 1 Constructor [] constructors = obj . getDeclaredConstructor (); Here, the we are accessing all the constructors present in Dog and assigning them to an array constructors of the Constructor type. We then used object c to get different informations about the constructor. c.getName() - returns the name of the constructor c.getModifiers() - returns the access modifiers of the constructor in integer form c.getParameterCount() - returns the number of parameters present in each constructor Java Wrapper Classes \u00b6 Java Wrapper Classes \u00b6 Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects Primitive Data Type \\(\\Longrightarrow\\) Wrapper Class byte \\(\\Longrightarrow\\) Byte short \\(\\Longrightarrow\\) Short int \\(\\Longrightarrow\\) Integer long \\(\\Longrightarrow\\) Long float \\(\\Longrightarrow\\) Float double \\(\\Longrightarrow\\) Double boolean \\(\\Longrightarrow\\) Boolean char \\(\\Longrightarrow\\) Character Java Wrapper Classes \u00b6 Sometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store objects) 1 ArrayList < int > myNumbers = new ArrayList < int > (); // Invalid 1 ArrayList < Integer > myNumbers = new ArrayList < Integer > (); // Valid Creating Wrapper Objects \u00b6 To create a wrapper object, use the wrapper class instead of the primitive type. To get the value, you can just print the object 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { Integer myInt = 5 ; Double myDouble = 5.99 ; Character myChar = 'A' ; System . out . println ( myInt ); System . out . println ( myDouble ); System . out . println ( myChar ); } } Creating Wrapper Objects \u00b6 Since you're now working with objects, you can use certain methods to get information about the specific object. For example, the following methods are used to get the value associated with the corresponding wrapper object: intValue() , byteValue() , shortValue() , longValue() , floatValue() , doubleValue() , charValue() , booleanValue() . Creating Wrapper Objects \u00b6 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { Integer myInt = 5 ; Double myDouble = 5.99 ; Character myChar = 'A' ; System . out . println ( myInt . intValue ()); System . out . println ( myDouble . doubleValue ()); System . out . println ( myChar . charValue ()); } } Creating Wrapper Objects \u00b6 Another useful method is the toString() method, which is used to convert wrapper objects to strings. In the following example, we convert an Integer to a String, and use the length() method of the String class to output the length of the \"string\": 1 2 3 4 5 6 7 public class Main { public static void main ( String [] args ) { Integer myInt = 100 ; String myString = myInt . toString (); System . out . println ( myString . length ()); } } Java Lambda Expressions \u00b6 Java Lambda Expressions \u00b6 Lambda Expressions were added in Java 8. A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method. Java Lambda Expressions Syntax \u00b6 The simplest lambda expression contains a single parameter and an expression: 1 parameter -> expression To use more than one parameter, wrap them in parentheses: 1 ( parameter1 , parameter2 ) -> expression Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement. 1 ( parameter1 , parameter2 ) -> { code block } Lambda expressions are usually passed as parameters to a function Using Lambda Expressions \u00b6 Use a lamba expression in the ArrayList's forEach() method to print every item in the list 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.ArrayList ; public class Main { public static void main ( String [] args ) { ArrayList < Integer > numbers = new ArrayList < Integer > (); numbers . add ( 5 ); numbers . add ( 9 ); numbers . add ( 8 ); numbers . add ( 1 ); numbers . forEach ( ( n ) -> { System . out . println ( n ); } ); } } Lambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the Consumer interface (found in the java.util package) used by lists. Using Lambda Expressions \u00b6 Use Java's Consumer interface to store a lambda expression in a variable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.ArrayList ; import java.util.function.Consumer ; public class Main { public static void main ( String [] args ) { ArrayList < Integer > numbers = new ArrayList < Integer > (); numbers . add ( 5 ); numbers . add ( 9 ); numbers . add ( 8 ); numbers . add ( 1 ); Consumer < Integer > method = ( n ) -> { System . out . println ( n ); }; numbers . forEach ( method ); } } To use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression: Using Lambda Expressions \u00b6 Create a method which takes a lambda expression as a parameter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface StringFunction { String run ( String str ); } public class Main { public static void main ( String [] args ) { StringFunction exclaim = ( s ) -> s + \"!\" ; StringFunction ask = ( s ) -> s + \"?\" ; printFormatted ( \"Hello\" , exclaim ); printFormatted ( \"Hello\" , ask ); } public static void printFormatted ( String str , StringFunction format ) { String result = format . run ( str ); System . out . println ( result ); } } References \u00b6 BTechSmartClass-Defining an Interface in Java BTechSmartClass-Implementing an Interface in Java BTechSmartClass-Nested Interfaces in java BTechSmartClass-Variables in Java Interfaces BTechSmartClass-Extending an Interface in java Programiz-Java Interface Programiz-Java Reflection W3schools-Java Wrapper Classes W3schools-Java Lambda Expressions","title":"Week-3 (OOP with Java Part-III)"},{"location":"week-3/ce204-week-3/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-3/ce204-week-3/#week-3-oop-with-java-iii","text":"","title":"Week-3 (OOP with Java-III)"},{"location":"week-3/ce204-week-3/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-3/ce204-week-3/#oop-with-java-iii","text":"","title":"OOP with Java-III"},{"location":"week-3/ce204-week-3/#outline-1","text":"Defining an Interface in Java Implementing an Interface in Java Nested Interfaces in Java Variables in Java Interfaces Extending an Interface in java","title":"Outline (1)"},{"location":"week-3/ce204-week-3/#outline-2","text":"Advantages of Interface in Java default methods in Java Interfaces private and static Methods in Interface Java Reflection Java Wrapper Classes Java Lambda Expressions","title":"Outline (2)"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java","text":"","title":"Defining an Interface in Java"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java_1","text":"In java, an interface is similar to a class, but it contains abstract methods and static final variables only. The interface in Java is another mechanism to achieve abstraction. We may think of an interface as a completely abstract class. None of the methods in the interface has an implementation, and all the variables in the interface are constants. All the methods of an interface, implemented by the class that implements it. The interface in java enables java to support multiple-inheritance. An interface may extend only one interface, but a class may implement any number of interfaces.","title":"Defining an Interface in Java"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java_2","text":"An interface is a container of abstract methods and static final variables. An interface, implemented by a class. (class implements interface). An interface may extend another interface. (Interface extends Interface). An interface never implements another interface, or class. A class may implement any number of interfaces. We can not instantiate an interface. Specifying the keyword abstract for interface methods is optional, it automatically added. All the members of an interface are public by default.","title":"Defining an Interface in Java"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java_3","text":"Defining an interface is similar to that of a class. We use the keyword interface to define an interface. All the members of an interface are public by default. The following is the syntax for defining an interface. 1 2 3 4 5 interface InterfaceName { ... members declaration ; ... }","title":"Defining an Interface in Java"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java_4","text":"In the example we defined an interface HumanInterfaceExample that contains two abstract methods learn(), work() and one constant duration. 1 2 3 4 5 6 7 8 interface HumanInterfaceExample { void learn ( String str ); void work (); int duration = 10 ; }","title":"Defining an Interface in Java"},{"location":"week-3/ce204-week-3/#defining-an-interface-in-java-example-1","text":"Every interface in Java is auto-completed by the compiler. For example, in the above example code, no member is defined as public, but all are public automatically. The above code automatically converted as follows. 1 2 3 4 5 6 7 8 interface HumanInterfaceExample { public abstract void learn ( String str ); public abstract void work (); public static final int duration = 10 ; }","title":"Defining an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java","text":"","title":"Implementing an Interface in Java"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java_1","text":"In java, an interface is implemented by a class. The class that implements an interface must provide code for all the methods defined in the interface, otherwise, it must be defined as an abstract class. The class uses a keyword implements to implement an interface. A class can implement any number of interfaces. When a class wants to implement more than one interface, we use the implements keyword is followed by a comma-separated list of the interfaces implemented by the class.","title":"Implementing an Interface in Java"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java_2","text":"The following is the syntax for defineing a class that implements an interface. 1 2 3 4 5 class className implements InterfaceName { ... boby - of - the - class ... }","title":"Implementing an Interface in Java"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-1","text":"1 2 3 4 5 6 7 8 interface Human { void learn ( String str ); void work (); int duration = 10 ; }","title":"Implementing an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-1_1","text":"1 2 3 4 5 6 7 8 class Programmer implements Human { public void learn ( String str ) { System . out . println ( \"Learn using \" + str ); } public void work () { System . out . println ( \"Develop applications\" ); } }","title":"Implementing an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-1_2","text":"1 2 3 4 5 6 7 8 public class HumanTest { public static void main ( String [] args ) { Programmer trainee = new Programmer (); trainee . learn ( \"coding\" ); trainee . work (); } }","title":"Implementing an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-1_3","text":"In the example we defined an interface Human that contains two abstract methods learn(), work() and one constant duration. The class Programmer implements the interface. As it implementing the Human interface it must provide the body of all the methods those defined in the Human interface.","title":"Implementing an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-2","text":"1 2 3 interface Polygon { void getArea ( int length , int breadth ); } 1 2 3 4 5 6 7 8 // implement the Polygon interface class Rectangle implements Polygon { // implementation of abstract method public void getArea ( int length , int breadth ) { System . out . println ( \"The area of the rectangle is \" + ( length * breadth )); } }","title":"Implementing an Interface in Java Example-2"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-2_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { Rectangle r1 = new Rectangle (); r1 . getArea ( 5 , 6 ); } }","title":"Implementing an Interface in Java Example-2"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-3","text":"1 2 3 4 // create an interface interface Language { void getName ( String name ); } 1 2 3 4 5 6 7 8 // class implements interface class ProgrammingLanguage implements Language { // implementation of abstract method public void getName ( String name ) { System . out . println ( \"Programming Language: \" + name ); } }","title":"Implementing an Interface in Java Example-3"},{"location":"week-3/ce204-week-3/#implementing-an-interface-in-java-example-3_1","text":"1 2 3 4 5 6 class Main { public static void main ( String [] args ) { ProgrammingLanguage language = new ProgrammingLanguage (); language . getName ( \"Java\" ); } }","title":"Implementing an Interface in Java Example-3"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces","text":"When a class wants to implement more than one interface, we use the implements keyword is followed by a comma-separated list of the interfaces implemented by the class.","title":"Implementing multiple Interfaces"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces_1","text":"The following is the syntax for defineing a class that implements multiple interfaces. 1 2 3 4 5 class className implements InterfaceName1 , InterfaceName2 , ...{ ... boby - of - the - class ... }","title":"Implementing multiple Interfaces"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces-example-1","text":"In the example we defined a class that implements multiple interfaces. 1 2 3 4 interface Human { void learn ( String str ); void work (); } 1 2 3 4 interface Recruitment { boolean screening ( int score ); boolean interview ( boolean selected ); }","title":"Implementing multiple Interfaces Example-1"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces-example-1_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Programmer implements Human , Recruitment { public void learn ( String str ) { System . out . println ( \"Learn using \" + str ); } public boolean screening ( int score ) { System . out . println ( \"Attend screening test\" ); int thresold = 20 ; if ( score > thresold ) return true ; return false ; } public boolean interview ( boolean selected ) { System . out . println ( \"Attend interview\" ); if ( selected ) return true ; return false ; } public void work () { System . out . println ( \"Develop applications\" ); } }","title":"Implementing multiple Interfaces Example-1"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces-example-1_2","text":"1 2 3 4 5 6 7 8 9 public class HumanTest { public static void main ( String [] args ) { Programmer trainee = new Programmer (); trainee . learn ( \"Coding\" ); trainee . screening ( 30 ); trainee . interview ( true ); trainee . work (); } } In the example, two interfaces Human and Recruitment , and a class Programmer implements both the interfaces.","title":"Implementing multiple Interfaces Example-1"},{"location":"week-3/ce204-week-3/#implementing-multiple-interfaces-example-2","text":"1 2 3 interface A { // members of A } 1 2 3 interface B { // members of B } 1 2 3 4 class C implements A , B { // abstract members of A // abstract members of B }","title":"Implementing multiple Interfaces Example-2"},{"location":"week-3/ce204-week-3/#nested-interfaces-in-java","text":"","title":"Nested Interfaces in Java"},{"location":"week-3/ce204-week-3/#nested-interfaces-in-java_1","text":"In java, an interface may be defined inside another interface, and also inside a class. The interface that defined inside another interface or a class is konwn as nested interface. The nested interface is also refered as inner interface.","title":"Nested Interfaces in Java"},{"location":"week-3/ce204-week-3/#nested-interfaces-in-java_2","text":"The nested interface declared within an interface is public by default. The nested interface declared within a class can be with any access modifier. Every nested interface is static by default.","title":"Nested Interfaces in Java"},{"location":"week-3/ce204-week-3/#nested-interfaces-in-java_3","text":"The nested interface cannot be accessed directly. We can only access the nested interface by using outer interface or outer class name followed by dot( . ), followed by the nested interface name.","title":"Nested Interfaces in Java"},{"location":"week-3/ce204-week-3/#nested-interface-inside-another-interface-example","text":"The nested interface that defined inside another interface must be accessed as OuterInterface.InnerInterface . 1 2 3 4 5 6 7 interface OuterInterface { void outerMethod (); interface InnerInterface { void innerMethod (); } }","title":"Nested interface inside another interface Example"},{"location":"week-3/ce204-week-3/#nested-interface-inside-another-interface-example_1","text":"1 2 3 4 5 class OnlyOuter implements OuterInterface { public void outerMethod () { System . out . println ( \"This is OuterInterface method\" ); } } 1 2 3 4 5 class OnlyInner implements OuterInterface . InnerInterface { public void innerMethod () { System . out . println ( \"This is InnerInterface method\" ); } }","title":"Nested interface inside another interface Example"},{"location":"week-3/ce204-week-3/#nested-interface-inside-another-interface-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 public class NestedInterfaceExample { public static void main ( String [] args ) { OnlyOuter obj_1 = new OnlyOuter (); OnlyInner obj_2 = new OnlyInner (); obj_1 . outerMethod (); obj_2 . innerMethod (); } }","title":"Nested interface inside another interface Example"},{"location":"week-3/ce204-week-3/#nested-interface-inside-a-class-example","text":"The nested interface that defined inside a class must be accessed as ClassName.InnerInterface 1 2 3 4 5 6 class OuterClass { interface InnerInterface { void innerMethod (); } }","title":"Nested interface inside a class Example"},{"location":"week-3/ce204-week-3/#nested-interface-inside-a-class-example_1","text":"1 2 3 4 5 class ImplementingClass implements OuterClass . InnerInterface { public void innerMethod () { System . out . println ( \"This is InnerInterface method\" ); } }","title":"Nested interface inside a class Example"},{"location":"week-3/ce204-week-3/#nested-interface-inside-a-class-example_2","text":"1 2 3 4 5 6 7 8 9 public class NestedInterfaceExample { public static void main ( String [] args ) { ImplementingClass obj = new ImplementingClass (); obj . innerMethod (); } }","title":"Nested interface inside a class Example"},{"location":"week-3/ce204-week-3/#variables-in-java-interfaces","text":"","title":"Variables in Java Interfaces"},{"location":"week-3/ce204-week-3/#variables-in-java-interfaces_1","text":"In java, an interface is a completely abstract class. An interface is a container of abstract methods and static final variables. The interface contains the static final variables. The variables defined in an interface can not be modified by the class that implements the interface, but it may use as it defined in the interface.","title":"Variables in Java Interfaces"},{"location":"week-3/ce204-week-3/#variables-in-java-interfaces_2","text":"The variable in an interface is public, static, and final by default. If any variable in an interface is defined without public, static, and final keywords then, the compiler automatically adds the same. No access modifier is allowed except the public for interface variables. Every variable of an interface must be initialized in the interface itself. The class that implements an interface can not modify the interface variable, but it may use as it defined in the interface.","title":"Variables in Java Interfaces"},{"location":"week-3/ce204-week-3/#variables-in-java-interfaces-example-1","text":"1 2 3 4 5 6 7 interface SampleInterface { int UPPER_LIMIT = 100 ; //int LOWER_LIMIT; // Error - must be initialised } 1 2 3 4 5 6 7 8 9 public class InterfaceVariablesExample implements SampleInterface { public static void main ( String [] args ) { System . out . println ( \"UPPER LIMIT = \" + UPPER_LIMIT ); // UPPER_LIMIT = 150; // Can not be modified } }","title":"Variables in Java Interfaces Example-1"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java","text":"","title":"Extending an Interface in java"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java_1","text":"In java, an interface can extend another interface. When an interface wants to extend another interface, it uses the keyword extends. The interface that extends another interface has its own members and all the members defined in its parent interface too. The class which implements a child interface needs to provide code for the methods defined in both child and parent interfaces, otherwise, it needs to be defined as abstract class.","title":"Extending an Interface in java"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java_2","text":"An interface can extend another interface. An interface can not extend multiple interfaces. An interface can implement neither an interface nor a class. The class that implements child interface needs to provide code for all the methods defined in both child and parent interfaces.","title":"Extending an Interface in Java"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java-example-1","text":"1 2 3 interface ParentInterface { void parentMethod (); } 1 2 3 interface ChildInterface extends ParentInterface { void childMethod (); }","title":"Extending an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java-example-1_1","text":"1 2 3 4 5 6 7 8 9 10 class ImplementingClass implements ChildInterface { public void childMethod () { System . out . println ( \"Child Interface method!!\" ); } public void parentMethod () { System . out . println ( \"Parent Interface mehtod!\" ); } }","title":"Extending an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java-example-1_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 public class ExtendingAnInterface { public static void main ( String [] args ) { ImplementingClass obj = new ImplementingClass (); obj . childMethod (); obj . parentMethod (); } }","title":"Extending an Interface in Java Example-1"},{"location":"week-3/ce204-week-3/#extending-an-interface-in-java-example-2","text":"Here, the Polygon interface extends the Line interface. Now, if any class implements Polygon, it should provide implementations for all the abstract methods of both Line and Polygon 1 2 3 4 5 6 7 8 9 interface Line { // members of Line interface } // extending interface interface Polygon extends Line { // members of Polygon interface // members of Line interface }","title":"Extending an Interface in Java Example-2"},{"location":"week-3/ce204-week-3/#extending-multiple-interfaces-in-java-example","text":"1 2 3 interface A { ... } 1 2 3 interface B { ... } 1 2 3 interface C extends A , B { ... }","title":"Extending Multiple Interfaces in Java Example"},{"location":"week-3/ce204-week-3/#advantages-of-interface-in-java","text":"","title":"Advantages of Interface in Java"},{"location":"week-3/ce204-week-3/#advantages-of-interface-in-java_1","text":"Similar to abstract classes, interfaces help us to achieve abstraction in Java Here, we know getArea() calculates the area of polygons but the way area is calculated is different for different polygons. Hence, the implementation of getArea() is independent of one another.","title":"Advantages of Interface in Java"},{"location":"week-3/ce204-week-3/#advantages-of-interface-in-java_2","text":"Interfaces provide specifications that a class (which implements it) must follow. In our previous example, we have used getArea() as a specification inside the interface Polygon. This is like setting a rule that we should be able to get the area of every polygon. Now any class that implements the Polygon interface must provide an implementation for the getArea() method.","title":"Advantages of Interface in Java"},{"location":"week-3/ce204-week-3/#advantages-of-interface-in-java_3","text":"Interfaces are also used to achieve multiple inheritance in Java In the example, the class Rectangle is implementing two different interfaces. This is how we achieve multiple inheritance in Java. 1 2 3 4 5 6 7 8 9 10 11 interface Line { \u2026 } interface Polygon { \u2026 } class Rectangle implements Line , Polygon { \u2026 }","title":"Advantages of Interface in Java"},{"location":"week-3/ce204-week-3/#advantages-of-interface-in-java_4","text":"All the methods inside an interface are implicitly public and all fields are implicitly public static final. For example, 1 2 3 4 5 6 7 8 interface Language { // by default public static final String type = \"programming language\" ; // by default public void getName (); }","title":"Advantages of Interface in Java"},{"location":"week-3/ce204-week-3/#default-methods-in-java-interfaces","text":"","title":"default methods in Java Interfaces"},{"location":"week-3/ce204-week-3/#default-methods-in-java-interfaces_1","text":"With the release of Java 8, we can now add methods with implementation inside an interface. These methods are called default methods. To declare default methods inside interfaces, we use the default keyword. For example, 1 2 3 public default void getSides () { // body of getSides() }","title":"default methods in Java Interfaces"},{"location":"week-3/ce204-week-3/#why-default-methods-in-java-interfaces","text":"Let's take a scenario to understand why default methods are introduced in Java. Suppose, we need to add a new method in an interface. We can add the method in our interface easily without implementation. However, that's not the end of the story. All our classes that implement that interface must provide an implementation for the method. If a large number of classes were implementing this interface, we need to track all these classes and make changes to them. This is not only tedious but error-prone as well. To resolve this, Java introduced default methods. Default methods are inherited like ordinary methods.","title":"why default methods in Java Interfaces"},{"location":"week-3/ce204-week-3/#default-method-in-java-interface-example","text":"1 2 3 4 5 6 7 8 interface Polygon { void getArea (); // default method default void getSides () { System . out . println ( \"I can get sides of a polygon.\" ); } }","title":"Default Method in Java Interface Example"},{"location":"week-3/ce204-week-3/#default-method-in-java-interface-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // implements the interface class Rectangle implements Polygon { public void getArea () { int length = 6 ; int breadth = 5 ; int area = length * breadth ; System . out . println ( \"The area of the rectangle is \" + area ); } // overrides the getSides() public void getSides () { System . out . println ( \"I have 4 sides.\" ); } }","title":"Default Method in Java Interface Example"},{"location":"week-3/ce204-week-3/#default-method-in-java-interface-example_2","text":"1 2 3 4 5 6 7 8 // implements the interface class Square implements Polygon { public void getArea () { int length = 5 ; int area = length * length ; System . out . println ( \"The area of the square is \" + area ); } }","title":"Default Method in Java Interface Example"},{"location":"week-3/ce204-week-3/#default-method-in-java-interface-example_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { // create an object of Rectangle Rectangle r1 = new Rectangle (); r1 . getArea (); r1 . getSides (); // create an object of Square Square s1 = new Square (); s1 . getArea (); s1 . getSides (); } }","title":"Default Method in Java Interface Example"},{"location":"week-3/ce204-week-3/#default-method-in-java-interface-example_4","text":"In the example, we have created an interface named Polygon. It has a default method getSides() and an abstract method getArea(). Here, we have created two classes Rectangle and Square that implement Polygon. The Rectangle class provides the implementation of the getArea() method and overrides the getSides() method. However, the Square class only provides the implementation of the getArea() method. Now, while calling the getSides() method using the Rectangle object, the overridden method is called. However, in the case of the Square object, the default method is called.","title":"Default Method in Java Interface Example"},{"location":"week-3/ce204-week-3/#private-and-static-methods-in-interface","text":"","title":"private and static Methods in Interface"},{"location":"week-3/ce204-week-3/#private-and-static-methods-in-interface_1","text":"The Java 8 also added another feature to include static methods inside an interface. Similar to a class, we can access static methods of an interface using its references. For example, 1 2 3 4 5 6 7 // create an interface interface Polygon { staticMethod (){..} } // access static method Polygon . staticMethod ();","title":"private and static Methods in Interface"},{"location":"week-3/ce204-week-3/#private-and-static-methods-in-interface_2","text":"Note: With the release of Java 9, private methods are also supported in interfaces. We cannot create objects of an interface. Hence, private methods are used as helper methods that provide support to other methods in interfaces.","title":"private and static Methods in Interface"},{"location":"week-3/ce204-week-3/#java-interface-practical-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // To use the sqrt function import java.lang.Math ; interface Polygon { void getArea (); // calculate the perimeter of a Polygon default void getPerimeter ( int ... sides ) { int perimeter = 0 ; for ( int side : sides ) { perimeter += side ; } System . out . println ( \"Perimeter: \" + perimeter ); } }","title":"Java Interface Practical Example"},{"location":"week-3/ce204-week-3/#java-interface-practical-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Triangle implements Polygon { private int a , b , c ; private double s , area ; // initializing sides of a triangle Triangle ( int a , int b , int c ) { this . a = a ; this . b = b ; this . c = c ; s = 0 ; } // calculate the area of a triangle public void getArea () { s = ( double ) ( a + b + c ) / 2 ; area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )); System . out . println ( \"Area: \" + area ); } }","title":"Java Interface Practical Example"},{"location":"week-3/ce204-week-3/#java-interface-practical-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 class Main { public static void main ( String [] args ) { Triangle t1 = new Triangle ( 2 , 3 , 4 ); // calls the method of the Triangle class t1 . getArea (); // calls the method of Polygon t1 . getPerimeter ( 2 , 3 , 4 ); } }","title":"Java Interface Practical Example"},{"location":"week-3/ce204-week-3/#java-interface-practical-example_3","text":"In the example, we have created an interface named Polygon. It includes a default method getPerimeter() and an abstract method getArea(). We can calculate the perimeter of all polygons in the same manner so we implemented the body of getPerimeter() in Polygon. Now, all polygons that implement Polygon can use getPerimeter() to calculate perimeter. However, the rule for calculating the area is different for different polygons. Hence, getArea() is included without implementation. Any class that implements Polygon must provide an implementation of getArea().","title":"Java Interface Practical Example"},{"location":"week-3/ce204-week-3/#java-reflection","text":"","title":"Java Reflection"},{"location":"week-3/ce204-week-3/#java-reflection_1","text":"In Java, reflection allows us to inspect and manipulate classes, interfaces, constructors, methods, and fields at run time. There is a class in Java named Class that keeps all the information about objects and classes at runtime. The object of Class can be used to perform reflection.","title":"Java Reflection"},{"location":"week-3/ce204-week-3/#reflection-of-java-classes","text":"In order to reflect a Java class, we first need to create an object of Class. And, using the object we can call various methods to get information about methods, fields, and constructors present in a class. There exists three ways to create objects of Class:","title":"Reflection of Java Classes"},{"location":"week-3/ce204-week-3/#reflection-of-java-classes_1","text":"Using forName() method 1 2 3 4 5 class Dog {...} // create object of Class // to reflect the Dog class Class a = Class . forName ( \"Dog\" ); - Here, the forName() method takes the name of the class to be reflected as its argument.","title":"Reflection of Java Classes"},{"location":"week-3/ce204-week-3/#reflection-of-java-classes_2","text":"Using getClass() method 1 2 3 4 5 6 // create an object of Dog class Dog d1 = new Dog (); // create an object of Class // to reflect Dog Class b = d1 . getClass (); - Here, we are using the object of the Dog class to create an object of Class.","title":"Reflection of Java Classes"},{"location":"week-3/ce204-week-3/#reflection-of-java-classes_3","text":"Using .class extension 1 2 3 // create an object of Class // to reflect the Dog class Class c = Dog . class ; Now that we know how we can create objects of the Class. We can use this object to get information about the corresponding class at runtime.","title":"Reflection of Java Classes"},{"location":"week-3/ce204-week-3/#java-class-reflection-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 import java.lang.Class ; import java.lang.reflect.* ; class Animal { } // put this class in different Dog.java file public class Dog extends Animal { public void display () { System . out . println ( \"I am a dog.\" ); } }","title":"Java Class Reflection Example"},{"location":"week-3/ce204-week-3/#java-class-reflection-example_1","text":"","title":"Java Class Reflection Example"},{"location":"week-3/ce204-week-3/#1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-put-this-in-mainjava-file-class-main-public-static-void-mainstring-args-try-create-an-object-of-dog-dog-d1-new-dog-create-an-object-of-class-using-getclass-class-obj-d1getclass-get-name-of-the-class-string-name-objgetname-systemoutprintlnname-name-get-the-access-modifier-of-the-class-int-modifier-objgetmodifiers-convert-the-access-modifier-to-string-string-mod-modifiertostringmodifier-systemoutprintlnmodifier-mod-get-the-superclass-of-dog-class-superclass-objgetsuperclass-systemoutprintlnsuperclass-superclassgetname-catch-exception-e-eprintstacktrace","text":"","title":" 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23// put this in Main.java file\nclass Main {\n  public static void main(String[] args) {\n    try {\n      // create an object of Dog\n      Dog d1 = new Dog();\n      // create an object of Class\n      // using getClass()\n      Class obj = d1.getClass();\n      // get name of the class\n      String name = obj.getName();\n      System.out.println(&quot;Name: &quot; + name);\n      // get the access modifier of the class\n      int modifier = obj.getModifiers();\n      // convert the access modifier to string\n      String mod = Modifier.toString(modifier);\n      System.out.println(&quot;Modifier: &quot; + mod);\n      // get the superclass of Dog\n      Class superClass = obj.getSuperclass();\n      System.out.println(&quot;Superclass: &quot; + superClass.getName());\n    }catch (Exception e) { e.printStackTrace();}\n  }\n}\n\n"},{"location":"week-3/ce204-week-3/#java-class-reflection-example_2","text":"In the example, we have created a superclass: Animal and a subclass: Dog. Here, we are trying to inspect the class Dog. Notice the statement, 1 Class obj = d1 . getClass (); Here, we are creating an object obj of Class using the getClass() method. Using the object, we are calling different methods of Class. obj.getName() - returns the name of the class obj.getModifiers() - returns the access modifier of the class obj.getSuperclass() - returns the super class of the class Note: We are using the Modifier class to convert the integer access modifier to a string.","title":"Java Class Reflection Example"},{"location":"week-3/ce204-week-3/#reflecting-fields-methods-and-constructors","text":"The package java.lang.reflect provides classes that can be used for manipulating class members. For example, Method class - provides information about methods in a class Field class - provides information about fields in a class Constructor class - provides information about constructors in a class","title":"Reflecting Fields, Methods, and Constructors"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods","text":"The Method class provides various methods that can be used to get information about the methods present in a class.","title":"Reflection of Java Methods"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.lang.Class ; import java.lang.reflect.* ; class Dog { // methods of the class public void display () { System . out . println ( \"I am a dog.\" ); } private void makeSound () { System . out . println ( \"Bark Bark\" ); } }","title":"Reflection of Java Methods Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // using object of Class to // get all the declared methods of Dog Method [] methods = obj . getDeclaredMethods (); ...","title":"Reflection of Java Methods Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... // create an object of the Method class for ( Method m : methods ) { // get names of methods System . out . println ( \"Method Name: \" + m . getName ()); // get the access modifier of methods int modifier = m . getModifiers (); System . out . println ( \"Modifier: \" + Modifier . toString ( modifier )); // get the return types of method System . out . println ( \"Return Types: \" + m . getReturnType ()); System . out . println ( \" \" ); } } catch ( Exception e ) { e . printStackTrace (); } } }","title":"Reflection of Java Methods Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods-example_3","text":"In the example, we are trying to get information about the methods present in the Dog class. As mentioned earlier, we have first created an object obj of Class using the getClass() method. Notice the expression, 1 Method [] methods = obj . getDeclaredMethod (); Here, the getDeclaredMethod() returns all the methods present inside the class.","title":"Reflection of Java Methods Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-methods-example_4","text":"Also, we have created an object m of the Method class. Here, m.getName() - returns the name of a method m.getModifiers() - returns the access modifier of methods in integer form m.getReturnType() - returns the return type of methods The Method class also provides various other methods that can be used to inspect methods at run time.","title":"Reflection of Java Methods Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-fields","text":"Like methods, we can also inspect and modify different fields of a class using the methods of the Field class.","title":"Reflection of Java Fields"},{"location":"week-3/ce204-week-3/#reflection-of-java-public-fields-example","text":"1 2 3 4 5 6 import java.lang.Class ; import java.lang.reflect.* ; class Dog { public String type ; }","title":"Reflection of Java Public Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-public-fields-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // access and set the type field Field field1 = obj . getField ( \"type\" ); field1 . set ( d1 , \"labrador\" ); ...","title":"Reflection of Java Public Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-public-fields-example_2","text":"","title":"Reflection of Java Public Fields Example"},{"location":"week-3/ce204-week-3/#1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-get-the-value-of-the-field-type-string-typevalue-string-field1getd1-systemoutprintlnvalue-typevalue-get-the-access-modifier-of-the-field-type-int-mod-field1getmodifiers-convert-the-modifier-to-string-form-string-modifier1-modifiertostringmod-systemoutprintlnmodifier-modifier1-systemoutprintln-catch-exception-e-eprintstacktrace","text":"","title":" 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19...\n      // get the value of the field type\n      String typeValue = (String) field1.get(d1);\n      System.out.println(&quot;Value: &quot; + typeValue);\n\n      // get the access modifier of the field type\n      int mod = field1.getModifiers();\n\n      // convert the modifier to String form\n      String modifier1 = Modifier.toString(mod);\n      System.out.println(&quot;Modifier: &quot; + modifier1);\n      System.out.println(&quot; &quot;);\n    }\n\n    catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n"},{"location":"week-3/ce204-week-3/#reflection-of-java-public-fields-example_3","text":"In the example, we have created a class named Dog. It includes a public field named type. Notice the statement, 1 Field field1 = obj . getField ( \"type\" ); Here, we are accessing the public field of the Dog class and assigning it to the object field1 of the Field class. We then used various methods of the Field class: field1.set() - sets the value of the field field1.get() - returns the value of field field1.getModifiers() - returns the value of the field in integer form","title":"Reflection of Java Public Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-private-fields-example","text":"Similarly, we can also access and modify private fields as well. However, the reflection of private field is little bit different than the public field","title":"Reflection of Java Private Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-private-fields-example_1","text":"1 2 3 4 5 6 import java.lang.Class ; import java.lang.reflect.* ; class Dog { private String color ; }","title":"Reflection of Java Private Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-private-fields-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // access the private field color Field field1 = obj . getDeclaredField ( \"color\" ); // allow modification of the private field field1 . setAccessible ( true ); ...","title":"Reflection of Java Private Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-private-fields-example_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... // set the value of color field1 . set ( d1 , \"brown\" ); // get the value of field color String colorValue = ( String ) field1 . get ( d1 ); System . out . println ( \"Value: \" + colorValue ); // get the access modifier of color int mod2 = field1 . getModifiers (); // convert the access modifier to string String modifier2 = Modifier . toString ( mod2 ); System . out . println ( \"Modifier: \" + modifier2 ); } catch ( Exception e ) { e . printStackTrace (); } } }","title":"Reflection of Java Private Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-private-fields-example_4","text":"In the example, we have created a class named Dog . The class contains a private field named color . Notice the statement. 1 2 Field field1 = obj . getDeclaredField ( \"color\" ); field1 . setAccessible ( true ); Here, we are accessing color and assigning it to the object field1 of the Field class. We then used field1 to modify the accessibility of color and allows us to make changes to it. We then used field1 to perform various operations on the private field color.","title":"Reflection of Java Private Fields Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-constructor","text":"We can also inspect different constructors of a class using various methods provided by the Constructor class","title":"Reflection of Java Constructor"},{"location":"week-3/ce204-week-3/#reflection-of-java-constructor-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.lang.Class ; import java.lang.reflect.* ; class Dog { // public constructor without parameter public Dog () { } // private constructor with a single parameter private Dog ( int age ) { } }","title":"Reflection of Java Constructor Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-constructor-example_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Main { public static void main ( String [] args ) { try { // create an object of Dog Dog d1 = new Dog (); // create an object of Class // using getClass() Class obj = d1 . getClass (); // get all constructors of Dog Constructor [] constructors = obj . getDeclaredConstructors (); ...","title":"Reflection of Java Constructor Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-constructor-example_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ... for ( Constructor c : constructors ) { // get the name of constructors System . out . println ( \"Constructor Name: \" + c . getName ()); // get the access modifier of constructors // convert it into string form int modifier = c . getModifiers (); String mod = Modifier . toString ( modifier ); System . out . println ( \"Modifier: \" + mod ); // get the number of parameters in constructors System . out . println ( \"Parameters: \" + c . getParameterCount ()); System . out . println ( \"\" ); } } catch ( Exception e ) { e . printStackTrace (); } } }","title":"Reflection of Java Constructor Example"},{"location":"week-3/ce204-week-3/#reflection-of-java-constructor-example_3","text":"In the example, we have created a class named Dog. The class includes two constructors. We are using reflection to find the information about the constructors of the class. Notice the statement, 1 Constructor [] constructors = obj . getDeclaredConstructor (); Here, the we are accessing all the constructors present in Dog and assigning them to an array constructors of the Constructor type. We then used object c to get different informations about the constructor. c.getName() - returns the name of the constructor c.getModifiers() - returns the access modifiers of the constructor in integer form c.getParameterCount() - returns the number of parameters present in each constructor","title":"Reflection of Java Constructor Example"},{"location":"week-3/ce204-week-3/#java-wrapper-classes","text":"","title":"Java Wrapper Classes"},{"location":"week-3/ce204-week-3/#java-wrapper-classes_1","text":"Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects Primitive Data Type \\(\\Longrightarrow\\) Wrapper Class byte \\(\\Longrightarrow\\) Byte short \\(\\Longrightarrow\\) Short int \\(\\Longrightarrow\\) Integer long \\(\\Longrightarrow\\) Long float \\(\\Longrightarrow\\) Float double \\(\\Longrightarrow\\) Double boolean \\(\\Longrightarrow\\) Boolean char \\(\\Longrightarrow\\) Character","title":"Java Wrapper Classes"},{"location":"week-3/ce204-week-3/#java-wrapper-classes_2","text":"Sometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store objects) 1 ArrayList < int > myNumbers = new ArrayList < int > (); // Invalid 1 ArrayList < Integer > myNumbers = new ArrayList < Integer > (); // Valid","title":"Java Wrapper Classes"},{"location":"week-3/ce204-week-3/#creating-wrapper-objects","text":"To create a wrapper object, use the wrapper class instead of the primitive type. To get the value, you can just print the object 1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { Integer myInt = 5 ; Double myDouble = 5.99 ; Character myChar = 'A' ; System . out . println ( myInt ); System . out . println ( myDouble ); System . out . println ( myChar ); } }","title":"Creating Wrapper Objects"},{"location":"week-3/ce204-week-3/#creating-wrapper-objects_1","text":"Since you're now working with objects, you can use certain methods to get information about the specific object. For example, the following methods are used to get the value associated with the corresponding wrapper object: intValue() , byteValue() , shortValue() , longValue() , floatValue() , doubleValue() , charValue() , booleanValue() .","title":"Creating Wrapper Objects"},{"location":"week-3/ce204-week-3/#creating-wrapper-objects_2","text":"1 2 3 4 5 6 7 8 9 10 public class Main { public static void main ( String [] args ) { Integer myInt = 5 ; Double myDouble = 5.99 ; Character myChar = 'A' ; System . out . println ( myInt . intValue ()); System . out . println ( myDouble . doubleValue ()); System . out . println ( myChar . charValue ()); } }","title":"Creating Wrapper Objects"},{"location":"week-3/ce204-week-3/#creating-wrapper-objects_3","text":"Another useful method is the toString() method, which is used to convert wrapper objects to strings. In the following example, we convert an Integer to a String, and use the length() method of the String class to output the length of the \"string\": 1 2 3 4 5 6 7 public class Main { public static void main ( String [] args ) { Integer myInt = 100 ; String myString = myInt . toString (); System . out . println ( myString . length ()); } }","title":"Creating Wrapper Objects"},{"location":"week-3/ce204-week-3/#java-lambda-expressions","text":"","title":"Java Lambda Expressions"},{"location":"week-3/ce204-week-3/#java-lambda-expressions_1","text":"Lambda Expressions were added in Java 8. A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.","title":"Java Lambda Expressions"},{"location":"week-3/ce204-week-3/#java-lambda-expressions-syntax","text":"The simplest lambda expression contains a single parameter and an expression: 1 parameter -> expression To use more than one parameter, wrap them in parentheses: 1 ( parameter1 , parameter2 ) -> expression Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement. 1 ( parameter1 , parameter2 ) -> { code block } Lambda expressions are usually passed as parameters to a function","title":"Java Lambda Expressions Syntax"},{"location":"week-3/ce204-week-3/#using-lambda-expressions","text":"Use a lamba expression in the ArrayList's forEach() method to print every item in the list 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.ArrayList ; public class Main { public static void main ( String [] args ) { ArrayList < Integer > numbers = new ArrayList < Integer > (); numbers . add ( 5 ); numbers . add ( 9 ); numbers . add ( 8 ); numbers . add ( 1 ); numbers . forEach ( ( n ) -> { System . out . println ( n ); } ); } } Lambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the Consumer interface (found in the java.util package) used by lists.","title":"Using Lambda Expressions"},{"location":"week-3/ce204-week-3/#using-lambda-expressions_1","text":"Use Java's Consumer interface to store a lambda expression in a variable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.ArrayList ; import java.util.function.Consumer ; public class Main { public static void main ( String [] args ) { ArrayList < Integer > numbers = new ArrayList < Integer > (); numbers . add ( 5 ); numbers . add ( 9 ); numbers . add ( 8 ); numbers . add ( 1 ); Consumer < Integer > method = ( n ) -> { System . out . println ( n ); }; numbers . forEach ( method ); } } To use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:","title":"Using Lambda Expressions"},{"location":"week-3/ce204-week-3/#using-lambda-expressions_2","text":"Create a method which takes a lambda expression as a parameter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface StringFunction { String run ( String str ); } public class Main { public static void main ( String [] args ) { StringFunction exclaim = ( s ) -> s + \"!\" ; StringFunction ask = ( s ) -> s + \"?\" ; printFormatted ( \"Hello\" , exclaim ); printFormatted ( \"Hello\" , ask ); } public static void printFormatted ( String str , StringFunction format ) { String result = format . run ( str ); System . out . println ( result ); } }","title":"Using Lambda Expressions"},{"location":"week-3/ce204-week-3/#references","text":"BTechSmartClass-Defining an Interface in Java BTechSmartClass-Implementing an Interface in Java BTechSmartClass-Nested Interfaces in java BTechSmartClass-Variables in Java Interfaces BTechSmartClass-Extending an Interface in java Programiz-Java Interface Programiz-Java Reflection W3schools-Java Wrapper Classes W3schools-Java Lambda Expressions","title":"References"},{"location":"week-4/ce204-week-4/","text":"CE204 Object-Oriented Programming \u00b6 Week-4 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-4 (UML)"},{"location":"week-4/ce204-week-4/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-4/ce204-week-4/#week-4-tbd","text":"","title":"Week-4 (TBD)"},{"location":"week-4/ce204-week-4/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-4/ce204-week-4/#title","text":"","title":"Title"},{"location":"week-4/ce204-week-4/#outline","text":"TBD","title":"Outline"},{"location":"week-4/ce204-week-4/#references","text":"TBD","title":"References"},{"location":"week-5/ce204-week-5/","text":"CE204 Object-Oriented Programming \u00b6 Week-5 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-5 (Plantuml)"},{"location":"week-5/ce204-week-5/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-5/ce204-week-5/#week-5-tbd","text":"","title":"Week-5 (TBD)"},{"location":"week-5/ce204-week-5/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-5/ce204-week-5/#title","text":"","title":"Title"},{"location":"week-5/ce204-week-5/#outline","text":"TBD","title":"Outline"},{"location":"week-5/ce204-week-5/#references","text":"TBD","title":"References"},{"location":"week-6/ce204-week-6/","text":"CE204 Object-Oriented Programming \u00b6 Week-6 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-6 (UMPLE-I)"},{"location":"week-6/ce204-week-6/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-6/ce204-week-6/#week-6-tbd","text":"","title":"Week-6 (TBD)"},{"location":"week-6/ce204-week-6/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-6/ce204-week-6/#title","text":"","title":"Title"},{"location":"week-6/ce204-week-6/#outline","text":"TBD","title":"Outline"},{"location":"week-6/ce204-week-6/#references","text":"TBD","title":"References"},{"location":"week-7/ce204-week-7/","text":"CE204 Object-Oriented Programming \u00b6 Week-7 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-7 (UMPLE-II)"},{"location":"week-7/ce204-week-7/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-7/ce204-week-7/#week-7-tbd","text":"","title":"Week-7 (TBD)"},{"location":"week-7/ce204-week-7/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-7/ce204-week-7/#title","text":"","title":"Title"},{"location":"week-7/ce204-week-7/#outline","text":"TBD","title":"Outline"},{"location":"week-7/ce204-week-7/#references","text":"TBD","title":"References"},{"location":"week-8/ce204-week-8-midterm/","text":"CE204 Object-Oriented Programming \u00b6 Week-8 (Midterm) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-8 (Midterm)"},{"location":"week-8/ce204-week-8-midterm/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-8/ce204-week-8-midterm/#week-8-midterm","text":"","title":"Week-8 (Midterm)"},{"location":"week-8/ce204-week-8-midterm/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-8/ce204-week-8-midterm/#title","text":"","title":"Title"},{"location":"week-8/ce204-week-8-midterm/#outline","text":"TBD","title":"Outline"},{"location":"week-8/ce204-week-8-midterm/#references","text":"TBD","title":"References"},{"location":"week-9/ce204-week-9/","text":"CE204 Object-Oriented Programming \u00b6 Week-9 (TBD) \u00b6 Spring Semester, 2021-2022 \u00b6 Download DOC , SLIDE , PPTX Title \u00b6 Outline \u00b6 TBD References \u00b6 TBD","title":"Week-9 (Using Design Patterns)"},{"location":"week-9/ce204-week-9/#ce204-object-oriented-programming","text":"","title":"CE204 Object-Oriented Programming"},{"location":"week-9/ce204-week-9/#week-9-tbd","text":"","title":"Week-9 (TBD)"},{"location":"week-9/ce204-week-9/#spring-semester-2021-2022","text":"Download DOC , SLIDE , PPTX","title":"Spring Semester, 2021-2022"},{"location":"week-9/ce204-week-9/#title","text":"","title":"Title"},{"location":"week-9/ce204-week-9/#outline","text":"TBD","title":"Outline"},{"location":"week-9/ce204-week-9/#references","text":"TBD","title":"References"}]}